<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√†ng Bu·ªôc L·ªìi v√† Mi·ªÅn Kh·∫£ Thi - Minh H·ªça T∆∞∆°ng T√°c</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="../math-config.js"></script>
    <style>
        body {
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }
        
        .header p {
            color: #666;
            margin: 10px 0 0 0;
            font-size: 1.1rem;
        }
        
        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .theory-section {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 5px solid #2196f3;
        }
        
        .theory-section h2 {
            color: #1976d2;
            margin: 0 0 20px 0;
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .interactive-section {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 5px solid #4caf50;
        }
        
        .interactive-section h2 {
            color: #2e7d32;
            margin: 0 0 20px 0;
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .math-content {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        .concept-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196f3;
        }
        
        .concept-box h4 {
            color: #1976d2;
            margin: 0 0 10px 0;
        }
        
        .visualization-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-top: 10px;
        }
        
        .container {
            display: flex;
            height: 70vh;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
        }
        
        canvas {
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .controls {
            width: 420px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-left: 2px solid #e0e0e0;
            overflow-y: auto;
        }
        
        .control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
        
        .constraint-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .constraint-item {
            background: rgba(0, 0, 0, 0.05);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 3px solid #2196f3;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            position: relative;
        }
        
        .constraint-item .remove-btn {
            position: absolute;
            right: 5px;
            top: 5px;
            background: #e74c3c;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 10px;
        }
        
        .constraint-type {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .constraint-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #2196f3;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .constraint-button:hover {
            background: #2196f3;
            color: white;
            transform: translateY(-2px);
        }
        
        .constraint-button.active {
            background: #2196f3;
            color: white;
        }
        
        .problem-info {
            background: rgba(33, 150, 243, 0.1);
            padding: 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
            border: 1px solid #2196f3;
        }
        
        .feasible-stats {
            background: rgba(76, 175, 80, 0.1);
            padding: 12px;
            border-radius: 5px;
            font-size: 12px;
            margin-bottom: 15px;
            border-left: 3px solid #4caf50;
            border: 1px solid #4caf50;
        }
        
        .toggle-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .toggle-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #2196f3;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .toggle-button:hover {
            background: #2196f3;
            color: white;
        }
        
        .toggle-button.active {
            background: #2196f3;
            color: white;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 350px;
            z-index: 10;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        
        .legend {
            font-size: 11px;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .legend-item {
            margin: 3px 0;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 12px;
            color: #2196f3;
            text-align: right;
            margin-top: 2px;
            font-weight: 600;
        }
        
        .constraint-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 5px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .constraint-inputs input {
            width: 100%;
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .constraint-inputs input:focus {
            border-color: #2196f3;
            outline: none;
        }
        
        .constraint-inputs select {
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .objective-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .objective-inputs input {
            width: 100%;
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .objective-inputs input:focus {
            border-color: #2196f3;
            outline: none;
        }
        
        .objective-inputs select {
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .preset-problems {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .preset-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #4caf50;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .preset-button:hover {
            background: #4caf50;
            color: white;
            transform: translateY(-2px);
        }
    </style>





</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>R√†ng Bu·ªôc L·ªìi v√† Mi·ªÅn Kh·∫£ Thi</h1>
            <p>Kh√°m ph√° t∆∞∆°ng t√°c v·ªÅ t·ªëi ∆∞u h√≥a c√≥ r√†ng bu·ªôc v√† h√¨nh h·ªçc mi·ªÅn kh·∫£ thi</p>
        </div>

        <div class="content-wrapper">
            <div class="theory-section">
                <h2>üìñ L√ù THUY·∫æT</h2>
                
                <div class="math-content">
                    <h3>1. R√†ng Bu·ªôc L·ªìi (Convex Constraints)</h3>
                    <p><strong>ƒê·ªãnh nghƒ©a:</strong> M·ªôt r√†ng bu·ªôc ƒë∆∞·ª£c g·ªçi l√† <em>l·ªìi</em> n·∫øu n√≥ c√≥ d·∫°ng:</p>
                    $$g(x) \leq 0$$
                    trong ƒë√≥ $g: \mathbb{R}^n \to \mathbb{R}$ l√† m·ªôt h√†m l·ªìi.
                    
                    <div class="concept-box">
                        <h4>C√°c lo·∫°i r√†ng bu·ªôc l·ªìi ph·ªï bi·∫øn:</h4>
                        <ul>
                            <li><strong>R√†ng bu·ªôc tuy·∫øn t√≠nh:</strong> $a^T x \leq b$</li>
                            <li><strong>R√†ng bu·ªôc b·∫≠c hai:</strong> $x^T Q x + p^T x + r \leq 0$ (v·ªõi $Q \succeq 0$)</li>
                            <li><strong>R√†ng bu·ªôc chu·∫©n:</strong> $\|x\|_p \leq t$ (v·ªõi $p \geq 1$)</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>2. Mi·ªÅn Kh·∫£ Thi (Feasible Region)</h3>
                    <p><strong>ƒê·ªãnh nghƒ©a:</strong> Mi·ªÅn kh·∫£ thi $\mathcal{F}$ l√† t·∫≠p h·ª£p t·∫•t c·∫£ c√°c ƒëi·ªÉm th·ªèa m√£n c√°c r√†ng bu·ªôc:</p>
                    $$\mathcal{F} = \{x \in \mathbb{R}^n : g_i(x) \leq 0, \; i = 1,\ldots,m\}$$
                    
                    <div class="concept-box">
                        <h4>T√≠nh ch·∫•t quan tr·ªçng:</h4>
                        <ul>
                            <li><strong>T·∫≠p l·ªìi:</strong> Giao c·ªßa c√°c t·∫≠p l·ªìi l√† t·∫≠p l·ªìi</li>
                            <li><strong>ƒê√≥ng:</strong> Mi·ªÅn kh·∫£ thi th∆∞·ªùng l√† t·∫≠p ƒë√≥ng</li>
                            <li><strong>ƒêa di·ªán:</strong> V·ªõi r√†ng bu·ªôc tuy·∫øn t√≠nh, mi·ªÅn kh·∫£ thi l√† ƒëa di·ªán l·ªìi</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>3. B√†i To√°n T·ªëi ∆Øu L·ªìi v·ªõi R√†ng Bu·ªôc</h3>
                    <p>D·∫°ng t·ªïng qu√°t:</p>
                    $$\begin{align}
                    \min \quad & f(x) \\
                    \text{s.t.} \quad & g_i(x) \leq 0, \quad i = 1,\ldots,m \\
                    & h_j(x) = 0, \quad j = 1,\ldots,p
                    \end{align}$$
                    
                    <div class="concept-box">
                        <h4>ƒêi·ªÅu ki·ªán KKT (Karush-Kuhn-Tucker):</h4>
                        <p>Cho ƒëi·ªÉm t·ªëi ∆∞u $x^*$, t·ªìn t·∫°i $\lambda \geq 0, \mu$ sao cho:</p>
                        <ul>
                            <li>$\nabla f(x^*) + \sum\limits_{i=1}^m \lambda_i \nabla g_i(x^*) + \sum\limits_{j=1}^p \mu_j \nabla h_j(x^*) = 0$</li>
                            <li>$g_i(x^*) \leq 0, \; \lambda_i \geq 0, \; \lambda_i g_i(x^*) = 0$</li>
                            <li>$h_j(x^*) = 0$</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>4. L·∫≠p Tr√¨nh Tuy·∫øn T√≠nh</h3>
                    <p>Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát v·ªõi h√†m m·ª•c ti√™u v√† r√†ng bu·ªôc ƒë·ªÅu tuy·∫øn t√≠nh:</p>
                    $$\begin{align}
                    \min \quad & c^T x \\
                    \text{s.t.} \quad & Ax \leq b \\
                    & x \geq 0
                    \end{align}$$
                    
                    <div class="concept-box">
                        <h4>ƒê·ªãnh l√Ω c∆° b·∫£n:</h4>
                        <ul>
                            <li><strong>ƒêi·ªÉm c·ª±c tr·ªã:</strong> Nghi·ªám t·ªëi ∆∞u n·∫±m t·∫°i ƒë·ªânh c·ªßa ƒëa di·ªán</li>
                            <li><strong>Duality:</strong> B√†i to√°n ƒë·ªëi ng·∫´u cung c·∫•p c·∫≠n d∆∞·ªõi</li>
                            <li><strong>Simplex:</strong> Thu·∫≠t to√°n di chuy·ªÉn gi·ªØa c√°c ƒë·ªânh li·ªÅn k·ªÅ</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="interactive-section">
                <h2>üéÆ MINH H·ªåA T∆Ø∆†NG T√ÅC</h2>
                
                <div class="visualization-container">
                    <p><strong>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:</strong></p>
                    <ul>
                        <li>üéØ <strong>Th√™m r√†ng bu·ªôc:</strong> Nh·∫≠p h·ªá s·ªë a, b, c cho r√†ng bu·ªôc ax + by ‚â§/‚â•/= c</li>
                        <li>üìä <strong>Thi·∫øt l·∫≠p h√†m m·ª•c ti√™u:</strong> Ch·ªçn h·ªá s·ªë v√† lo·∫°i t·ªëi ∆∞u (min/max)</li>
                        <li>üé≤ <strong>D√πng m·∫´u c√≥ s·∫µn:</strong> Ch·ªçn c√°c b√†i to√°n m·∫´u ƒë·ªÉ kh√°m ph√°</li>
                        <li>üëÅÔ∏è <strong>T√πy ch·ªânh hi·ªÉn th·ªã:</strong> B·∫≠t/t·∫Øt c√°c th√†nh ph·∫ßn tr·ª±c quan</li>
                    </ul>
                    
                    <div class="container">
                        <div class="canvas-container">
                            <canvas id="canvas" width="800" height="600"></canvas>
                            <div class="info-panel">
                                <strong>üéØ R√†ng Bu·ªôc L·ªìi & Mi·ªÅn Kh·∫£ Thi</strong><br/>
                                Kh√°m ph√° t∆∞∆°ng t√°c v·ªÅ t·ªëi ∆∞u h√≥a c√≥ r√†ng bu·ªôc v√† h√¨nh h·ªçc mi·ªÅn kh·∫£ thi.
                                <div class="legend">
                                    <div class="legend-item" style="color: #4caf50;">üü¢ Mi·ªÅn Kh·∫£ Thi</div>
                                    <div class="legend-item" style="color: #f44336;">üî¥ ƒê∆∞·ªùng R√†ng Bu·ªôc</div>
                                    <div class="legend-item" style="color: #ff9800;">üü† H√†m M·ª•c Ti√™u</div>
                                    <div class="legend-item" style="color: #9c27b0;">üü£ ƒêi·ªÉm T·ªëi ∆Øu</div>
                                    <div class="legend-item" style="color: #2196f3;">üîµ H∆∞·ªõng Gradient</div>
                                    <div class="legend-item" style="color: #ff5722;">üü§ ƒêi·ªÉm ƒê·ªânh</div>
                                </div>
                            </div>
                        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>H√†m M·ª•c Ti√™u</h3>
                <div class="objective-inputs">
                    <input type="number" id="objA" step="0.1" value="1" placeholder="coeff x">
                    <input type="number" id="objB" step="0.1" value="1" placeholder="coeff y">
                    <select id="objType">
                        <option value="minimize">T·ªëi thi·ªÉu h√≥a</option>
                        <option value="maximize">T·ªëi ƒëa h√≥a</option>
                    </select>
                </div>
                <div id="objective-display" class="problem-info">
                    T·ªëi thi·ªÉu h√≥a: f(x,y) = x + y
                </div>
            </div>
            
            <div class="control-section">
                <h3>Th√™m R√†ng Bu·ªôc</h3>
                <div class="constraint-inputs">
                    <input type="number" id="constraintA" step="0.1" value="1" placeholder="a">
                    <input type="number" id="constraintB" step="0.1" value="0" placeholder="b">
                    <select id="constraintType">
                        <option value="‚â§">‚â§</option>
                        <option value="‚â•">‚â•</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" id="constraintC" step="0.1" value="1" placeholder="c">
                </div>
                <div class="constraint-type">
                    <button class="constraint-button" onclick="addConstraint()">Th√™m R√†ng Bu·ªôc</button>
                    <button class="constraint-button" onclick="clearConstraints()">X√≥a T·∫•t C·∫£</button>
                    <button class="constraint-button" onclick="solveOptimization()">üéØ Gi·∫£i</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>B√†i To√°n M·∫´u</h3>
                <div class="preset-problems">
                    <button class="preset-button" onclick="loadPreset('simple')">LP ƒê∆°n Gi·∫£n</button>
                    <button class="preset-button" onclick="loadPreset('bounded')">Mi·ªÅn B·ªã Ch·∫∑n</button>
                    <button class="preset-button" onclick="loadPreset('unbounded')">Kh√¥ng B·ªã Ch·∫∑n</button>
                    <button class="preset-button" onclick="loadPreset('infeasible')">V√¥ Nghi·ªám</button>
                    <button class="preset-button" onclick="loadPreset('degenerate')">Suy Bi·∫øn</button>
                    <button class="preset-button" onclick="loadPreset('polytope')">ƒêa Di·ªán Ph·ª©c T·∫°p</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>R√†ng Bu·ªôc Hi·ªán T·∫°i</h3>
                <div id="constraint-list" class="constraint-list">
                    <!-- Constraints will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>T√πy Ch·ªçn Hi·ªÉn Th·ªã</h3>
                <div class="toggle-section">
                    <div class="toggle-button active" id="toggle-feasible" onclick="toggleVisualization('feasible')">
                        Mi·ªÅn Kh·∫£ Thi
                    </div>
                    <div class="toggle-button active" id="toggle-constraints" onclick="toggleVisualization('constraints')">
                        ƒê∆∞·ªùng R√†ng Bu·ªôc
                    </div>
                    <div class="toggle-button active" id="toggle-objective" onclick="toggleVisualization('objective')">
                        ƒê∆∞·ªùng M·ª•c Ti√™u
                    </div>
                    <div class="toggle-button active" id="toggle-gradient" onclick="toggleVisualization('gradient')">
                        Gradient
                    </div>
                    <div class="toggle-button active" id="toggle-vertices" onclick="toggleVisualization('vertices')">
                        ƒêi·ªÉm ƒê·ªânh
                    </div>
                    <div class="toggle-button active" id="toggle-optimal" onclick="toggleVisualization('optimal')">
                        ƒêi·ªÉm T·ªëi ∆Øu
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Ph√¢n T√≠ch B√†i To√°n</h3>
                <div id="feasible-stats" class="feasible-stats">
                    <!-- Problem statistics will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>ƒêi·ªÅu Khi·ªÉn T∆∞∆°ng T√°c</h3>
                <div class="slider-group">
                    <label>M·ª©c H√†m M·ª•c Ti√™u:</label>
                    <input type="range" id="objectiveLevel" min="-10" max="10" step="0.1" value="0">
                    <div class="slider-value" id="objectiveLevelValue">0.0</div>
                </div>
                <div class="toggle-section">
                    <div class="toggle-button" onclick="resetView()">
                        üîÑ ƒê·∫∑t L·∫°i
                    </div>
                    <div class="toggle-button" onclick="randomProblem()">
                        üé≤ B√†i To√°n Ng·∫´u Nhi√™n
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 60;
        
        // Problem state
        let constraints = [];
        let objective = { a: 1, b: 1, type: 'minimize' };
        let feasibleRegion = [];
        let vertices = [];
        let optimalPoint = null;
        let optimalValue = null;
        let objectiveLevel = 0;
        
        // Visualization options
        let showOptions = {
            feasible: true,
            constraints: true,
            objective: true,
            gradient: true,
            vertices: true,
            optimal: true
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function addConstraint() {
            const a = parseFloat(document.getElementById('constraintA').value) || 0;
            const b = parseFloat(document.getElementById('constraintB').value) || 0;
            const type = document.getElementById('constraintType').value;
            const c = parseFloat(document.getElementById('constraintC').value) || 0;
            
            if (Math.abs(a) < 1e-10 && Math.abs(b) < 1e-10) {
                alert('C·∫£ hai h·ªá s·ªë kh√¥ng th·ªÉ b·∫±ng 0');
                return;
            }
            
            const constraint = { a, b, type, c, id: Date.now() };
            constraints.push(constraint);
            
            updateConstraintList();
            updateProblem();
        }
        
        function removeConstraint(id) {
            constraints = constraints.filter(c => c.id !== id);
            updateConstraintList();
            updateProblem();
        }
        
        function clearConstraints() {
            constraints = [];
            updateConstraintList();
            updateProblem();
        }
        
        function updateConstraintList() {
            const list = document.getElementById('constraint-list');
            list.innerHTML = '';
            
            constraints.forEach((constraint, index) => {
                const div = document.createElement('div');
                div.className = 'constraint-item';
                div.innerHTML = `
                    <span>${constraint.a.toFixed(2)}x + ${constraint.b.toFixed(2)}y ${constraint.type} ${constraint.c.toFixed(2)}</span>
                    <button class="remove-btn" onclick="removeConstraint(${constraint.id})">√ó</button>
                `;
                list.appendChild(div);
            });
        }
        
        function updateObjective() {
            const a = parseFloat(document.getElementById('objA').value) || 0;
            const b = parseFloat(document.getElementById('objB').value) || 0;
            const type = document.getElementById('objType').value;
            
            objective = { a, b, type };
            
            const typeText = type === 'minimize' ? 'T·ªëi thi·ªÉu h√≥a' : 'T·ªëi ƒëa h√≥a';
            document.getElementById('objective-display').innerHTML = 
                `${typeText}: f(x,y) = ${a.toFixed(2)}x + ${b.toFixed(2)}y`;
            
            updateProblem();
        }
        
        function updateProblem() {
            findFeasibleRegion();
            findVertices();
            solveOptimization();
            updateProblemStats();
            draw();
        }
        
        function findFeasibleRegion() {
            feasibleRegion = [];
            
            // Create a grid of points and test each one
            const step = 0.2;
            for (let x = -8; x <= 8; x += step) {
                for (let y = -6; y <= 6; y += step) {
                    if (isPointFeasible(x, y)) {
                        feasibleRegion.push({ x, y });
                    }
                }
            }
        }
        
        function isPointFeasible(x, y) {
            return constraints.every(constraint => {
                const value = constraint.a * x + constraint.b * y;
                switch (constraint.type) {
                    case '‚â§': return value <= constraint.c + 1e-10;
                    case '‚â•': return value >= constraint.c - 1e-10;
                    case '=': return Math.abs(value - constraint.c) < 1e-6;
                    default: return true;
                }
            });
        }
        
        function findVertices() {
            vertices = [];
            
            if (constraints.length < 2) return;
            
            // Find intersections of constraint lines
            for (let i = 0; i < constraints.length; i++) {
                for (let j = i + 1; j < constraints.length; j++) {
                    const intersection = findIntersection(constraints[i], constraints[j]);
                    if (intersection && isPointFeasible(intersection.x, intersection.y)) {
                        // Check if vertex is not too close to existing vertices
                        const isDuplicate = vertices.some(v => 
                            Math.abs(v.x - intersection.x) < 1e-6 && 
                            Math.abs(v.y - intersection.y) < 1e-6
                        );
                        
                        if (!isDuplicate && Math.abs(intersection.x) < 20 && Math.abs(intersection.y) < 20) {
                            vertices.push(intersection);
                        }
                    }
                }
            }
            
            // Also check intersections with axes bounds
            const bounds = [
                { a: 1, b: 0, c: 8 },   // x ‚â§ 8
                { a: -1, b: 0, c: 8 },  // x ‚â• -8
                { a: 0, b: 1, c: 6 },   // y ‚â§ 6
                { a: 0, b: -1, c: 6 }   // y ‚â• -6
            ];
            
            bounds.forEach(bound => {
                constraints.forEach(constraint => {
                    const intersection = findIntersection(bound, constraint);
                    if (intersection && isPointFeasible(intersection.x, intersection.y)) {
                        const isDuplicate = vertices.some(v => 
                            Math.abs(v.x - intersection.x) < 1e-6 && 
                            Math.abs(v.y - intersection.y) < 1e-6
                        );
                        
                        if (!isDuplicate) {
                            vertices.push(intersection);
                        }
                    }
                });
            });
        }
        
        function findIntersection(constraint1, constraint2) {
            const { a: a1, b: b1, c: c1 } = constraint1;
            const { a: a2, b: b2, c: c2 } = constraint2;
            
            const det = a1 * b2 - a2 * b1;
            if (Math.abs(det) < 1e-10) return null; // Parallel lines
            
            const x = (c1 * b2 - c2 * b1) / det;
            const y = (a1 * c2 - a2 * c1) / det;
            
            return { x, y };
        }
        
        function solveOptimization() {
            optimalPoint = null;
            optimalValue = null;
            
            if (vertices.length === 0) return;
            
            let bestPoint = null;
            let bestValue = objective.type === 'minimize' ? Infinity : -Infinity;
            
            vertices.forEach(vertex => {
                const value = objective.a * vertex.x + objective.b * vertex.y;
                
                if ((objective.type === 'minimize' && value < bestValue) ||
                    (objective.type === 'maximize' && value > bestValue)) {
                    bestValue = value;
                    bestPoint = vertex;
                }
            });
            
            optimalPoint = bestPoint;
            optimalValue = bestValue;
        }
        
        function updateProblemStats() {
            const stats = document.getElementById('feasible-stats');
            
            let status = 'Ch∆∞a x√°c ƒë·ªãnh';
            if (feasibleRegion.length === 0) {
                status = 'V√¥ nghi·ªám - Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm kh·∫£ thi';
            } else if (vertices.length === 0) {
                status = 'Kh√¥ng b·ªã ch·∫∑n - Kh√¥ng c√≥ ƒëi·ªÉm ƒë·ªânh';
            } else if (optimalPoint) {
                status = 'ƒê√£ t√¨m th·∫•y nghi·ªám t·ªëi ∆∞u';
            }
            
            stats.innerHTML = `
                <strong>Ph√¢n t√≠ch b√†i to√°n:</strong><br/>
                Tr·∫°ng th√°i: ${status}<br/>
                ƒêi·ªÉm kh·∫£ thi: ${feasibleRegion.length}<br/>
                ƒêi·ªÉm ƒë·ªânh: ${vertices.length}<br/>
                ${optimalPoint ? `ƒêi·ªÉm t·ªëi ∆∞u: (${optimalPoint.x.toFixed(3)}, ${optimalPoint.y.toFixed(3)})<br/>` : ''}
                ${optimalValue !== null ? `Gi√° tr·ªã t·ªëi ∆∞u: ${optimalValue.toFixed(3)}` : ''}
            `;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -20; i <= 20; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawFeasibleRegion() {
            if (!showOptions.feasible || feasibleRegion.length === 0) return;
            
            ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
            feasibleRegion.forEach(point => {
                ctx.fillRect(toCanvasX(point.x) - 1, toCanvasY(point.y) - 1, 2, 2);
            });
        }
        
        function drawConstraints() {
            if (!showOptions.constraints) return;
            
            constraints.forEach((constraint, index) => {
                const colors = ['#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#e67e22', '#2ecc71'];
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2;
                
                // Draw constraint line
                drawConstraintLine(constraint);
                
                // Draw constraint label
                ctx.fillStyle = colors[index % colors.length];
                ctx.font = '12px Arial';
                ctx.fillText(
                    `${constraint.a.toFixed(1)}x + ${constraint.b.toFixed(1)}y ${constraint.type} ${constraint.c.toFixed(1)}`,
                    10,
                    20 + index * 16
                );
            });
        }
        
        function drawConstraintLine(constraint) {
            const { a, b, c } = constraint;
            
            // Find two points on the line ax + by = c
            let x1, y1, x2, y2;
            
            if (Math.abs(b) > 1e-10) {
                // Vertical line case
                x1 = -10;
                y1 = (c - a * x1) / b;
                x2 = 10;
                y2 = (c - a * x2) / b;
            } else {
                // Horizontal line case
                x1 = c / a;
                y1 = -10;
                x2 = c / a;
                y2 = 10;
            }
            
            ctx.beginPath();
            ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
            ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
            ctx.stroke();
        }
        
        function drawObjectiveFunction() {
            if (!showOptions.objective) return;
            
            const { a, b } = objective;
            
            // Draw objective function level curves
            for (let level = -10; level <= 10; level += 2) {
                ctx.strokeStyle = `rgba(243, 156, 18, ${level === objectiveLevel ? 1 : 0.3})`;
                ctx.lineWidth = level === objectiveLevel ? 3 : 1;
                
                // Draw line ax + by = level
                let x1, y1, x2, y2;
                
                if (Math.abs(b) > 1e-10) {
                    x1 = -10;
                    y1 = (level - a * x1) / b;
                    x2 = 10;
                    y2 = (level - a * x2) / b;
                } else {
                    x1 = level / a;
                    y1 = -10;
                    x2 = level / a;
                    y2 = 10;
                }
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                ctx.stroke();
            }
        }
        
        function drawGradient() {
            if (!showOptions.gradient) return;
            
            const { a, b } = objective;
            const magnitude = Math.sqrt(a * a + b * b);
            
            if (magnitude > 0) {
                const direction = objective.type === 'minimize' ? 1 : -1;
                const arrowLength = 2;
                
                ctx.strokeStyle = '#3498db';
                ctx.fillStyle = '#3498db';
                ctx.lineWidth = 3;
                
                const startX = 0;
                const startY = 0;
                const endX = direction * a * arrowLength / magnitude;
                const endY = direction * b * arrowLength / magnitude;
                
                // Draw arrow
                ctx.beginPath();
                ctx.moveTo(toCanvasX(startX), toCanvasY(startY));
                ctx.lineTo(toCanvasX(endX), toCanvasY(endY));
                ctx.stroke();
                
                // Draw arrowhead
                const angle = Math.atan2(endY - startY, endX - startX);
                const headLength = 0.3;
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
                ctx.lineTo(
                    toCanvasX(endX - headLength * Math.cos(angle - Math.PI / 6)),
                    toCanvasY(endY - headLength * Math.sin(angle - Math.PI / 6))
                );
                ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
                ctx.lineTo(
                    toCanvasX(endX - headLength * Math.cos(angle + Math.PI / 6)),
                    toCanvasY(endY - headLength * Math.sin(angle + Math.PI / 6))
                );
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#3498db';
                ctx.font = '12px Arial';
                ctx.fillText(
                    `‚àáf = (${a.toFixed(1)}, ${b.toFixed(1)})`,
                    toCanvasX(endX) + 10,
                    toCanvasY(endY) - 10
                );
            }
        }
        
        function drawVertices() {
            if (!showOptions.vertices) return;
            
            ctx.fillStyle = '#e67e22';
            vertices.forEach(vertex => {
                ctx.beginPath();
                ctx.arc(toCanvasX(vertex.x), toCanvasY(vertex.y), 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function drawOptimalPoint() {
            if (!showOptions.optimal || !optimalPoint) return;
            
            ctx.fillStyle = '#9b59b6';
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimalPoint.x), toCanvasY(optimalPoint.y), 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimalPoint.x), toCanvasY(optimalPoint.y), 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#9b59b6';
            ctx.font = '12px Arial';
            ctx.fillText(
                `T·ªëi ∆∞u: (${optimalPoint.x.toFixed(2)}, ${optimalPoint.y.toFixed(2)})`,
                toCanvasX(optimalPoint.x) + 15,
                toCanvasY(optimalPoint.y) - 15
            );
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            drawFeasibleRegion();
            drawConstraints();
            drawObjectiveFunction();
            drawGradient();
            drawVertices();
            drawOptimalPoint();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        function resetView() {
            clearConstraints();
            objective = { a: 1, b: 1, type: 'minimize' };
            document.getElementById('objA').value = 1;
            document.getElementById('objB').value = 1;
            document.getElementById('objType').value = 'minimize';
            objectiveLevel = 0;
            document.getElementById('objectiveLevel').value = 0;
            document.getElementById('objectiveLevelValue').textContent = '0.0';
            updateObjective();
        }
        
        function randomProblem() {
            clearConstraints();
            
            // Generate random objective
            const objA = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
            const objB = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
            document.getElementById('objA').value = objA;
            document.getElementById('objB').value = objB;
            
            // Generate random constraints
            const numConstraints = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numConstraints; i++) {
                const a = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
                const b = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
                const c = Math.round(Math.random() * 6);
                const type = Math.random() < 0.7 ? '‚â§' : '‚â•';
                
                if (Math.abs(a) > 0.1 || Math.abs(b) > 0.1) {
                    constraints.push({ a, b, type, c, id: Date.now() + i });
                }
            }
            
            updateObjective();
            updateConstraintList();
        }
        
        function loadPreset(presetName) {
            clearConstraints();
            
            const presets = {
                simple: {
                    objective: { a: 1, b: 1, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '‚â•', c: 0 },
                        { a: 0, b: 1, type: '‚â•', c: 0 },
                        { a: 1, b: 1, type: '‚â§', c: 3 }
                    ]
                },
                bounded: {
                    objective: { a: 3, b: 2, type: 'maximize' },
                    constraints: [
                        { a: 1, b: 0, type: '‚â•', c: 0 },
                        { a: 0, b: 1, type: '‚â•', c: 0 },
                        { a: 2, b: 1, type: '‚â§', c: 6 },
                        { a: 1, b: 2, type: '‚â§', c: 6 },
                        { a: 1, b: 0, type: '‚â§', c: 4 }
                    ]
                },
                unbounded: {
                    objective: { a: 1, b: 1, type: 'maximize' },
                    constraints: [
                        { a: 1, b: -1, type: '‚â§', c: 2 },
                        { a: -1, b: 1, type: '‚â§', c: 2 }
                    ]
                },
                infeasible: {
                    objective: { a: 1, b: 1, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '‚â§', c: 1 },
                        { a: 1, b: 0, type: '‚â•', c: 2 },
                        { a: 0, b: 1, type: '‚â•', c: 0 }
                    ]
                },
                degenerate: {
                    objective: { a: 1, b: 0, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '‚â•', c: 0 },
                        { a: 0, b: 1, type: '‚â•', c: 0 },
                        { a: 1, b: 1, type: '‚â§', c: 2 },
                        { a: 1, b: -1, type: '‚â§', c: 0 }
                    ]
                },
                polytope: {
                    objective: { a: 2, b: 3, type: 'maximize' },
                    constraints: [
                        { a: 1, b: 0, type: '‚â•', c: 0 },
                        { a: 0, b: 1, type: '‚â•', c: 0 },
                        { a: 3, b: 2, type: '‚â§', c: 18 },
                        { a: 2, b: 3, type: '‚â§', c: 18 },
                        { a: 1, b: 3, type: '‚â§', c: 12 },
                        { a: 4, b: 1, type: '‚â§', c: 16 }
                    ]
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Set objective
            document.getElementById('objA').value = preset.objective.a;
            document.getElementById('objB').value = preset.objective.b;
            document.getElementById('objType').value = preset.objective.type;
            
            // Set constraints
            preset.constraints.forEach((constraint, index) => {
                constraints.push({ ...constraint, id: Date.now() + index });
            });
            
            updateObjective();
            updateConstraintList();
        }
        
        // Event listeners
        document.getElementById('objA').addEventListener('input', updateObjective);
        document.getElementById('objB').addEventListener('input', updateObjective);
        document.getElementById('objType').addEventListener('change', updateObjective);
        
        document.getElementById('objectiveLevel').addEventListener('input', function() {
            objectiveLevel = parseFloat(this.value);
            document.getElementById('objectiveLevelValue').textContent = objectiveLevel.toFixed(1);
            draw();
        });
        
        // Initialize
        loadPreset('simple');
        draw();
    </script>
</body>
</html>
