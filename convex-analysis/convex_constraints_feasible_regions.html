<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ràng Buộc Lồi và Miền Khả Thi - Minh Họa Tương Tác</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="../math-config.js"></script>
    <style>
        body {
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }
        
        .header p {
            color: #666;
            margin: 10px 0 0 0;
            font-size: 1.1rem;
        }
        
        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .theory-section {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 5px solid #2196f3;
        }
        
        .theory-section h2 {
            color: #1976d2;
            margin: 0 0 20px 0;
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .interactive-section {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 5px solid #4caf50;
        }
        
        .interactive-section h2 {
            color: #2e7d32;
            margin: 0 0 20px 0;
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .math-content {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        .concept-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196f3;
        }
        
        .concept-box h4 {
            color: #1976d2;
            margin: 0 0 10px 0;
        }
        
        .visualization-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-top: 10px;
        }
        
        .container {
            display: flex;
            height: 70vh;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
        }
        
        canvas {
            background: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .controls {
            width: 420px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-left: 2px solid #e0e0e0;
            overflow-y: auto;
        }
        
        .control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
        
        .constraint-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .constraint-item {
            background: rgba(0, 0, 0, 0.05);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 3px solid #2196f3;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            position: relative;
        }
        
        .constraint-item .remove-btn {
            position: absolute;
            right: 5px;
            top: 5px;
            background: #e74c3c;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 10px;
        }
        
        .constraint-type {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .constraint-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #2196f3;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .constraint-button:hover {
            background: #2196f3;
            color: white;
            transform: translateY(-2px);
        }
        
        .constraint-button.active {
            background: #2196f3;
            color: white;
        }
        
        .problem-info {
            background: rgba(33, 150, 243, 0.1);
            padding: 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
            border: 1px solid #2196f3;
        }
        
        .feasible-stats {
            background: rgba(76, 175, 80, 0.1);
            padding: 12px;
            border-radius: 5px;
            font-size: 12px;
            margin-bottom: 15px;
            border-left: 3px solid #4caf50;
            border: 1px solid #4caf50;
        }
        
        .toggle-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .toggle-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #2196f3;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .toggle-button:hover {
            background: #2196f3;
            color: white;
        }
        
        .toggle-button.active {
            background: #2196f3;
            color: white;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 350px;
            z-index: 10;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        
        .legend {
            font-size: 11px;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .legend-item {
            margin: 3px 0;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 12px;
            color: #2196f3;
            text-align: right;
            margin-top: 2px;
            font-weight: 600;
        }
        
        .constraint-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 5px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .constraint-inputs input {
            width: 100%;
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .constraint-inputs input:focus {
            border-color: #2196f3;
            outline: none;
        }
        
        .constraint-inputs select {
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .objective-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .objective-inputs input {
            width: 100%;
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .objective-inputs input:focus {
            border-color: #2196f3;
            outline: none;
        }
        
        .objective-inputs select {
            padding: 6px;
            background: white;
            color: #2c3e50;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .preset-problems {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .preset-button {
            padding: 8px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #4caf50;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .preset-button:hover {
            background: #4caf50;
            color: white;
            transform: translateY(-2px);
        }
    </style>





</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>Ràng Buộc Lồi và Miền Khả Thi</h1>
            <p>Khám phá tương tác về tối ưu hóa có ràng buộc và hình học miền khả thi</p>
        </div>

        <div class="content-wrapper">
            <div class="theory-section">
                <h2>📖 LÝ THUYẾT</h2>
                
                <div class="math-content">
                    <h3>1. Ràng Buộc Lồi (Convex Constraints)</h3>
                    <p><strong>Định nghĩa:</strong> Một ràng buộc được gọi là <em>lồi</em> nếu nó có dạng:</p>
                    $$g(x) \leq 0$$
                    trong đó $g: \mathbb{R}^n \to \mathbb{R}$ là một hàm lồi.
                    
                    <div class="concept-box">
                        <h4>Các loại ràng buộc lồi phổ biến:</h4>
                        <ul>
                            <li><strong>Ràng buộc tuyến tính:</strong> $a^T x \leq b$</li>
                            <li><strong>Ràng buộc bậc hai:</strong> $x^T Q x + p^T x + r \leq 0$ (với $Q \succeq 0$)</li>
                            <li><strong>Ràng buộc chuẩn:</strong> $\|x\|_p \leq t$ (với $p \geq 1$)</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>2. Miền Khả Thi (Feasible Region)</h3>
                    <p><strong>Định nghĩa:</strong> Miền khả thi $\mathcal{F}$ là tập hợp tất cả các điểm thỏa mãn các ràng buộc:</p>
                    $$\mathcal{F} = \{x \in \mathbb{R}^n : g_i(x) \leq 0, \; i = 1,\ldots,m\}$$
                    
                    <div class="concept-box">
                        <h4>Tính chất quan trọng:</h4>
                        <ul>
                            <li><strong>Tập lồi:</strong> Giao của các tập lồi là tập lồi</li>
                            <li><strong>Đóng:</strong> Miền khả thi thường là tập đóng</li>
                            <li><strong>Đa diện:</strong> Với ràng buộc tuyến tính, miền khả thi là đa diện lồi</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>3. Bài Toán Tối Ưu Lồi với Ràng Buộc</h3>
                    <p>Dạng tổng quát:</p>
                    $$\begin{align}
                    \min \quad & f(x) \\
                    \text{s.t.} \quad & g_i(x) \leq 0, \quad i = 1,\ldots,m \\
                    & h_j(x) = 0, \quad j = 1,\ldots,p
                    \end{align}$$
                    
                    <div class="concept-box">
                        <h4>Điều kiện KKT (Karush-Kuhn-Tucker):</h4>
                        <p>Cho điểm tối ưu $x^*$, tồn tại $\lambda \geq 0, \mu$ sao cho:</p>
                        <ul>
                            <li>$\nabla f(x^*) + \sum\limits_{i=1}^m \lambda_i \nabla g_i(x^*) + \sum\limits_{j=1}^p \mu_j \nabla h_j(x^*) = 0$</li>
                            <li>$g_i(x^*) \leq 0, \; \lambda_i \geq 0, \; \lambda_i g_i(x^*) = 0$</li>
                            <li>$h_j(x^*) = 0$</li>
                        </ul>
                    </div>
                </div>

                <div class="math-content">
                    <h3>4. Lập Trình Tuyến Tính</h3>
                    <p>Trường hợp đặc biệt với hàm mục tiêu và ràng buộc đều tuyến tính:</p>
                    $$\begin{align}
                    \min \quad & c^T x \\
                    \text{s.t.} \quad & Ax \leq b \\
                    & x \geq 0
                    \end{align}$$
                    
                    <div class="concept-box">
                        <h4>Định lý cơ bản:</h4>
                        <ul>
                            <li><strong>Điểm cực trị:</strong> Nghiệm tối ưu nằm tại đỉnh của đa diện</li>
                            <li><strong>Duality:</strong> Bài toán đối ngẫu cung cấp cận dưới</li>
                            <li><strong>Simplex:</strong> Thuật toán di chuyển giữa các đỉnh liền kề</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="interactive-section">
                <h2>🎮 MINH HỌA TƯƠNG TÁC</h2>
                
                <div class="visualization-container">
                    <p><strong>Hướng dẫn sử dụng:</strong></p>
                    <ul>
                        <li>🎯 <strong>Thêm ràng buộc:</strong> Nhập hệ số a, b, c cho ràng buộc ax + by ≤/≥/= c</li>
                        <li>📊 <strong>Thiết lập hàm mục tiêu:</strong> Chọn hệ số và loại tối ưu (min/max)</li>
                        <li>🎲 <strong>Dùng mẫu có sẵn:</strong> Chọn các bài toán mẫu để khám phá</li>
                        <li>👁️ <strong>Tùy chỉnh hiển thị:</strong> Bật/tắt các thành phần trực quan</li>
                    </ul>
                    
                    <div class="container">
                        <div class="canvas-container">
                            <canvas id="canvas" width="800" height="600"></canvas>
                            <div class="info-panel">
                                <strong>🎯 Ràng Buộc Lồi & Miền Khả Thi</strong><br/>
                                Khám phá tương tác về tối ưu hóa có ràng buộc và hình học miền khả thi.
                                <div class="legend">
                                    <div class="legend-item" style="color: #4caf50;">🟢 Miền Khả Thi</div>
                                    <div class="legend-item" style="color: #f44336;">🔴 Đường Ràng Buộc</div>
                                    <div class="legend-item" style="color: #ff9800;">🟠 Hàm Mục Tiêu</div>
                                    <div class="legend-item" style="color: #9c27b0;">🟣 Điểm Tối Ưu</div>
                                    <div class="legend-item" style="color: #2196f3;">🔵 Hướng Gradient</div>
                                    <div class="legend-item" style="color: #ff5722;">🟤 Điểm Đỉnh</div>
                                </div>
                            </div>
                        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Hàm Mục Tiêu</h3>
                <div class="objective-inputs">
                    <input type="number" id="objA" step="0.1" value="1" placeholder="coeff x">
                    <input type="number" id="objB" step="0.1" value="1" placeholder="coeff y">
                    <select id="objType">
                        <option value="minimize">Tối thiểu hóa</option>
                        <option value="maximize">Tối đa hóa</option>
                    </select>
                </div>
                <div id="objective-display" class="problem-info">
                    Tối thiểu hóa: f(x,y) = x + y
                </div>
            </div>
            
            <div class="control-section">
                <h3>Thêm Ràng Buộc</h3>
                <div class="constraint-inputs">
                    <input type="number" id="constraintA" step="0.1" value="1" placeholder="a">
                    <input type="number" id="constraintB" step="0.1" value="0" placeholder="b">
                    <select id="constraintType">
                        <option value="≤">≤</option>
                        <option value="≥">≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" id="constraintC" step="0.1" value="1" placeholder="c">
                </div>
                <div class="constraint-type">
                    <button class="constraint-button" onclick="addConstraint()">Thêm Ràng Buộc</button>
                    <button class="constraint-button" onclick="clearConstraints()">Xóa Tất Cả</button>
                    <button class="constraint-button" onclick="solveOptimization()">🎯 Giải</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Bài Toán Mẫu</h3>
                <div class="preset-problems">
                    <button class="preset-button" onclick="loadPreset('simple')">LP Đơn Giản</button>
                    <button class="preset-button" onclick="loadPreset('bounded')">Miền Bị Chặn</button>
                    <button class="preset-button" onclick="loadPreset('unbounded')">Không Bị Chặn</button>
                    <button class="preset-button" onclick="loadPreset('infeasible')">Vô Nghiệm</button>
                    <button class="preset-button" onclick="loadPreset('degenerate')">Suy Biến</button>
                    <button class="preset-button" onclick="loadPreset('polytope')">Đa Diện Phức Tạp</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Ràng Buộc Hiện Tại</h3>
                <div id="constraint-list" class="constraint-list">
                    <!-- Constraints will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Tùy Chọn Hiển Thị</h3>
                <div class="toggle-section">
                    <div class="toggle-button active" id="toggle-feasible" onclick="toggleVisualization('feasible')">
                        Miền Khả Thi
                    </div>
                    <div class="toggle-button active" id="toggle-constraints" onclick="toggleVisualization('constraints')">
                        Đường Ràng Buộc
                    </div>
                    <div class="toggle-button active" id="toggle-objective" onclick="toggleVisualization('objective')">
                        Đường Mục Tiêu
                    </div>
                    <div class="toggle-button active" id="toggle-gradient" onclick="toggleVisualization('gradient')">
                        Gradient
                    </div>
                    <div class="toggle-button active" id="toggle-vertices" onclick="toggleVisualization('vertices')">
                        Điểm Đỉnh
                    </div>
                    <div class="toggle-button active" id="toggle-optimal" onclick="toggleVisualization('optimal')">
                        Điểm Tối Ưu
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Phân Tích Bài Toán</h3>
                <div id="feasible-stats" class="feasible-stats">
                    <!-- Problem statistics will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Điều Khiển Tương Tác</h3>
                <div class="slider-group">
                    <label>Mức Hàm Mục Tiêu:</label>
                    <input type="range" id="objectiveLevel" min="-10" max="10" step="0.1" value="0">
                    <div class="slider-value" id="objectiveLevelValue">0.0</div>
                </div>
                <div class="toggle-section">
                    <div class="toggle-button" onclick="resetView()">
                        🔄 Đặt Lại
                    </div>
                    <div class="toggle-button" onclick="randomProblem()">
                        🎲 Bài Toán Ngẫu Nhiên
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 60;
        
        // Problem state
        let constraints = [];
        let objective = { a: 1, b: 1, type: 'minimize' };
        let feasibleRegion = [];
        let vertices = [];
        let optimalPoint = null;
        let optimalValue = null;
        let objectiveLevel = 0;
        
        // Visualization options
        let showOptions = {
            feasible: true,
            constraints: true,
            objective: true,
            gradient: true,
            vertices: true,
            optimal: true
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function addConstraint() {
            const a = parseFloat(document.getElementById('constraintA').value) || 0;
            const b = parseFloat(document.getElementById('constraintB').value) || 0;
            const type = document.getElementById('constraintType').value;
            const c = parseFloat(document.getElementById('constraintC').value) || 0;
            
            if (Math.abs(a) < 1e-10 && Math.abs(b) < 1e-10) {
                alert('Cả hai hệ số không thể bằng 0');
                return;
            }
            
            const constraint = { a, b, type, c, id: Date.now() };
            constraints.push(constraint);
            
            updateConstraintList();
            updateProblem();
        }
        
        function removeConstraint(id) {
            constraints = constraints.filter(c => c.id !== id);
            updateConstraintList();
            updateProblem();
        }
        
        function clearConstraints() {
            constraints = [];
            updateConstraintList();
            updateProblem();
        }
        
        function updateConstraintList() {
            const list = document.getElementById('constraint-list');
            list.innerHTML = '';
            
            constraints.forEach((constraint, index) => {
                const div = document.createElement('div');
                div.className = 'constraint-item';
                div.innerHTML = `
                    <span>${constraint.a.toFixed(2)}x + ${constraint.b.toFixed(2)}y ${constraint.type} ${constraint.c.toFixed(2)}</span>
                    <button class="remove-btn" onclick="removeConstraint(${constraint.id})">×</button>
                `;
                list.appendChild(div);
            });
        }
        
        function updateObjective() {
            const a = parseFloat(document.getElementById('objA').value) || 0;
            const b = parseFloat(document.getElementById('objB').value) || 0;
            const type = document.getElementById('objType').value;
            
            objective = { a, b, type };
            
            const typeText = type === 'minimize' ? 'Tối thiểu hóa' : 'Tối đa hóa';
            document.getElementById('objective-display').innerHTML = 
                `${typeText}: f(x,y) = ${a.toFixed(2)}x + ${b.toFixed(2)}y`;
            
            updateProblem();
        }
        
        function updateProblem() {
            findFeasibleRegion();
            findVertices();
            solveOptimization();
            updateProblemStats();
            draw();
        }
        
        function findFeasibleRegion() {
            feasibleRegion = [];
            
            // Create a grid of points and test each one
            const step = 0.2;
            for (let x = -8; x <= 8; x += step) {
                for (let y = -6; y <= 6; y += step) {
                    if (isPointFeasible(x, y)) {
                        feasibleRegion.push({ x, y });
                    }
                }
            }
        }
        
        function isPointFeasible(x, y) {
            return constraints.every(constraint => {
                const value = constraint.a * x + constraint.b * y;
                switch (constraint.type) {
                    case '≤': return value <= constraint.c + 1e-10;
                    case '≥': return value >= constraint.c - 1e-10;
                    case '=': return Math.abs(value - constraint.c) < 1e-6;
                    default: return true;
                }
            });
        }
        
        function findVertices() {
            vertices = [];
            
            if (constraints.length < 2) return;
            
            // Find intersections of constraint lines
            for (let i = 0; i < constraints.length; i++) {
                for (let j = i + 1; j < constraints.length; j++) {
                    const intersection = findIntersection(constraints[i], constraints[j]);
                    if (intersection && isPointFeasible(intersection.x, intersection.y)) {
                        // Check if vertex is not too close to existing vertices
                        const isDuplicate = vertices.some(v => 
                            Math.abs(v.x - intersection.x) < 1e-6 && 
                            Math.abs(v.y - intersection.y) < 1e-6
                        );
                        
                        if (!isDuplicate && Math.abs(intersection.x) < 20 && Math.abs(intersection.y) < 20) {
                            vertices.push(intersection);
                        }
                    }
                }
            }
            
            // Also check intersections with axes bounds
            const bounds = [
                { a: 1, b: 0, c: 8 },   // x ≤ 8
                { a: -1, b: 0, c: 8 },  // x ≥ -8
                { a: 0, b: 1, c: 6 },   // y ≤ 6
                { a: 0, b: -1, c: 6 }   // y ≥ -6
            ];
            
            bounds.forEach(bound => {
                constraints.forEach(constraint => {
                    const intersection = findIntersection(bound, constraint);
                    if (intersection && isPointFeasible(intersection.x, intersection.y)) {
                        const isDuplicate = vertices.some(v => 
                            Math.abs(v.x - intersection.x) < 1e-6 && 
                            Math.abs(v.y - intersection.y) < 1e-6
                        );
                        
                        if (!isDuplicate) {
                            vertices.push(intersection);
                        }
                    }
                });
            });
        }
        
        function findIntersection(constraint1, constraint2) {
            const { a: a1, b: b1, c: c1 } = constraint1;
            const { a: a2, b: b2, c: c2 } = constraint2;
            
            const det = a1 * b2 - a2 * b1;
            if (Math.abs(det) < 1e-10) return null; // Parallel lines
            
            const x = (c1 * b2 - c2 * b1) / det;
            const y = (a1 * c2 - a2 * c1) / det;
            
            return { x, y };
        }
        
        function solveOptimization() {
            optimalPoint = null;
            optimalValue = null;
            
            if (vertices.length === 0) return;
            
            let bestPoint = null;
            let bestValue = objective.type === 'minimize' ? Infinity : -Infinity;
            
            vertices.forEach(vertex => {
                const value = objective.a * vertex.x + objective.b * vertex.y;
                
                if ((objective.type === 'minimize' && value < bestValue) ||
                    (objective.type === 'maximize' && value > bestValue)) {
                    bestValue = value;
                    bestPoint = vertex;
                }
            });
            
            optimalPoint = bestPoint;
            optimalValue = bestValue;
        }
        
        function updateProblemStats() {
            const stats = document.getElementById('feasible-stats');
            
            let status = 'Chưa xác định';
            if (feasibleRegion.length === 0) {
                status = 'Vô nghiệm - Không tìm thấy điểm khả thi';
            } else if (vertices.length === 0) {
                status = 'Không bị chặn - Không có điểm đỉnh';
            } else if (optimalPoint) {
                status = 'Đã tìm thấy nghiệm tối ưu';
            }
            
            stats.innerHTML = `
                <strong>Phân tích bài toán:</strong><br/>
                Trạng thái: ${status}<br/>
                Điểm khả thi: ${feasibleRegion.length}<br/>
                Điểm đỉnh: ${vertices.length}<br/>
                ${optimalPoint ? `Điểm tối ưu: (${optimalPoint.x.toFixed(3)}, ${optimalPoint.y.toFixed(3)})<br/>` : ''}
                ${optimalValue !== null ? `Giá trị tối ưu: ${optimalValue.toFixed(3)}` : ''}
            `;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -20; i <= 20; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawFeasibleRegion() {
            if (!showOptions.feasible || feasibleRegion.length === 0) return;
            
            ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
            feasibleRegion.forEach(point => {
                ctx.fillRect(toCanvasX(point.x) - 1, toCanvasY(point.y) - 1, 2, 2);
            });
        }
        
        function drawConstraints() {
            if (!showOptions.constraints) return;
            
            constraints.forEach((constraint, index) => {
                const colors = ['#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#e67e22', '#2ecc71'];
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2;
                
                // Draw constraint line
                drawConstraintLine(constraint);
                
                // Draw constraint label
                ctx.fillStyle = colors[index % colors.length];
                ctx.font = '12px Arial';
                ctx.fillText(
                    `${constraint.a.toFixed(1)}x + ${constraint.b.toFixed(1)}y ${constraint.type} ${constraint.c.toFixed(1)}`,
                    10,
                    20 + index * 16
                );
            });
        }
        
        function drawConstraintLine(constraint) {
            const { a, b, c } = constraint;
            
            // Find two points on the line ax + by = c
            let x1, y1, x2, y2;
            
            if (Math.abs(b) > 1e-10) {
                // Vertical line case
                x1 = -10;
                y1 = (c - a * x1) / b;
                x2 = 10;
                y2 = (c - a * x2) / b;
            } else {
                // Horizontal line case
                x1 = c / a;
                y1 = -10;
                x2 = c / a;
                y2 = 10;
            }
            
            ctx.beginPath();
            ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
            ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
            ctx.stroke();
        }
        
        function drawObjectiveFunction() {
            if (!showOptions.objective) return;
            
            const { a, b } = objective;
            
            // Draw objective function level curves
            for (let level = -10; level <= 10; level += 2) {
                ctx.strokeStyle = `rgba(243, 156, 18, ${level === objectiveLevel ? 1 : 0.3})`;
                ctx.lineWidth = level === objectiveLevel ? 3 : 1;
                
                // Draw line ax + by = level
                let x1, y1, x2, y2;
                
                if (Math.abs(b) > 1e-10) {
                    x1 = -10;
                    y1 = (level - a * x1) / b;
                    x2 = 10;
                    y2 = (level - a * x2) / b;
                } else {
                    x1 = level / a;
                    y1 = -10;
                    x2 = level / a;
                    y2 = 10;
                }
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                ctx.stroke();
            }
        }
        
        function drawGradient() {
            if (!showOptions.gradient) return;
            
            const { a, b } = objective;
            const magnitude = Math.sqrt(a * a + b * b);
            
            if (magnitude > 0) {
                const direction = objective.type === 'minimize' ? 1 : -1;
                const arrowLength = 2;
                
                ctx.strokeStyle = '#3498db';
                ctx.fillStyle = '#3498db';
                ctx.lineWidth = 3;
                
                const startX = 0;
                const startY = 0;
                const endX = direction * a * arrowLength / magnitude;
                const endY = direction * b * arrowLength / magnitude;
                
                // Draw arrow
                ctx.beginPath();
                ctx.moveTo(toCanvasX(startX), toCanvasY(startY));
                ctx.lineTo(toCanvasX(endX), toCanvasY(endY));
                ctx.stroke();
                
                // Draw arrowhead
                const angle = Math.atan2(endY - startY, endX - startX);
                const headLength = 0.3;
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
                ctx.lineTo(
                    toCanvasX(endX - headLength * Math.cos(angle - Math.PI / 6)),
                    toCanvasY(endY - headLength * Math.sin(angle - Math.PI / 6))
                );
                ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
                ctx.lineTo(
                    toCanvasX(endX - headLength * Math.cos(angle + Math.PI / 6)),
                    toCanvasY(endY - headLength * Math.sin(angle + Math.PI / 6))
                );
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#3498db';
                ctx.font = '12px Arial';
                ctx.fillText(
                    `∇f = (${a.toFixed(1)}, ${b.toFixed(1)})`,
                    toCanvasX(endX) + 10,
                    toCanvasY(endY) - 10
                );
            }
        }
        
        function drawVertices() {
            if (!showOptions.vertices) return;
            
            ctx.fillStyle = '#e67e22';
            vertices.forEach(vertex => {
                ctx.beginPath();
                ctx.arc(toCanvasX(vertex.x), toCanvasY(vertex.y), 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function drawOptimalPoint() {
            if (!showOptions.optimal || !optimalPoint) return;
            
            ctx.fillStyle = '#9b59b6';
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimalPoint.x), toCanvasY(optimalPoint.y), 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimalPoint.x), toCanvasY(optimalPoint.y), 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#9b59b6';
            ctx.font = '12px Arial';
            ctx.fillText(
                `Tối ưu: (${optimalPoint.x.toFixed(2)}, ${optimalPoint.y.toFixed(2)})`,
                toCanvasX(optimalPoint.x) + 15,
                toCanvasY(optimalPoint.y) - 15
            );
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            drawFeasibleRegion();
            drawConstraints();
            drawObjectiveFunction();
            drawGradient();
            drawVertices();
            drawOptimalPoint();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        function resetView() {
            clearConstraints();
            objective = { a: 1, b: 1, type: 'minimize' };
            document.getElementById('objA').value = 1;
            document.getElementById('objB').value = 1;
            document.getElementById('objType').value = 'minimize';
            objectiveLevel = 0;
            document.getElementById('objectiveLevel').value = 0;
            document.getElementById('objectiveLevelValue').textContent = '0.0';
            updateObjective();
        }
        
        function randomProblem() {
            clearConstraints();
            
            // Generate random objective
            const objA = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
            const objB = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
            document.getElementById('objA').value = objA;
            document.getElementById('objB').value = objB;
            
            // Generate random constraints
            const numConstraints = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numConstraints; i++) {
                const a = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
                const b = Math.round((Math.random() - 0.5) * 4 * 10) / 10;
                const c = Math.round(Math.random() * 6);
                const type = Math.random() < 0.7 ? '≤' : '≥';
                
                if (Math.abs(a) > 0.1 || Math.abs(b) > 0.1) {
                    constraints.push({ a, b, type, c, id: Date.now() + i });
                }
            }
            
            updateObjective();
            updateConstraintList();
        }
        
        function loadPreset(presetName) {
            clearConstraints();
            
            const presets = {
                simple: {
                    objective: { a: 1, b: 1, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '≥', c: 0 },
                        { a: 0, b: 1, type: '≥', c: 0 },
                        { a: 1, b: 1, type: '≤', c: 3 }
                    ]
                },
                bounded: {
                    objective: { a: 3, b: 2, type: 'maximize' },
                    constraints: [
                        { a: 1, b: 0, type: '≥', c: 0 },
                        { a: 0, b: 1, type: '≥', c: 0 },
                        { a: 2, b: 1, type: '≤', c: 6 },
                        { a: 1, b: 2, type: '≤', c: 6 },
                        { a: 1, b: 0, type: '≤', c: 4 }
                    ]
                },
                unbounded: {
                    objective: { a: 1, b: 1, type: 'maximize' },
                    constraints: [
                        { a: 1, b: -1, type: '≤', c: 2 },
                        { a: -1, b: 1, type: '≤', c: 2 }
                    ]
                },
                infeasible: {
                    objective: { a: 1, b: 1, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '≤', c: 1 },
                        { a: 1, b: 0, type: '≥', c: 2 },
                        { a: 0, b: 1, type: '≥', c: 0 }
                    ]
                },
                degenerate: {
                    objective: { a: 1, b: 0, type: 'minimize' },
                    constraints: [
                        { a: 1, b: 0, type: '≥', c: 0 },
                        { a: 0, b: 1, type: '≥', c: 0 },
                        { a: 1, b: 1, type: '≤', c: 2 },
                        { a: 1, b: -1, type: '≤', c: 0 }
                    ]
                },
                polytope: {
                    objective: { a: 2, b: 3, type: 'maximize' },
                    constraints: [
                        { a: 1, b: 0, type: '≥', c: 0 },
                        { a: 0, b: 1, type: '≥', c: 0 },
                        { a: 3, b: 2, type: '≤', c: 18 },
                        { a: 2, b: 3, type: '≤', c: 18 },
                        { a: 1, b: 3, type: '≤', c: 12 },
                        { a: 4, b: 1, type: '≤', c: 16 }
                    ]
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Set objective
            document.getElementById('objA').value = preset.objective.a;
            document.getElementById('objB').value = preset.objective.b;
            document.getElementById('objType').value = preset.objective.type;
            
            // Set constraints
            preset.constraints.forEach((constraint, index) => {
                constraints.push({ ...constraint, id: Date.now() + index });
            });
            
            updateObjective();
            updateConstraintList();
        }
        
        // Event listeners
        document.getElementById('objA').addEventListener('input', updateObjective);
        document.getElementById('objB').addEventListener('input', updateObjective);
        document.getElementById('objType').addEventListener('change', updateObjective);
        
        document.getElementById('objectiveLevel').addEventListener('input', function() {
            objectiveLevel = parseFloat(this.value);
            document.getElementById('objectiveLevelValue').textContent = objectiveLevel.toFixed(1);
            draw();
        });
        
        // Initialize
        loadPreset('simple');
        draw();
    </script>
</body>
</html>
