<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîÑ H√†m Li√™n H·ª£p & ƒê·ªëi Ng·∫´u - L√Ω Thuy·∫øt & Minh H·ªça T∆∞∆°ng T√°c</title>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="../math-simple.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            text-align: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 30px;
            font-size: 20px;
            line-height: 1.8;
            margin: 0;
            min-height: 100vh;
        }
        canvas {
            background: #000;
            margin-top: 10px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            border: 1px solid #444;
        }
        
        .theory-section {
            background: linear-gradient(145deg, rgba(25, 25, 60, 0.9), rgba(15, 15, 40, 0.7));
            padding: 30px;
            border-radius: 15px;
            margin: 30px auto;
            max-width: 1000px;
            text-align: left;
            border: 2px solid rgba(100, 200, 255, 0.4);
        }
        
        .interactive-section {
            background: linear-gradient(145deg, rgba(15, 40, 15, 0.9), rgba(25, 60, 25, 0.7));
            padding: 30px;
            border-radius: 15px;
            margin: 30px auto;
            border: 2px solid rgba(76, 175, 80, 0.4);
        }
        .controls {
            margin: 30px 0;
            padding: 25px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            display: inline-block;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 800px;
        }
        .control-section {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #4caf50;
            font-size: 18px;
            text-align: center;
        }
        .function-info, .conjugate-info, .duality-gap, .tangent-line, .optimization-problem {
            background: rgba(0, 0, 0, 0.6);
            color: #ffffff;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .formula-container {
            background: linear-gradient(145deg, rgba(15, 15, 40, 0.9), rgba(25, 25, 60, 0.7));
            padding: 20px 25px;
            border-radius: 12px;
            margin: 20px 0;
            border: 2px solid rgba(100, 200, 255, 0.4);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .formula-title {
            font-size: 16px;
            color: #ffeb3b;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .math-environment {
            font-size: 18px;
            text-align: center;
            margin: 15px 0;
            color: #ffffff;
        }
        
        .formula-description {
            font-size: 14px;
            color: #b8e6ff;
            font-style: italic;
            margin-top: 8px;
            text-align: center;
        }
        .toggle-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .toggle-button, .function-button {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
            font-weight: 600;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        
        .toggle-button:hover, .function-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }
        
        .toggle-button.active {
            background: #4caf50;
            color: #000;
        }
        
        .function-button.active {
            background: #f39c12;
            color: #000;
        }
        .info-panel {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            margin: 20px auto;
            max-width: 600px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .legend {
            font-size: 13px;
            margin-top: 15px;
            line-height: 1.6;
            text-align: left;
        }
        
        .legend-item {
            margin: 8px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        .slider-group {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            color: #4caf50;
            font-weight: 600;
            text-align: center;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .slider-value {
            font-size: 16px;
            color: #0ff;
            text-align: center;
            margin-top: 8px;
            font-weight: 600;
        }
        .function-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
    </style>





</head>
<body>
  <h2 style="font-size: 3.2em; font-weight: 900; text-shadow: 4px 4px 8px rgba(0,0,0,0.8); margin-bottom: 40px; letter-spacing: 1px;">üîÑ H√†m Li√™n H·ª£p & ƒê·ªëi Ng·∫´u - L√Ω Thuy·∫øt & Minh H·ªça T∆∞∆°ng T√°c</h2>
  
  <!-- ===========================================
       PH·∫¶N L√ù THUY·∫æT (THEORY SECTION)
       =========================================== -->
  
  <div class="theory-section">
    <h2 style="color: #00d4ff; font-size: 2.5em; margin-bottom: 20px; text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üìñ L√ù THUY·∫æT V·ªÄ H√ÄM LI√äN H·ª¢P & ƒê·ªêI NG·∫™U</h2>
    
    <div class="formula-container">
      <div class="formula-title">ƒê·ªãnh Nghƒ©a H√†m Li√™n H·ª£p</div>
      <div class="math-environment">
        $$f^*(y) = \sup_{x \in \text{dom}(f)} \{yx - f(x)\}$$
      </div>
      <div class="formula-description">H√†m li√™n h·ª£p l√† ph√©p bi·∫øn ƒë·ªïi Legendre-Fenchel</div>
    </div>

    <div style="background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 10px; margin: 25px 0;">
      <h3 style="font-size: 1.8em; font-weight: 800; color: #FFD700; margin-bottom: 15px;">üîç ƒê·∫∑c T√≠nh C∆° B·∫£n</h3>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div>
          <p><strong>Fenchel-Moreau:</strong> N·∫øu f l√† h√†m l·ªìi th√¨ $f^{**} = f$</p>
          <p><strong>B·∫•t ƒë·∫≥ng th·ª©c Fenchel:</strong> $f(x) + f^*(y) \geq xy$</p>
        </div>
        <div>
          <p><strong>D·∫°ng Bi·∫øn Ph√¢n:</strong> $y \in \partial f(x) \Leftrightarrow x \in \partial f^*(y)$</p>
          <p><strong>ƒê·ªëi Ng·∫´u Fenchel:</strong> $\min f(x) = -\max(-f^*(0))$</p>
        </div>
      </div>
    </div>

    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;">
      <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px;">
        <h4 style="color: #ffd700;">‚ö° V√≠ D·ª• H√†m Li√™n H·ª£p</h4>
        <div class="formula-container">
          <div class="formula-title">H√†m B·∫≠c 2</div>
          <div class="math-environment">$$f(x) = \frac{1}{2}x^2 \Rightarrow f^*(y) = \frac{1}{2}y^2$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">H√†m M≈©</div>
          <div class="math-environment">$$f(x) = e^x \Rightarrow f^*(y) = y\log(y) - y$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">Gi√° Tr·ªã Tuy·ªát ƒê·ªëi</div>
          <div class="math-environment">$$f(x) = |x| \Rightarrow f^*(y) = \delta_{[-1,1]}(y)$$</div>
        </div>
      </div>
      
      <div style="background: rgba(0, 123, 255, 0.1); padding: 15px; border-radius: 8px;">
        <h4 style="color: #007bff;">üìê ƒê·ªëi Ng·∫´u Fenchel</h4>
        <div class="formula-container">
          <div class="formula-title">B√†i To√°n G·ªëc (Primal)</div>
          <div class="math-environment">$$\inf_{x} f(x) + g(Ax)$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">B√†i To√°n ƒê·ªëi Ng·∫´u (Dual)</div>
          <div class="math-environment">$$\sup_{y} -f^*(A^T y) - g^*(-y)$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">ƒê·ªëi Ng·∫´u M·∫°nh</div>
          <div class="math-environment">$$\inf \text{ primal} = \sup \text{ dual}$$</div>
        </div>
      </div>
      
      <div style="background: rgba(40, 167, 69, 0.1); padding: 15px; border-radius: 8px;">
        <h4 style="color: #28a745;">üéØ ·ª®ng D·ª•ng Th·ª±c Ti·ªÖn</h4>
        <div class="formula-container">
          <div class="formula-title">T·ªëi ∆∞u L·ªìi</div>
          <div class="math-environment">$$\text{Dual problem solving}$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">Machine Learning</div>
          <div class="math-environment">$$\text{SVM, Lasso, Ridge}$$</div>
        </div>
        <div class="formula-container">
          <div class="formula-title">X·ª≠ L√Ω T√≠n Hi·ªáu</div>
          <div class="math-environment">$$\text{Image reconstruction}$$</div>
        </div>
      </div>
    </div>
    
    <div style="background: rgba(220, 53, 69, 0.1); padding: 20px; border-radius: 8px; margin-top: 20px;">
      <h4 style="color: #dc3545; font-size: 1.6em; margin-bottom: 15px;">üéØ T·∫ßm Quan Tr·ªçng Trong To√°n H·ªçc</h4>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
        <div>
          <h5 style="color: #ff6b6b; font-size: 1.3em;">Gi·∫£i T√≠ch L·ªìi:</h5>
          <ul style="font-size: 14px; line-height: 1.6;">
            <li>Bi·∫øn ƒë·ªïi gi·ªØa h√†m g·ªëc v√† h√†m li√™n h·ª£p</li>
            <li>ƒê·ªãnh l√Ω Fenchel-Moreau: $f^{**} = f$</li>
            <li>Bi·∫øn ph√¢n (subdifferential) v√† t·ªëi ∆∞u h√≥a</li>
            <li>H√¨nh h·ªçc c·ªßa epigraph v√† simpeau</li>
          </ul>
        </div>
        <div>
          <h5 style="color: #4ecdc4; font-size: 1.3em;">T·ªëi ∆∞u H√≥a:</h5>
          <ul style="font-size: 14px; line-height: 1.6;">
            <li>ƒê·ªëi ng·∫´u Lagrange v√† Fenchel</li>
            <li>ƒêi·ªÅu ki·ªán KKT v√† ƒë·ªëi ng·∫´u m·∫°nh</li>
            <li>Thu·∫≠t to√°n proximal v√† ADMM</li>
            <li>B√†i to√°n min-max v√† ƒëi·ªÉm y√™n ng·ª±a</li>
          </ul>
        </div>
        <div>
          <h5 style="color: #7c4dff; font-size: 1.3em;">Machine Learning:</h5>
          <ul style="font-size: 14px; line-height: 1.6;">
            <li>SVM: Dual formulation cho kernel methods</li>
            <li>Lasso regression: Soft-thresholding operator</li>
            <li>Deep learning: Regularization theory</li>
            <li>GANs: Optimal transport v√† Wasserstein distance</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ===========================================
       PH·∫¶N MINH H·ªåA T∆Ø∆†NG T√ÅC (INTERACTIVE ILLUSTRATION)
       =========================================== -->
  
  <div class="interactive-section">
    <h2 style="color: #4caf50; font-size: 2.5em; margin-bottom: 20px; text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üéÆ MINH H·ªåA T∆Ø∆†NG T√ÅC</h2>
    
    <div style="text-align: center; margin-bottom: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 10px;">
      <p style="font-size: 18px; color: #81c784; margin: 0;">Kh√°m ph√° tr·ª±c quan h√†m li√™n h·ª£p, ƒë·ªëi ng·∫´u Fenchel v√† c√°c gi·∫£i th√≠ch h√¨nh h·ªçc</p>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="info-panel">
      <h3 style="color: #4caf50; text-align: center; margin-bottom: 15px;">üîÑ H√†m Li√™n H·ª£p & ƒê·ªëi Ng·∫´u</h3>
      <p style="text-align: center; margin-bottom: 15px;">Kh√°m ph√° t∆∞∆°ng t√°c c√°c h√†m li√™n h·ª£p, ƒë·ªëi ng·∫´u Fenchel v√† gi·∫£i th√≠ch h√¨nh h·ªçc.</p>
      <div class="legend">
        <div class="legend-item" style="color: #0ff;">üîµ H√†m g·ªëc f(x)</div>
        <div class="legend-item" style="color: #ff00ff;">üü£ H√†m li√™n h·ª£p f*(y)</div>
        <div class="legend-item" style="color: #00ff00;">üü¢ ƒê∆∞·ªùng ti·∫øp tuy·∫øn yx - f*(y)</div>
        <div class="legend-item" style="color: #ff6b6b;">üî¥ Si√™u ph·∫≥ng ƒë·ª° tr·ª£</div>
        <div class="legend-item" style="color: #ffa500;">üü† Epigraph</div>
        <div class="legend-item" style="color: #ffff00;">üü° ƒêi·ªÉm ƒë·ªëi ng·∫´u</div>
      </div>
    </div>
        
    <div class="controls">
            <div class="control-section">
                <h3>Function Selection</h3>
                <div class="function-selector">
                    <button class="function-button active" onclick="selectFunction('quadratic')">Quadratic</button>
                    <button class="function-button" onclick="selectFunction('absolute')">Absolute Value</button>
                    <button class="function-button" onclick="selectFunction('exponential')">Exponential</button>
                    <button class="function-button" onclick="selectFunction('logistic')">Log-Sum-Exp</button>
                    <button class="function-button" onclick="selectFunction('norm')">Euclidean Norm</button>
                    <button class="function-button" onclick="selectFunction('entropy')">Negative Entropy</button>
                    <button class="function-button" onclick="selectFunction('hinge')">Hinge Loss</button>
                    <button class="function-button" onclick="selectFunction('huber')">Huber Loss</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Current Function</h3>
                <div id="function-info" class="function-info">
                    <!-- Function information will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Conjugate Function</h3>
                <div id="conjugate-info" class="conjugate-info">
                    <!-- Conjugate function information will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Interactive Duality</h3>
                <div class="slider-group">
                    <label>Dual Variable y:</label>
                    <input type="range" id="dualVariable" min="-3" max="3" step="0.1" value="1">
                    <div class="slider-value" id="dualVariableValue">1.0</div>
                </div>
                <div id="tangent-line" class="tangent-line">
                    <!-- Tangent line information will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Optimization Problem</h3>
                <div id="optimization-problem" class="optimization-problem">
                    <!-- Optimization problem will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Duality Gap Analysis</h3>
                <div id="duality-gap" class="duality-gap">
                    <!-- Duality gap analysis will be displayed here -->
                </div>
                <div class="slider-group">
                    <label>Primal Variable x:</label>
                    <input type="range" id="primalVariable" min="-3" max="3" step="0.1" value="0">
                    <div class="slider-value" id="primalVariableValue">0.0</div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visualization Options</h3>
                <div class="toggle-section">
                    <div class="toggle-button active" id="toggle-function" onclick="toggleVisualization('function')">
                        Original Function
                    </div>
                    <div class="toggle-button active" id="toggle-conjugate" onclick="toggleVisualization('conjugate')">
                        Conjugate Function
                    </div>
                    <div class="toggle-button active" id="toggle-tangent" onclick="toggleVisualization('tangent')">
                        Tangent Line
                    </div>
                    <div class="toggle-button" id="toggle-epigraph" onclick="toggleVisualization('epigraph')">
                        Epigraph
                    </div>
                    <div class="toggle-button" id="toggle-hyperplane" onclick="toggleVisualization('hyperplane')">
                        Support Hyperplane
                    </div>
                    <div class="toggle-button active" id="toggle-dualpoint" onclick="toggleVisualization('dualpoint')">
                        Dual Point
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Advanced Controls</h3>
                <div class="toggle-section">
          <div class="toggle-button" onclick="animateDuality()">
            üé¨ Ho·∫°t H√¨nh ƒê·ªëi Ng·∫´u
          </div>
          <div class="toggle-button" onclick="resetView()">
            üîÑ ƒê·∫∑t L·∫°i
          </div>
          <div class="toggle-button" onclick="showBiconjugate()">
            üîÑüîÑ Song Li√™n H·ª£p
          </div>
          <div class="toggle-button" onclick="findSaddlePoint()">
            üéØ ƒêi·ªÉm Y√™n Ng·ª±a
          </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 60;
        
        // Current function and parameters
        let currentFunction = 'quadratic';
        let dualVariable = 1;
        let primalVariable = 0;
        let isAnimating = false;
        let animationId = null;
        
        // Visualization options
        let showOptions = {
            function: true,
            conjugate: true,
            tangent: true,
            epigraph: false,
            hyperplane: false,
            dualpoint: true
        };
        
        // Function definitions with conjugates
        const functions = {
            quadratic: {
                name: 'Quadratic Function',
                formula: 'f(x) = ¬Ωx¬≤',
                func: (x) => 0.5 * x * x,
                conjugate: (y) => 0.5 * y * y,
                conjugateFormula: 'f*(y) = ¬Ωy¬≤',
                subdifferential: (x) => x,
                domain: '‚Ñù',
                conjugateDomain: '‚Ñù',
                convex: true
            },
            absolute: {
                name: 'Absolute Value',
                formula: 'f(x) = |x|',
                func: (x) => Math.abs(x),
                conjugate: (y) => Math.abs(y) <= 1 ? 0 : Infinity,
                conjugateFormula: 'f*(y) = Œ¥(y ‚àà [-1,1])',
                subdifferential: (x) => x >= 0 ? 1 : -1,
                domain: '‚Ñù',
                conjugateDomain: '[-1,1]',
                convex: true
            },
            exponential: {
                name: 'Exponential Function',
                formula: 'f(x) = eÀ£',
                func: (x) => Math.exp(x),
                conjugate: (y) => y <= 0 ? Infinity : y * Math.log(y) - y,
                conjugateFormula: 'f*(y) = y log(y) - y, y > 0',
                subdifferential: (x) => Math.exp(x),
                domain: '‚Ñù',
                conjugateDomain: '‚Ñù‚Çä',
                convex: true
            },
            logistic: {
                name: 'Log-Sum-Exp',
                formula: 'f(x) = log(1 + eÀ£)',
                func: (x) => Math.log(1 + Math.exp(x)),
                conjugate: (y) => {
                    if (y <= 0 || y >= 1) return Infinity;
                    return y * Math.log(y) + (1-y) * Math.log(1-y);
                },
                conjugateFormula: 'f*(y) = y log(y) + (1-y)log(1-y), y ‚àà (0,1)',
                subdifferential: (x) => 1 / (1 + Math.exp(-x)),
                domain: '‚Ñù',
                conjugateDomain: '(0,1)',
                convex: true
            },
            norm: {
                name: 'Euclidean Norm (1D)',
                formula: 'f(x) = |x|',
                func: (x) => Math.abs(x),
                conjugate: (y) => Math.abs(y) <= 1 ? 0 : Infinity,
                conjugateFormula: 'f*(y) = Œ¥(|y| ‚â§ 1)',
                subdifferential: (x) => x >= 0 ? 1 : -1,
                domain: '‚Ñù',
                conjugateDomain: '[-1,1]',
                convex: true
            },
            entropy: {
                name: 'Negative Entropy',
                formula: 'f(x) = x log(x) - x, x > 0',
                func: (x) => x > 0 ? x * Math.log(x) - x : Infinity,
                conjugate: (y) => Math.exp(y),
                conjugateFormula: 'f*(y) = e ∏',
                subdifferential: (x) => x > 0 ? Math.log(x) : NaN,
                domain: '‚Ñù‚Çä',
                conjugateDomain: '‚Ñù',
                convex: true
            },
            hinge: {
                name: 'Hinge Loss',
                formula: 'f(x) = max(0, 1-x)',
                func: (x) => Math.max(0, 1 - x),
                conjugate: (y) => {
                    if (y < -1 || y > 0) return Infinity;
                    return -y;
                },
                conjugateFormula: 'f*(y) = -y, y ‚àà [-1,0]',
                subdifferential: (x) => x < 1 ? -1 : 0,
                domain: '‚Ñù',
                conjugateDomain: '[-1,0]',
                convex: true
            },
            huber: {
                name: 'Huber Loss',
                formula: 'f(x) = ¬Ωx¬≤ if |x| ‚â§ 1, |x| - ¬Ω otherwise',
                func: (x) => Math.abs(x) <= 1 ? 0.5 * x * x : Math.abs(x) - 0.5,
                conjugate: (y) => {
                    const ay = Math.abs(y);
                    if (ay <= 1) return 0.5 * y * y;
                    return ay - 0.5;
                },
                conjugateFormula: 'f*(y) = ¬Ωy¬≤ if |y| ‚â§ 1, |y| - ¬Ω otherwise',
                subdifferential: (x) => Math.abs(x) <= 1 ? x : Math.sign(x),
                domain: '‚Ñù',
                conjugateDomain: '‚Ñù',
                convex: true
            }
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function selectFunction(funcName) {
            currentFunction = funcName;
            
            // Update active button
            document.querySelectorAll('.function-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            updateFunctionInfo();
            updateConjugateInfo();
            updateTangentLine();
            updateOptimizationProblem();
            updateDualityGap();
            draw();
        }
        
        function updateFunctionInfo() {
            const func = functions[currentFunction];
            document.getElementById('function-info').innerHTML = `
                <strong>${func.name}</strong><br/>
                Formula: ${func.formula}<br/>
                Domain: ${func.domain}<br/>
                Convex: ${func.convex ? 'Yes' : 'No'}
            `;
        }
        
        function updateConjugateInfo() {
            const func = functions[currentFunction];
            document.getElementById('conjugate-info').innerHTML = `
                <strong>Conjugate Function f*(y)</strong><br/>
                Formula: ${func.conjugateFormula}<br/>
                Domain: ${func.conjugateDomain}<br/>
                Definition: f*(y) = sup{xy - f(x) : x ‚àà dom(f)}
            `;
        }
        
        function updateTangentLine() {
            const func = functions[currentFunction];
            const y = dualVariable;
            const conjugateValue = func.conjugate(y);
            
            let html = `<strong>Tangent Line at y = ${y.toFixed(2)}</strong><br/>`;
            html += `f*(${y.toFixed(2)}) = ${isFinite(conjugateValue) ? conjugateValue.toFixed(3) : '‚àû'}<br/>`;
            html += `Tangent line: h(x) = ${y.toFixed(2)}x - ${isFinite(conjugateValue) ? conjugateValue.toFixed(3) : '‚àû'}<br/>`;
            html += `This line supports f(x) from below`;
            
            document.getElementById('tangent-line').innerHTML = html;
        }
        
        function updateOptimizationProblem() {
            const func = functions[currentFunction];
            const y = dualVariable;
            
            let html = '<strong>Fenchel Duality:</strong><br/><br/>';
            html += 'Primal Problem:<br/>';
            html += `minimize f(x)<br/><br/>`;
            html += 'Dual Problem:<br/>';
            html += `maximize ${y.toFixed(2)}x - f*(${y.toFixed(2)})<br/>`;
            html += `= maximize ${y.toFixed(2)}x - ${isFinite(func.conjugate(y)) ? func.conjugate(y).toFixed(3) : '‚àû'}<br/><br/>`;
            html += 'Strong Duality holds for convex f';
            
            document.getElementById('optimization-problem').innerHTML = html;
        }
        
        function updateDualityGap() {
            const func = functions[currentFunction];
            const x = primalVariable;
            const y = dualVariable;
            
            const primalValue = func.func(x);
            const dualValue = y * x - func.conjugate(y);
            const gap = primalValue - dualValue;
            
            let html = '<strong>Duality Gap Analysis:</strong><br/><br/>';
            html += `Primal point: x = ${x.toFixed(2)}<br/>`;
            html += `Dual point: y = ${y.toFixed(2)}<br/><br/>`;
            html += `Primal value: f(${x.toFixed(2)}) = ${primalValue.toFixed(3)}<br/>`;
            html += `Dual value: ${y.toFixed(2)}¬∑${x.toFixed(2)} - f*(${y.toFixed(2)}) = ${isFinite(dualValue) ? dualValue.toFixed(3) : '-‚àû'}<br/><br/>`;
            html += `Duality gap: ${isFinite(gap) ? gap.toFixed(3) : '‚àû'}<br/>`;
            html += `${Math.abs(gap) < 0.01 ? 'Strong duality achieved!' : 'Gap > 0 (weak duality)'}`;
            
            document.getElementById('duality-gap').innerHTML = html;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -10; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawFunction() {
            if (!showOptions.function) return;
            
            const func = functions[currentFunction];
            const step = 0.05;
            
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let x = -5; x <= 5; x += step) {
                const y = func.func(x);
                if (isFinite(y) && Math.abs(y) < 10) {
                    if (firstPoint) {
                        ctx.moveTo(toCanvasX(x), toCanvasY(y));
                        firstPoint = false;
                    } else {
                        ctx.lineTo(toCanvasX(x), toCanvasY(y));
                    }
                }
            }
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#0ff';
            ctx.font = '14px Arial';
            ctx.fillText('f(x)', 20, 30);
        }
        
        function drawConjugate() {
            if (!showOptions.conjugate) return;
            
            const func = functions[currentFunction];
            const step = 0.05;
            
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let y = -5; y <= 5; y += step) {
                const value = func.conjugate(y);
                if (isFinite(value) && Math.abs(value) < 10) {
                    if (firstPoint) {
                        ctx.moveTo(toCanvasX(y), toCanvasY(value));
                        firstPoint = false;
                    } else {
                        ctx.lineTo(toCanvasX(y), toCanvasY(value));
                    }
                }
            }
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#ff00ff';
            ctx.font = '14px Arial';
            ctx.fillText('f*(y)', 20, 50);
        }
        
        function drawTangentLine() {
            if (!showOptions.tangent) return;
            
            const func = functions[currentFunction];
            const y = dualVariable;
            const conjugateValue = func.conjugate(y);
            
            if (!isFinite(conjugateValue)) return;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Draw tangent line: h(x) = yx - f*(y)
            ctx.beginPath();
            const x1 = -5;
            const x2 = 5;
            const y1 = y * x1 - conjugateValue;
            const y2 = y * x2 - conjugateValue;
            
            if (isFinite(y1) && isFinite(y2)) {
                ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Label
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Arial';
            ctx.fillText(`y=${y.toFixed(1)} tangent`, 20, 90);
        }
        
        function drawEpigraph() {
            if (!showOptions.epigraph) return;
            
            const func = functions[currentFunction];
            const step = 0.1;
            
            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
            
            for (let x = -5; x <= 5; x += step) {
                const fx = func.func(x);
                if (isFinite(fx) && fx < 8) {
                    const canvasX = toCanvasX(x);
                    const height_pixels = Math.max(0, toCanvasY(fx));
                    ctx.fillRect(canvasX - 1, 0, 2, height_pixels);
                }
            }
        }
        
        function drawSupportingHyperplane() {
            if (!showOptions.hyperplane) return;
            
            const func = functions[currentFunction];
            const y = dualVariable;
            const conjugateValue = func.conjugate(y);
            
            if (!isFinite(conjugateValue)) return;
            
            // Find the point where the hyperplane supports the function
            let bestX = 0;
            let minDiff = Infinity;
            
            for (let x = -5; x <= 5; x += 0.1) {
                const fx = func.func(x);
                const hyperplaneValue = y * x - conjugateValue;
                const diff = Math.abs(fx - hyperplaneValue);
                
                if (isFinite(fx) && isFinite(hyperplaneValue) && diff < minDiff) {
                    minDiff = diff;
                    bestX = x;
                }
            }
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            // Draw supporting hyperplane
            ctx.beginPath();
            const x1 = bestX - 2;
            const x2 = bestX + 2;
            const y1 = y * x1 - conjugateValue;
            const y2 = y * x2 - conjugateValue;
            
            if (isFinite(y1) && isFinite(y2)) {
                ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
                ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
                ctx.stroke();
                
                // Mark support point
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(toCanvasX(bestX), toCanvasY(func.func(bestX)), 4, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawDualPoint() {
            if (!showOptions.dualpoint) return;
            
            const func = functions[currentFunction];
            const y = dualVariable;
            const conjugateValue = func.conjugate(y);
            
            if (!isFinite(conjugateValue)) return;
            
            // Draw dual point on conjugate function
            ctx.fillStyle = '#ffff00';
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(y), toCanvasY(conjugateValue), 6, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(y), toCanvasY(conjugateValue), 10, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#ffff00';
            ctx.font = '12px Arial';
            ctx.fillText(`(${y.toFixed(1)}, ${conjugateValue.toFixed(2)})`, 
                toCanvasX(y) + 12, 
                toCanvasY(conjugateValue) - 8);
        }
        
        function drawPrimalDualPoints() {
            const func = functions[currentFunction];
            const x = primalVariable;
            const y = dualVariable;
            
            // Draw primal point
            ctx.fillStyle = '#0ff';
            ctx.beginPath();
            ctx.arc(toCanvasX(x), toCanvasY(func.func(x)), 4, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw dual point
            const conjugateValue = func.conjugate(y);
            if (isFinite(conjugateValue)) {
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(toCanvasX(y), toCanvasY(conjugateValue), 4, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            drawEpigraph();
            drawFunction();
            drawConjugate();
            drawTangentLine();
            drawSupportingHyperplane();
            drawDualPoint();
            drawPrimalDualPoints();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        function animateDuality() {
            if (isAnimating) {
                isAnimating = false;
                if (animationId) cancelAnimationFrame(animationId);
                return;
            }
            
            isAnimating = true;
            let animationTime = 0;
            
            function animate() {
                if (!isAnimating) return;
                
                animationTime += 0.02;
                dualVariable = 2 * Math.sin(animationTime);
                
                document.getElementById('dualVariable').value = dualVariable;
                document.getElementById('dualVariableValue').textContent = dualVariable.toFixed(1);
                
                updateTangentLine();
                updateOptimizationProblem();
                updateDualityGap();
                draw();
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function showBiconjugate() {
            alert('For convex functions, f** = f (biconjugate equals original function). This is the Fenchel-Moreau theorem!');
        }
        
        function findSaddlePoint() {
            // Find where primal and dual values are closest (saddle point of Lagrangian)
            let bestX = 0, bestY = 0, minGap = Infinity;
            
            for (let x = -3; x <= 3; x += 0.1) {
                for (let y = -3; y <= 3; y += 0.1) {
                    const func = functions[currentFunction];
                    const primalVal = func.func(x);
                    const dualVal = y * x - func.conjugate(y);
                    
                    if (isFinite(primalVal) && isFinite(dualVal)) {
                        const gap = Math.abs(primalVal - dualVal);
                        if (gap < minGap) {
                            minGap = gap;
                            bestX = x;
                            bestY = y;
                        }
                    }
                }
            }
            
            primalVariable = bestX;
            dualVariable = bestY;
            
            document.getElementById('primalVariable').value = bestX;
            document.getElementById('dualVariable').value = bestY;
            document.getElementById('primalVariableValue').textContent = bestX.toFixed(1);
            document.getElementById('dualVariableValue').textContent = bestY.toFixed(1);
            
            updateTangentLine();
            updateOptimizationProblem();
            updateDualityGap();
            draw();
        }
        
        function resetView() {
            isAnimating = false;
            if (animationId) cancelAnimationFrame(animationId);
            
            dualVariable = 1;
            primalVariable = 0;
            
            document.getElementById('dualVariable').value = 1;
            document.getElementById('primalVariable').value = 0;
            document.getElementById('dualVariableValue').textContent = '1.0';
            document.getElementById('primalVariableValue').textContent = '0.0';
            
            updateTangentLine();
            updateOptimizationProblem();
            updateDualityGap();
            draw();
        }
        
        // Event listeners
        document.getElementById('dualVariable').addEventListener('input', function() {
            dualVariable = parseFloat(this.value);
            document.getElementById('dualVariableValue').textContent = dualVariable.toFixed(1);
            updateTangentLine();
            updateOptimizationProblem();
            updateDualityGap();
            draw();
        });
        
        document.getElementById('primalVariable').addEventListener('input', function() {
            primalVariable = parseFloat(this.value);
            document.getElementById('primalVariableValue').textContent = primalVariable.toFixed(1);
            updateDualityGap();
            draw();
        });
        
        // Initialize
        selectFunction('quadratic');
        draw();
    </script>
</body>
</html>
