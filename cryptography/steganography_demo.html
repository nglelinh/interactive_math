<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üñºÔ∏è Steganography: Hidden Messages in Images</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2d1b69 0%, #11047a 50%, #1e40af 100%);
            color: #ffffff;
            min-height: 100vh;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #f7fafc;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .intro {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #9f7aea;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }
        
        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(247, 250, 252, 0.3);
        }
        
        .canvas-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(247, 250, 252, 0.2);
        }
        
        canvas {
            border: 2px solid #4a5568;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
            background: white;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #e2e8f0;
        }
        
        .control-group input, .control-group textarea, .control-group select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #4a5568;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            box-sizing: border-box;
        }
        
        .control-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .btn {
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin: 5px;
            width: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn-encode {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }
        
        .btn-decode {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        }
        
        .btn-download {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
        }
        
        .file-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #9f7aea;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .file-input:hover {
            background: rgba(159, 122, 234, 0.1);
        }
        
        .method-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #4299e1;
        }
        
        .result-panel {
            background: rgba(66, 153, 225, 0.1);
            border: 1px solid #4299e1;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .success {
            background: rgba(72, 187, 120, 0.1);
            border-color: #48bb78;
        }
        
        .warning {
            background: rgba(237, 137, 54, 0.1);
            border-color: #ed8936;
        }
        
        .error {
            background: rgba(245, 101, 101, 0.1);
            border-color: #f56565;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }
        
        .binary-display {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            word-break: break-all;
            margin: 10px 0;
        }
        
        .capacity-info {
            background: rgba(159, 122, 234, 0.1);
            border: 1px solid #9f7aea;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .steganography-steps {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .step {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #9f7aea;
        }
        
        .step h4 {
            margin: 0 0 10px 0;
            color: #9f7aea;
        }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            height: 20px;
            margin: 10px 0;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #9f7aea, #48bb78);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            .demo-grid, .three-column {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üñºÔ∏è Steganography: Hidden Messages in Images</h1>
        
        <div class="intro">
            <h2>What is Steganography?</h2>
            <p><strong>Steganography</strong> is the practice of concealing a file, message, image, or video within another file, message, image, or video. The word derives from the Greek words "steganos" (covered or concealed) and "graphein" (writing).</p>
            <p>Unlike cryptography, which hides the content of a message, steganography hides the very existence of the message itself.</p>
        </div>
        
        <div class="method-section">
            <h3>üîç LSB (Least Significant Bit) Method</h3>
            <p>The LSB method embeds data in the least significant bits of pixel values. Since human eyes are less sensitive to small changes in pixel values, this method is nearly invisible.</p>
            
            <div class="math-formula">
                <p><strong>Mathematical Foundation:</strong></p>
                <p>For an 8-bit pixel value P = b‚Çáb‚ÇÜb‚ÇÖb‚ÇÑb‚ÇÉb‚ÇÇb‚ÇÅb‚ÇÄ</p>
                <p>We replace b‚ÇÄ (LSB) with our hidden bit</p>
                <p>Modified pixel: P' = b‚Çáb‚ÇÜb‚ÇÖb‚ÇÑb‚ÇÉb‚ÇÇb‚ÇÅ<strong>h</strong></p>
                <p>Where <strong>h</strong> is the hidden bit</p>
            </div>
        </div>
        
        <div class="demo-grid">
            <div class="control-panel">
                <h3>üìù Encoding (Hide Message)</h3>
                
                <div class="control-group">
                    <label>Upload Cover Image:</label>
                    <div class="file-input" onclick="document.getElementById('imageInput').click()">
                        <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="loadImage(this)">
                        Click to select an image file
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Secret Message:</label>
                    <textarea id="secretMessage" placeholder="Enter your secret message here..."></textarea>
                </div>
                
                <div class="control-group">
                    <label>Encoding Method:</label>
                    <select id="encodingMethod">
                        <option value="lsb">LSB (Least Significant Bit)</option>
                        <option value="lsb-random">LSB with Random Distribution</option>
                        <option value="dct">DCT Domain (Advanced)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Password (Optional):</label>
                    <input type="password" id="password" placeholder="Enter password for additional security">
                </div>
                
                <button class="btn btn-encode" onclick="encodeMessage()">üîí Hide Message in Image</button>
                <button class="btn btn-download" onclick="downloadStegImage()">‚¨áÔ∏è Download Stego Image</button>
                
                <div id="capacityInfo" class="capacity-info" style="display: none;">
                    <h4>üìä Capacity Analysis</h4>
                    <div id="capacityDetails"></div>
                </div>
            </div>
            
            <div class="control-panel">
                <h3>üîç Decoding (Extract Message)</h3>
                
                <div class="control-group">
                    <label>Upload Stego Image:</label>
                    <div class="file-input" onclick="document.getElementById('stegoInput').click()">
                        <input type="file" id="stegoInput" accept="image/*" style="display: none;" onchange="loadStegoImage(this)">
                        Click to select stego image
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Decoding Method:</label>
                    <select id="decodingMethod">
                        <option value="lsb">LSB (Least Significant Bit)</option>
                        <option value="lsb-random">LSB with Random Distribution</option>
                        <option value="dct">DCT Domain (Advanced)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Password (if used):</label>
                    <input type="password" id="decodePassword" placeholder="Enter password if message was encrypted">
                </div>
                
                <button class="btn btn-decode" onclick="decodeMessage()">üîì Extract Hidden Message</button>
                
                <div id="extractedMessage" class="result-panel" style="display: none;">
                    <h4>üìú Extracted Message:</h4>
                    <div id="messageContent"></div>
                </div>
            </div>
        </div>
        
        <div class="three-column">
            <div class="canvas-container">
                <h4>üì∏ Original Image</h4>
                <canvas id="originalCanvas"></canvas>
                <div id="originalInfo"></div>
            </div>
            
            <div class="canvas-container">
                <h4>üñºÔ∏è Stego Image</h4>
                <canvas id="stegoCanvas"></canvas>
                <div id="stegoInfo"></div>
            </div>
            
            <div class="canvas-container">
                <h4>üîç Difference Analysis</h4>
                <canvas id="diffCanvas"></canvas>
                <div id="diffInfo"></div>
            </div>
        </div>
        
        <div class="steganography-steps">
            <div class="step">
                <h4>Step 1: Image Preprocessing</h4>
                <p>Convert the cover image to a suitable format and analyze its capacity for hiding data.</p>
                <div class="binary-display" id="step1Display">Waiting for image...</div>
            </div>
            
            <div class="step">
                <h4>Step 2: Message Preparation</h4>
                <p>Convert the secret message to binary and add necessary headers for reconstruction.</p>
                <div class="binary-display" id="step2Display">Waiting for message...</div>
            </div>
            
            <div class="step">
                <h4>Step 3: Bit Embedding</h4>
                <p>Replace the least significant bits of pixel values with message bits.</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="embedProgress" style="width: 0%"></div>
                </div>
                <div id="step3Display">Ready to embed...</div>
            </div>
        </div>
        
        <div class="method-section">
            <h3>üõ°Ô∏è Security Considerations</h3>
            
            <div class="demo-grid">
                <div class="result-panel">
                    <h4>üîç Steganalysis Resistance</h4>
                    <ul>
                        <li><strong>Visual Analysis:</strong> Minimal visible distortion</li>
                        <li><strong>Statistical Analysis:</strong> Chi-square and histogram analysis</li>
                        <li><strong>Spatial Analysis:</strong> LSB plane analysis</li>
                        <li><strong>Transform Domain:</strong> Frequency domain analysis</li>
                    </ul>
                </div>
                
                <div class="result-panel">
                    <h4>üìà Capacity vs. Security Trade-off</h4>
                    <div id="securityAnalysis">
                        <p><strong>Current Configuration:</strong></p>
                        <p>Capacity: <span id="currentCapacity">0</span> bytes</p>
                        <p>Security Level: <span id="securityLevel">High</span></p>
                        <p>Detectability Risk: <span id="detectabilityRisk">Low</span></p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="method-section">
            <h3>üßÆ Mathematical Analysis</h3>
            
            <div class="math-formula">
                <h4>Capacity Calculation:</h4>
                <p>For an image of size W √ó H with C channels:</p>
                <p><strong>Maximum Capacity = (W √ó H √ó C √ó bits_per_pixel) / 8 bytes</strong></p>
                <p>For LSB method: bits_per_pixel = 1</p>
                <p>Practical capacity ‚âà 12.5% of image size (including headers and error correction)</p>
            </div>
            
            <div class="math-formula">
                <h4>PSNR (Peak Signal-to-Noise Ratio):</h4>
                <p><strong>PSNR = 10 √ó log‚ÇÅ‚ÇÄ(MAX¬≤/MSE)</strong></p>
                <p>Where MSE = Mean Square Error between original and stego image</p>
                <p>Higher PSNR indicates better image quality preservation</p>
                <div id="psnrDisplay">PSNR: Waiting for images...</div>
            </div>
        </div>
    </div>

    <script>
        let originalImageData = null;
        let stegoImageData = null;
        let originalCanvas = document.getElementById('originalCanvas');
        let stegoCanvas = document.getElementById('stegoCanvas');
        let diffCanvas = document.getElementById('diffCanvas');
        let originalCtx = originalCanvas.getContext('2d');
        let stegoCtx = stegoCanvas.getContext('2d');
        let diffCtx = diffCanvas.getContext('2d');
        
        // Simple XOR encryption for password protection
        function simpleEncrypt(text, password) {
            if (!password) return text;
            let result = '';
            for (let i = 0; i < text.length; i++) {
                result += String.fromCharCode(text.charCodeAt(i) ^ password.charCodeAt(i % password.length));
            }
            return result;
        }
        
        function simpleDecrypt(encryptedText, password) {
            return simpleEncrypt(encryptedText, password); // XOR is its own inverse
        }
        
        function loadImage(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Resize canvas to fit image
                    originalCanvas.width = Math.min(img.width, 400);
                    originalCanvas.height = (img.height * originalCanvas.width) / img.width;
                    
                    originalCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
                    originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                    
                    updateCapacityInfo();
                    updateStep1Display();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function loadStegoImage(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    stegoCanvas.width = Math.min(img.width, 400);
                    stegoCanvas.height = (img.height * stegoCanvas.width) / img.width;
                    
                    stegoCtx.drawImage(img, 0, 0, stegoCanvas.width, stegoCanvas.height);
                    stegoImageData = stegoCtx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function updateCapacityInfo() {
            if (!originalImageData) return;
            
            const totalPixels = originalImageData.width * originalImageData.height;
            const maxCapacity = Math.floor(totalPixels * 3 / 8); // 3 bits per pixel (RGB), 8 bits per byte
            const practicalCapacity = Math.floor(maxCapacity * 0.8); // 80% for safety and headers
            
            document.getElementById('capacityInfo').style.display = 'block';
            document.getElementById('capacityDetails').innerHTML = `
                <p><strong>Image Dimensions:</strong> ${originalImageData.width} √ó ${originalImageData.height}</p>
                <p><strong>Total Pixels:</strong> ${totalPixels.toLocaleString()}</p>
                <p><strong>Maximum Capacity:</strong> ${maxCapacity.toLocaleString()} bytes</p>
                <p><strong>Practical Capacity:</strong> ${practicalCapacity.toLocaleString()} bytes</p>
                <p><strong>Characters (UTF-8):</strong> ~${practicalCapacity.toLocaleString()} characters</p>
            `;
            
            document.getElementById('currentCapacity').textContent = practicalCapacity;
        }
        
        function updateStep1Display() {
            if (!originalImageData) return;
            
            const firstPixels = originalImageData.data.slice(0, 12); // First 4 pixels (RGBA)
            let binary = '';
            for (let i = 0; i < firstPixels.length; i += 4) {
                const r = firstPixels[i].toString(2).padStart(8, '0');
                const g = firstPixels[i + 1].toString(2).padStart(8, '0');
                const b = firstPixels[i + 2].toString(2).padStart(8, '0');
                binary += `R:${r} G:${g} B:${b} `;
            }
            
            document.getElementById('step1Display').textContent = binary;
        }
        
        function stringToBinary(str) {
            let binary = '';
            for (let i = 0; i < str.length; i++) {
                binary += str.charCodeAt(i).toString(2).padStart(8, '0');
            }
            return binary;
        }
        
        function binaryToString(binary) {
            let str = '';
            for (let i = 0; i < binary.length; i += 8) {
                const byte = binary.substr(i, 8);
                if (byte.length === 8) {
                    str += String.fromCharCode(parseInt(byte, 2));
                }
            }
            return str;
        }
        
        function encodeMessage() {
            if (!originalImageData) {
                alert('Please load an image first!');
                return;
            }
            
            const message = document.getElementById('secretMessage').value;
            if (!message) {
                alert('Please enter a message to hide!');
                return;
            }
            
            const password = document.getElementById('password').value;
            const method = document.getElementById('encodingMethod').value;
            
            // Encrypt message if password provided
            const finalMessage = password ? simpleEncrypt(message, password) : message;
            
            // Add delimiter to mark end of message
            const messageWithDelimiter = finalMessage + '\0\0\0'; // Null terminators
            const messageBinary = stringToBinary(messageWithDelimiter);
            
            // Update step 2 display
            document.getElementById('step2Display').textContent = 
                `Message: "${message}" ‚Üí Binary: ${messageBinary.substring(0, 64)}...`;
            
            // Check capacity
            const requiredBits = messageBinary.length;
            const availableBits = originalImageData.width * originalImageData.height * 3; // RGB channels
            
            if (requiredBits > availableBits) {
                alert(`Message too long! Required: ${requiredBits} bits, Available: ${availableBits} bits`);
                return;
            }
            
            // Create copy of image data
            stegoImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            
            // Embed message based on method
            if (method === 'lsb') {
                embedLSB(stegoImageData, messageBinary);
            } else if (method === 'lsb-random') {
                embedLSBRandom(stegoImageData, messageBinary, password || 'default');
            }
            
            // Display stego image
            stegoCanvas.width = originalCanvas.width;
            stegoCanvas.height = originalCanvas.height;
            stegoCtx.putImageData(stegoImageData, 0, 0);
            
            // Calculate and display differences
            calculateDifference();
            calculatePSNR();
            updateSecurityAnalysis(messageBinary.length);
            
            document.getElementById('step3Display').textContent = 
                `Embedded ${messageBinary.length} bits successfully!`;
        }
        
        function embedLSB(imageData, messageBinary) {
            let bitIndex = 0;
            const data = imageData.data;
            
            for (let i = 0; i < data.length - 1 && bitIndex < messageBinary.length; i += 4) {
                // Skip alpha channel, use only RGB
                for (let channel = 0; channel < 3 && bitIndex < messageBinary.length; channel++) {
                    const pixelIndex = i + channel;
                    const messageBit = parseInt(messageBinary[bitIndex]);
                    
                    // Clear LSB and set it to message bit
                    data[pixelIndex] = (data[pixelIndex] & 0xFE) | messageBit;
                    
                    bitIndex++;
                    
                    // Update progress
                    const progress = (bitIndex / messageBinary.length) * 100;
                    document.getElementById('embedProgress').style.width = progress + '%';
                }
            }
        }
        
        function embedLSBRandom(imageData, messageBinary, seed) {
            // Simple pseudo-random generator based on seed
            let rng = simpleHash(seed);
            const positions = [];
            
            // Generate random positions
            for (let i = 0; i < messageBinary.length; i++) {
                rng = (rng * 9301 + 49297) % 233280;
                const pos = Math.floor((rng / 233280) * (imageData.data.length / 4) * 3);
                positions.push(pos);
            }
            
            // Embed at random positions
            for (let i = 0; i < messageBinary.length; i++) {
                const pos = positions[i];
                const pixelIndex = Math.floor(pos / 3) * 4 + (pos % 3);
                const messageBit = parseInt(messageBinary[i]);
                
                imageData.data[pixelIndex] = (imageData.data[pixelIndex] & 0xFE) | messageBit;
                
                const progress = ((i + 1) / messageBinary.length) * 100;
                document.getElementById('embedProgress').style.width = progress + '%';
            }
        }
        
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }
        
        function decodeMessage() {
            if (!stegoImageData) {
                alert('Please load a stego image first!');
                return;
            }
            
            const method = document.getElementById('decodingMethod').value;
            const password = document.getElementById('decodePassword').value;
            
            let extractedBinary = '';
            
            if (method === 'lsb') {
                extractedBinary = extractLSB(stegoImageData);
            } else if (method === 'lsb-random') {
                extractedBinary = extractLSBRandom(stegoImageData, password || 'default');
            }
            
            // Convert binary to string and find delimiter
            const extractedMessage = binaryToString(extractedBinary);
            const delimiterIndex = extractedMessage.indexOf('\0\0\0');
            
            if (delimiterIndex === -1) {
                alert('No hidden message found or wrong decoding method!');
                return;
            }
            
            let finalMessage = extractedMessage.substring(0, delimiterIndex);
            
            // Decrypt if password provided
            if (password) {
                finalMessage = simpleDecrypt(finalMessage, password);
            }
            
            // Display extracted message
            document.getElementById('extractedMessage').style.display = 'block';
            document.getElementById('messageContent').innerHTML = `
                <p><strong>Extracted Message:</strong></p>
                <div class="binary-display">${finalMessage}</div>
                <p><strong>Message Length:</strong> ${finalMessage.length} characters</p>
                <p><strong>Extraction Method:</strong> ${method.toUpperCase()}</p>
            `;
        }
        
        function extractLSB(imageData) {
            let binary = '';
            const data = imageData.data;
            
            for (let i = 0; i < data.length - 1; i += 4) {
                for (let channel = 0; channel < 3; channel++) {
                    const pixelIndex = i + channel;
                    const lsb = data[pixelIndex] & 1;
                    binary += lsb.toString();
                    
                    // Stop if we have enough for a reasonable message
                    if (binary.length > 10000) break;
                }
                if (binary.length > 10000) break;
            }
            
            return binary;
        }
        
        function extractLSBRandom(imageData, seed) {
            let rng = simpleHash(seed);
            let binary = '';
            
            // Extract from same random positions used in encoding
            for (let i = 0; i < 10000; i++) { // Extract reasonable amount
                rng = (rng * 9301 + 49297) % 233280;
                const pos = Math.floor((rng / 233280) * (imageData.data.length / 4) * 3);
                const pixelIndex = Math.floor(pos / 3) * 4 + (pos % 3);
                
                if (pixelIndex < imageData.data.length) {
                    const lsb = imageData.data[pixelIndex] & 1;
                    binary += lsb.toString();
                }
            }
            
            return binary;
        }
        
        function calculateDifference() {
            if (!originalImageData || !stegoImageData) return;
            
            diffCanvas.width = originalCanvas.width;
            diffCanvas.height = originalCanvas.height;
            
            const diffData = diffCtx.createImageData(originalCanvas.width, originalCanvas.height);
            
            for (let i = 0; i < originalImageData.data.length; i += 4) {
                const rDiff = Math.abs(originalImageData.data[i] - stegoImageData.data[i]);
                const gDiff = Math.abs(originalImageData.data[i + 1] - stegoImageData.data[i + 1]);
                const bDiff = Math.abs(originalImageData.data[i + 2] - stegoImageData.data[i + 2]);
                
                // Amplify differences for visibility
                diffData.data[i] = rDiff * 50;
                diffData.data[i + 1] = gDiff * 50;
                diffData.data[i + 2] = bDiff * 50;
                diffData.data[i + 3] = 255; // Alpha
            }
            
            diffCtx.putImageData(diffData, 0, 0);
            
            document.getElementById('diffInfo').innerHTML = 
                '<p>Differences amplified 50x for visibility</p><p>Darker areas = no change</p>';
        }
        
        function calculatePSNR() {
            if (!originalImageData || !stegoImageData) return;
            
            let mse = 0;
            const totalPixels = originalImageData.width * originalImageData.height * 3;
            
            for (let i = 0; i < originalImageData.data.length; i += 4) {
                for (let channel = 0; channel < 3; channel++) {
                    const diff = originalImageData.data[i + channel] - stegoImageData.data[i + channel];
                    mse += diff * diff;
                }
            }
            
            mse /= totalPixels;
            const psnr = mse === 0 ? Infinity : 10 * Math.log10((255 * 255) / mse);
            
            document.getElementById('psnrDisplay').innerHTML = 
                `<strong>PSNR: ${psnr.toFixed(2)} dB</strong><br>
                (>40 dB: Excellent, 30-40 dB: Good, <30 dB: Poor)`;
        }
        
        function updateSecurityAnalysis(messageBits) {
            const totalBits = originalImageData ? originalImageData.width * originalImageData.height * 3 : 0;
            const utilizationRatio = messageBits / totalBits;
            
            let securityLevel, detectabilityRisk;
            
            if (utilizationRatio < 0.01) {
                securityLevel = 'Very High';
                detectabilityRisk = 'Very Low';
            } else if (utilizationRatio < 0.05) {
                securityLevel = 'High';
                detectabilityRisk = 'Low';
            } else if (utilizationRatio < 0.1) {
                securityLevel = 'Medium';
                detectabilityRisk = 'Medium';
            } else {
                securityLevel = 'Low';
                detectabilityRisk = 'High';
            }
            
            document.getElementById('securityLevel').textContent = securityLevel;
            document.getElementById('detectabilityRisk').textContent = detectabilityRisk;
        }
        
        function downloadStegImage() {
            if (!stegoImageData) {
                alert('No stego image to download!');
                return;
            }
            
            const link = document.createElement('a');
            link.download = 'stego_image.png';
            link.href = stegoCanvas.toDataURL();
            link.click();
        }
        
        // Initialize MathJax when page loads
        window.onload = function() {
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        };
    </script>
</body>
</html>
