<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåä Continuum Mechanics - Interactive Physics</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f1419 0%, #1a202c 50%, #2d3748 100%);
            color: #ffffff;
            min-height: 100vh;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #63b3ed;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        h2 {
            color: #81e6d9;
            border-bottom: 2px solid #63b3ed;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        
        h3 {
            color: #f7fafc;
            margin-top: 30px;
        }
        
        .intro {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #63b3ed;
        }
        
        .concept-box {
            background: rgba(129, 230, 217, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #81e6d9;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }
        
        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }
        
        .continuum-simulator {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #63b3ed;
            border-radius: 10px;
            height: 400px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .stress-visualization {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #81e6d9;
            border-radius: 10px;
            height: 350px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .strain-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
        }
        
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ed8936;
            border-radius: 50%;
            transition: all 0.1s ease;
        }
        
        .flow-line {
            stroke: #48bb78;
            stroke-width: 2;
            fill: none;
            opacity: 0.8;
        }
        
        .stress-tensor {
            background: rgba(237, 137, 54, 0.2);
            border: 2px solid #ed8936;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .button {
            background: linear-gradient(45deg, #63b3ed, #81e6d9);
            color: #1a202c;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(99, 179, 237, 0.4);
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
        }
        
        .parameter-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 3px solid #63b3ed;
        }
        
        .tensor-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .tensor-element {
            background: rgba(99, 179, 237, 0.2);
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .deformation-canvas {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #f093fb;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .legend {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
        }
        
        @media (max-width: 768px) {
            .demo-grid, .three-column {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Continuum Mechanics</h1>
        
        <div class="intro">
            <p><strong>Continuum Mechanics</strong> is the branch of mechanics that deals with the analysis of the mechanical behavior of materials modeled as continuous masses rather than discrete particles. It provides the mathematical framework for describing the motion and deformation of solids, liquids, and gases.</p>
            
            <p>This field bridges the gap between molecular-scale physics and macroscopic engineering applications, making it fundamental to understanding everything from structural engineering to fluid dynamics to geophysics.</p>
        </div>

        <h2>üéØ Fundamental Concepts</h2>
        
        <div class="concept-box">
            <h3>The Continuum Hypothesis</h3>
            <p>The continuum hypothesis assumes that matter can be treated as continuously distributed throughout space, ignoring its discrete molecular structure. This allows us to define properties like density, velocity, and stress as continuous fields.</p>
            
            <div class="math-formula">
                <p><strong>Density Field:</strong></p>
                $$\rho(\mathbf{x}, t) = \lim_{V \to 0} \frac{\Delta m}{\Delta V}$$
                <p>Where the limit is taken as the volume approaches a size much larger than molecular dimensions but much smaller than characteristic macroscopic dimensions.</p>
            </div>
        </div>

        <h2>üìê Stress and Strain Analysis</h2>
        
        <div class="demo-grid">
            <div>
                <h3>Interactive Stress Tensor Visualization</h3>
                <div class="stress-visualization" id="stressVisualization">
                    <canvas id="stressCanvas" width="400" height="350"></canvas>
                </div>
                
                <div class="control-panel">
                    <h4>Stress Components</h4>
                    <div class="slider-container">
                        <label>Normal Stress œÉ‚ÇÅ‚ÇÅ: <span id="sigma11Value">10</span> MPa</label>
                        <input type="range" class="slider" id="sigma11" min="-50" max="50" value="10">
                    </div>
                    
                    <div class="slider-container">
                        <label>Normal Stress œÉ‚ÇÇ‚ÇÇ: <span id="sigma22Value">5</span> MPa</label>
                        <input type="range" class="slider" id="sigma22" min="-50" max="50" value="5">
                    </div>
                    
                    <div class="slider-container">
                        <label>Shear Stress œÑ‚ÇÅ‚ÇÇ: <span id="tau12Value">2</span> MPa</label>
                        <input type="range" class="slider" id="tau12" min="-25" max="25" value="2">
                    </div>
                    
                    <button class="button" onclick="resetStress()">Reset</button>
                    <button class="button" onclick="animateStress()">Animate</button>
                </div>
            </div>
            
            <div>
                <h3>Stress Tensor Matrix</h3>
                <div class="math-formula">
                    <p><strong>Cauchy Stress Tensor:</strong></p>
                    $$\boldsymbol{\sigma} = \begin{bmatrix} 
                    \sigma_{11} & \tau_{12} & \tau_{13} \\
                    \tau_{21} & \sigma_{22} & \tau_{23} \\
                    \tau_{31} & \tau_{32} & \sigma_{33}
                    \end{bmatrix}$$
                </div>
                
                <div class="tensor-matrix" id="stressTensor">
                    <div class="tensor-element" id="s11">œÉ‚ÇÅ‚ÇÅ</div>
                    <div class="tensor-element" id="s12">œÑ‚ÇÅ‚ÇÇ</div>
                    <div class="tensor-element" id="s13">œÑ‚ÇÅ‚ÇÉ</div>
                    <div class="tensor-element" id="s21">œÑ‚ÇÇ‚ÇÅ</div>
                    <div class="tensor-element" id="s22">œÉ‚ÇÇ‚ÇÇ</div>
                    <div class="tensor-element" id="s23">œÑ‚ÇÇ‚ÇÉ</div>
                    <div class="tensor-element" id="s31">œÑ‚ÇÉ‚ÇÅ</div>
                    <div class="tensor-element" id="s32">œÑ‚ÇÉ‚ÇÇ</div>
                    <div class="tensor-element" id="s33">œÉ‚ÇÉ‚ÇÉ</div>
                </div>
                
                <div class="parameter-display" id="principalStresses">
                    <strong>Principal Stresses:</strong><br>
                    œÉ‚ÇÅ = <span id="principalStress1">0</span> MPa<br>
                    œÉ‚ÇÇ = <span id="principalStress2">0</span> MPa<br>
                    Maximum Shear: <span id="maxShear">0</span> MPa
                </div>
            </div>
        </div>

        <h2>üîÑ Deformation and Strain</h2>
        
        <div class="demo-grid">
            <div>
                <h3>Deformation Gradient Visualization</h3>
                <div class="deformation-canvas">
                    <canvas id="deformationCanvas" width="400" height="300"></canvas>
                </div>
                
                <div class="control-panel">
                    <h4>Deformation Parameters</h4>
                    <div class="slider-container">
                        <label>Stretch Œª‚ÇÅ: <span id="lambda1Value">1.0</span></label>
                        <input type="range" class="slider" id="lambda1" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="slider-container">
                        <label>Stretch Œª‚ÇÇ: <span id="lambda2Value">1.0</span></label>
                        <input type="range" class="slider" id="lambda2" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="slider-container">
                        <label>Shear Œ≥: <span id="gammaValue">0.0</span></label>
                        <input type="range" class="slider" id="gamma" min="-1.0" max="1.0" step="0.1" value="0.0">
                    </div>
                    
                    <button class="button" onclick="resetDeformation()">Reset</button>
                    <button class="button" onclick="animateDeformation()">Animate</button>
                </div>
            </div>
            
            <div>
                <h3>Strain Analysis</h3>
                <div class="math-formula">
                    <p><strong>Green-Lagrange Strain Tensor:</strong></p>
                    $$\mathbf{E} = \frac{1}{2}(\mathbf{F}^T\mathbf{F} - \mathbf{I})$$
                    <p>Where <strong>F</strong> is the deformation gradient tensor and <strong>I</strong> is the identity matrix.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Small Strain Tensor:</strong></p>
                    $$\boldsymbol{\epsilon} = \frac{1}{2}(\nabla \mathbf{u} + (\nabla \mathbf{u})^T)$$
                    <p>Where <strong>u</strong> is the displacement field.</p>
                </div>
                
                <div class="parameter-display" id="strainValues">
                    <strong>Current Strain State:</strong><br>
                    Œµ‚ÇÅ‚ÇÅ = <span id="strain11">0.00</span><br>
                    Œµ‚ÇÇ‚ÇÇ = <span id="strain22">0.00</span><br>
                    Œ≥‚ÇÅ‚ÇÇ = <span id="strain12">0.00</span><br>
                    Volume Change = <span id="volumeChange">0.0</span>%
                </div>
            </div>
        </div>

        <h2>üíß Fluid Mechanics</h2>
        
        <div class="demo-grid">
            <div>
                <h3>Fluid Flow Visualization</h3>
                <div class="continuum-simulator" id="fluidSimulator">
                    <canvas id="fluidCanvas" width="400" height="400"></canvas>
                </div>
                
                <div class="control-panel">
                    <h4>Flow Parameters</h4>
                    <div class="slider-container">
                        <label>Flow Velocity: <span id="velocityValue">1.0</span> m/s</label>
                        <input type="range" class="slider" id="velocity" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="slider-container">
                        <label>Viscosity: <span id="viscosityValue">0.1</span> Pa¬∑s</label>
                        <input type="range" class="slider" id="viscosity" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    
                    <div class="slider-container">
                        <label>Reynolds Number: <span id="reynoldsValue">10</span></label>
                        <input type="range" class="slider" id="reynolds" min="1" max="1000" value="10">
                    </div>
                    
                    <button class="button" onclick="startFlowAnimation()">Start Flow</button>
                    <button class="button" onclick="pauseFlowAnimation()">Pause</button>
                    <button class="button" onclick="resetFlowField()">Reset</button>
                </div>
            </div>
            
            <div>
                <h3>Governing Equations</h3>
                
                <div class="math-formula">
                    <p><strong>Continuity Equation (Mass Conservation):</strong></p>
                    $$\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho \mathbf{v}) = 0$$
                </div>
                
                <div class="math-formula">
                    <p><strong>Navier-Stokes Equation (Momentum Conservation):</strong></p>
                    $$\rho \frac{D\mathbf{v}}{Dt} = -\nabla p + \mu \nabla^2 \mathbf{v} + \rho \mathbf{f}$$
                    <p>Where D/Dt is the material derivative, p is pressure, Œº is dynamic viscosity, and <strong>f</strong> is body force per unit mass.</p>
                </div>
                
                <div class="concept-box">
                    <h4>Reynolds Number</h4>
                    <p>The Reynolds number characterizes the ratio of inertial forces to viscous forces:</p>
                    $$Re = \frac{\rho V L}{\mu}$$
                    <p>Where V is characteristic velocity, L is characteristic length, œÅ is density, and Œº is dynamic viscosity.</p>
                </div>
                
                <div class="legend">
                    <h4>Flow Regimes</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span>Re < 2300: Laminar Flow</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ed8936;"></div>
                        <span>2300 < Re < 4000: Transitional</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e53e3e;"></div>
                        <span>Re > 4000: Turbulent Flow</span>
                    </div>
                </div>
            </div>
        </div>

        <h2>üèóÔ∏è Constitutive Relations</h2>
        
        <div class="three-column">
            <div class="concept-box">
                <h3>Linear Elasticity</h3>
                <div class="math-formula">
                    <p><strong>Hooke's Law (Generalized):</strong></p>
                    $$\boldsymbol{\sigma} = \mathbf{C} : \boldsymbol{\epsilon}$$
                    <p>Or in index notation:</p>
                    $$\sigma_{ij} = C_{ijkl} \epsilon_{kl}$$
                </div>
                
                <div class="math-formula">
                    <p><strong>Isotropic Material:</strong></p>
                    $$\sigma_{ij} = \lambda \delta_{ij} \epsilon_{kk} + 2\mu \epsilon_{ij}$$
                    <p>Where Œª and Œº are Lam√© parameters, Œ¥·µ¢‚±º is Kronecker delta.</p>
                </div>
            </div>
            
            <div class="concept-box">
                <h3>Newtonian Fluid</h3>
                <div class="math-formula">
                    <p><strong>Constitutive Relation:</strong></p>
                    $$\boldsymbol{\tau} = \mu (\nabla \mathbf{v} + (\nabla \mathbf{v})^T)$$
                    <p>Where œÑ is the deviatoric stress tensor and Œº is dynamic viscosity.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Full Stress Tensor:</strong></p>
                    $$\boldsymbol{\sigma} = -p\mathbf{I} + \boldsymbol{\tau}$$
                </div>
            </div>
            
            <div class="concept-box">
                <h3>Hyperelastic Materials</h3>
                <div class="math-formula">
                    <p><strong>Strain Energy Function:</strong></p>
                    $$W = W(\mathbf{C})$$
                    <p>Where C is the right Cauchy-Green deformation tensor.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Neo-Hookean Model:</strong></p>
                    $$W = \frac{\mu}{2}(I_1 - 3) - \mu \ln J + \frac{\lambda}{2}(\ln J)^2$$
                </div>
            </div>
        </div>

        <h2>üå°Ô∏è Thermomechanics</h2>
        
        <div class="demo-grid">
            <div>
                <h3>Heat Conduction Simulation</h3>
                <div class="continuum-simulator" id="heatSimulator">
                    <canvas id="heatCanvas" width="400" height="400"></canvas>
                </div>
                
                <div class="control-panel">
                    <h4>Thermal Parameters</h4>
                    <div class="slider-container">
                        <label>Thermal Conductivity: <span id="conductivityValue">1.0</span> W/m¬∑K</label>
                        <input type="range" class="slider" id="conductivity" min="0.1" max="5.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="slider-container">
                        <label>Heat Source: <span id="heatSourceValue">100</span> W/m¬≥</label>
                        <input type="range" class="slider" id="heatSource" min="0" max="500" value="100">
                    </div>
                    
                    <button class="button" onclick="startHeatSimulation()">Start</button>
                    <button class="button" onclick="pauseHeatSimulation()">Pause</button>
                    <button class="button" onclick="resetHeatField()">Reset</button>
                </div>
            </div>
            
            <div>
                <h3>Coupled Thermomechanical Equations</h3>
                
                <div class="math-formula">
                    <p><strong>Heat Equation:</strong></p>
                    $$\rho c_p \frac{\partial T}{\partial t} = k \nabla^2 T + Q + \sigma : \dot{\boldsymbol{\epsilon}}$$
                    <p>Where T is temperature, c‚Çö is specific heat, k is thermal conductivity, Q is heat source, and œÉ:ŒµÃá is mechanical dissipation.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Thermal Stress:</strong></p>
                    $$\boldsymbol{\sigma} = \mathbf{C} : (\boldsymbol{\epsilon} - \alpha \Delta T \mathbf{I})$$
                    <p>Where Œ± is the coefficient of thermal expansion and ŒîT is temperature change.</p>
                </div>
                
                <div class="concept-box">
                    <h4>Thermodynamic Laws</h4>
                    <p><strong>First Law:</strong> Conservation of energy including thermal and mechanical work.</p>
                    <p><strong>Second Law:</strong> Entropy production ‚â• 0, constraining constitutive relations.</p>
                </div>
            </div>
        </div>

        <h2>üî¨ Advanced Topics</h2>
        
        <div class="three-column">
            <div class="concept-box">
                <h3>Plasticity</h3>
                <p>Describes irreversible deformation in materials beyond the elastic limit.</p>
                
                <div class="math-formula">
                    <p><strong>Yield Condition:</strong></p>
                    $$f(\boldsymbol{\sigma}, \kappa) = 0$$
                    <p>Where Œ∫ represents hardening parameters.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Flow Rule:</strong></p>
                    $$\dot{\boldsymbol{\epsilon}}^p = \dot{\lambda} \frac{\partial g}{\partial \boldsymbol{\sigma}}$$
                    <p>Where g is the plastic potential function.</p>
                </div>
            </div>
            
            <div class="concept-box">
                <h3>Viscoelasticity</h3>
                <p>Materials exhibiting both viscous and elastic characteristics when deformed.</p>
                
                <div class="math-formula">
                    <p><strong>Maxwell Model:</strong></p>
                    $$\dot{\boldsymbol{\sigma}} + \frac{\boldsymbol{\sigma}}{\tau} = E \dot{\boldsymbol{\epsilon}}$$
                    <p>Where œÑ is relaxation time.</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Kelvin-Voigt Model:</strong></p>
                    $$\boldsymbol{\sigma} = E \boldsymbol{\epsilon} + \eta \dot{\boldsymbol{\epsilon}}$$
                </div>
            </div>
            
            <div class="concept-box">
                <h3>Damage Mechanics</h3>
                <p>Describes the progressive deterioration of material properties due to microcrack formation.</p>
                
                <div class="math-formula">
                    <p><strong>Effective Stress:</strong></p>
                    $$\tilde{\boldsymbol{\sigma}} = \frac{\boldsymbol{\sigma}}{1-D}$$
                    <p>Where D is the damage parameter (0 ‚â§ D ‚â§ 1).</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>Damage Evolution:</strong></p>
                    $$\dot{D} = f(\boldsymbol{\sigma}, \boldsymbol{\epsilon}, D)$$
                </div>
            </div>
        </div>

        <div class="concept-box">
            <h3>üéì Key Applications</h3>
            <ul>
                <li><strong>Structural Engineering:</strong> Analysis of buildings, bridges, and mechanical components</li>
                <li><strong>Aerospace:</strong> Aircraft and spacecraft design, considering extreme loading conditions</li>
                <li><strong>Geomechanics:</strong> Soil mechanics, rock mechanics, and earthquake engineering</li>
                <li><strong>Biomechanics:</strong> Modeling of biological tissues and organs</li>
                <li><strong>Manufacturing:</strong> Metal forming, machining, and additive manufacturing processes</li>
                <li><strong>Energy:</strong> Nuclear reactor design, oil and gas extraction, renewable energy systems</li>
                <li><strong>Materials Science:</strong> Development of new materials with tailored properties</li>
            </ul>
        </div>

        <div class="intro">
            <h3>üßÆ Mathematical Tools</h3>
            <p>Continuum mechanics relies heavily on tensor calculus, differential equations, and variational principles. The field requires understanding of:</p>
            <ul>
                <li>Tensor analysis and index notation</li>
                <li>Partial differential equations and boundary value problems</li>
                <li>Calculus of variations and energy methods</li>
                <li>Linear algebra and eigenvalue problems</li>
                <li>Vector calculus and field theory</li>
                <li>Numerical methods for solving complex problems</li>
            </ul>
        </div>
    </div>

    <script>
        // Initialize MathJax
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };

        // Global variables for animations
        let stressAnimationId;
        let deformationAnimationId;
        let fluidAnimationId;
        let heatAnimationId;
        let isFlowRunning = false;
        let isHeatRunning = false;

        // Stress visualization
        function initializeStressVisualization() {
            const canvas = document.getElementById('stressCanvas');
            const ctx = canvas.getContext('2d');
            
            drawStressVisualization(ctx, 10, 5, 2);
            updateStressTensor();
            updatePrincipalStresses();
        }

        function drawStressVisualization(ctx, sigma11, sigma22, tau12) {
            ctx.clearRect(0, 0, 400, 350);
            
            // Draw material element
            const centerX = 200, centerY = 175;
            const size = 80;
            
            // Draw deformed square
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 3;
            ctx.strokeRect(centerX - size/2, centerY - size/2, size, size);
            
            // Draw stress arrows
            const scale = 2;
            
            // Normal stresses
            drawArrow(ctx, centerX + size/2, centerY, sigma11 * scale, 0, '#ed8936', `œÉ‚ÇÅ‚ÇÅ=${sigma11}`);
            drawArrow(ctx, centerX - size/2, centerY, -sigma11 * scale, 0, '#ed8936', '');
            drawArrow(ctx, centerX, centerY - size/2, 0, -sigma22 * scale, '#f093fb', `œÉ‚ÇÇ‚ÇÇ=${sigma22}`);
            drawArrow(ctx, centerX, centerY + size/2, 0, sigma22 * scale, '#f093fb', '');
            
            // Shear stresses
            drawArrow(ctx, centerX, centerY - size/2, tau12 * scale, 0, '#48bb78', `œÑ‚ÇÅ‚ÇÇ=${tau12}`);
            drawArrow(ctx, centerX, centerY + size/2, -tau12 * scale, 0, '#48bb78', '');
            drawArrow(ctx, centerX - size/2, centerY, 0, tau12 * scale, '#48bb78', '');
            drawArrow(ctx, centerX + size/2, centerY, 0, -tau12 * scale, '#48bb78', '');
            
            // Draw coordinate system
            drawCoordinateSystem(ctx, 50, 50);
        }

        function drawArrow(ctx, x, y, dx, dy, color, label) {
            if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(dy, dx);
            const headLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLength * Math.cos(angle - Math.PI/6), 
                      y + dy - headLength * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLength * Math.cos(angle + Math.PI/6), 
                      y + dy - headLength * Math.sin(angle + Math.PI/6));
            ctx.stroke();
            
            // Label
            if (label) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText(label, x + dx + 15, y + dy + 5);
            }
        }

        function drawCoordinateSystem(ctx, x, y) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 30, y);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - 30);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.fillText('x‚ÇÅ', x + 35, y + 5);
            ctx.fillText('x‚ÇÇ', x - 5, y - 35);
        }

        function updateStressTensor() {
            const sigma11 = parseFloat(document.getElementById('sigma11').value);
            const sigma22 = parseFloat(document.getElementById('sigma22').value);
            const tau12 = parseFloat(document.getElementById('tau12').value);
            
            document.getElementById('s11').textContent = sigma11.toFixed(1);
            document.getElementById('s22').textContent = sigma22.toFixed(1);
            document.getElementById('s12').textContent = tau12.toFixed(1);
            document.getElementById('s21').textContent = tau12.toFixed(1);
            document.getElementById('s13').textContent = '0.0';
            document.getElementById('s23').textContent = '0.0';
            document.getElementById('s31').textContent = '0.0';
            document.getElementById('s32').textContent = '0.0';
            document.getElementById('s33').textContent = '0.0';
        }

        function updatePrincipalStresses() {
            const sigma11 = parseFloat(document.getElementById('sigma11').value);
            const sigma22 = parseFloat(document.getElementById('sigma22').value);
            const tau12 = parseFloat(document.getElementById('tau12').value);
            
            // Calculate principal stresses
            const sigmaAvg = (sigma11 + sigma22) / 2;
            const radius = Math.sqrt(Math.pow((sigma11 - sigma22) / 2, 2) + Math.pow(tau12, 2));
            
            const sigma1 = sigmaAvg + radius;
            const sigma2 = sigmaAvg - radius;
            const maxShear = radius;
            
            document.getElementById('principalStress1').textContent = sigma1.toFixed(2);
            document.getElementById('principalStress2').textContent = sigma2.toFixed(2);
            document.getElementById('maxShear').textContent = maxShear.toFixed(2);
        }

        // Deformation visualization
        function initializeDeformationVisualization() {
            const canvas = document.getElementById('deformationCanvas');
            const ctx = canvas.getContext('2d');
            
            drawDeformationGrid(ctx, 1.0, 1.0, 0.0);
            updateStrainValues();
        }

        function drawDeformationGrid(ctx, lambda1, lambda2, gamma) {
            ctx.clearRect(0, 0, 400, 300);
            
            const gridSize = 20;
            const offsetX = 100;
            const offsetY = 50;
            
            // Original grid (light blue)
            ctx.strokeStyle = 'rgba(99, 179, 237, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(offsetX + i * gridSize, offsetY);
                ctx.lineTo(offsetX + i * gridSize, offsetY + 10 * gridSize);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + i * gridSize);
                ctx.lineTo(offsetX + 10 * gridSize, offsetY + i * gridSize);
                ctx.stroke();
            }
            
            // Deformed grid (orange)
            ctx.strokeStyle = '#ed8936';
            ctx.lineWidth = 2;
            
            for (let i = 0; i <= 10; i++) {
                for (let j = 0; j <= 10; j++) {
                    const x = i * gridSize;
                    const y = j * gridSize;
                    
                    // Apply deformation
                    const newX = lambda1 * x + gamma * y;
                    const newY = lambda2 * y;
                    
                    if (i < 10) {
                        const nextX = (i + 1) * gridSize;
                        const nextNewX = lambda1 * nextX + gamma * y;
                        const nextNewY = lambda2 * y;
                        
                        ctx.beginPath();
                        ctx.moveTo(offsetX + newX, offsetY + newY);
                        ctx.lineTo(offsetX + nextNewX, offsetY + nextNewY);
                        ctx.stroke();
                    }
                    
                    if (j < 10) {
                        const nextY = (j + 1) * gridSize;
                        const nextNewX = lambda1 * x + gamma * nextY;
                        const nextNewY = lambda2 * nextY;
                        
                        ctx.beginPath();
                        ctx.moveTo(offsetX + newX, offsetY + newY);
                        ctx.lineTo(offsetX + nextNewX, offsetY + nextNewY);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw legend
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('Original Grid', 20, 280);
            ctx.strokeStyle = 'rgba(99, 179, 237, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(5, 275);
            ctx.lineTo(15, 275);
            ctx.stroke();
            
            ctx.fillText('Deformed Grid', 120, 280);
            ctx.strokeStyle = '#ed8936';
            ctx.beginPath();
            ctx.moveTo(105, 275);
            ctx.lineTo(115, 275);
            ctx.stroke();
        }

        function updateStrainValues() {
            const lambda1 = parseFloat(document.getElementById('lambda1').value);
            const lambda2 = parseFloat(document.getElementById('lambda2').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            
            // Calculate strains (small strain approximation)
            const epsilon11 = lambda1 - 1;
            const epsilon22 = lambda2 - 1;
            const gamma12 = gamma;
            const volumeChange = ((lambda1 * lambda2) - 1) * 100;
            
            document.getElementById('strain11').textContent = epsilon11.toFixed(3);
            document.getElementById('strain22').textContent = epsilon22.toFixed(3);
            document.getElementById('strain12').textContent = gamma12.toFixed(3);
            document.getElementById('volumeChange').textContent = volumeChange.toFixed(1);
        }

        // Fluid flow visualization
        function initializeFluidVisualization() {
            const canvas = document.getElementById('fluidCanvas');
            const ctx = canvas.getContext('2d');
            
            drawFluidField(ctx);
        }

        function drawFluidField(ctx) {
            ctx.clearRect(0, 0, 400, 400);
            
            const velocity = parseFloat(document.getElementById('velocity').value);
            const viscosity = parseFloat(document.getElementById('viscosity').value);
            
            // Draw streamlines
            ctx.strokeStyle = '#48bb78';
            ctx.lineWidth = 1;
            
            for (let y = 50; y < 350; y += 30) {
                ctx.beginPath();
                ctx.moveTo(20, y);
                
                for (let x = 20; x < 380; x += 10) {
                    const streamY = y + 10 * Math.sin(x * 0.02) * velocity;
                    ctx.lineTo(x, streamY);
                }
                ctx.stroke();
            }
            
            // Draw velocity vectors
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            
            for (let x = 50; x < 350; x += 50) {
                for (let y = 50; y < 350; y += 50) {
                    const vx = velocity * 10;
                    const vy = velocity * 5 * Math.sin(x * 0.02);
                    
                    drawArrow(ctx, x, y, vx, vy, '#63b3ed', '');
                }
            }
            
            // Draw obstacle (cylinder)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(200, 200, 30, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Heat conduction visualization
        function initializeHeatVisualization() {
            const canvas = document.getElementById('heatCanvas');
            const ctx = canvas.getContext('2d');
            
            drawHeatField(ctx);
        }

        function drawHeatField(ctx) {
            ctx.clearRect(0, 0, 400, 400);
            
            const conductivity = parseFloat(document.getElementById('conductivity').value);
            const heatSource = parseFloat(document.getElementById('heatSource').value);
            
            // Create temperature field visualization
            const imageData = ctx.createImageData(400, 400);
            const data = imageData.data;
            
            for (let x = 0; x < 400; x++) {
                for (let y = 0; y < 400; y++) {
                    const centerX = 200, centerY = 200;
                    const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    
                    // Temperature distribution (heat source at center)
                    const temperature = Math.max(0, 1 - distance / 200) * heatSource / 100;
                    
                    const pixelIndex = (y * 400 + x) * 4;
                    
                    // Color mapping: blue (cold) to red (hot)
                    data[pixelIndex] = Math.min(255, temperature * 255);     // Red
                    data[pixelIndex + 1] = Math.max(0, 255 - temperature * 255); // Green
                    data[pixelIndex + 2] = Math.max(0, 255 - temperature * 255); // Blue
                    data[pixelIndex + 3] = 100; // Alpha
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Draw isotherms
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            
            for (let radius = 50; radius < 200; radius += 30) {
                ctx.beginPath();
                ctx.arc(200, 200, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw heat flux vectors
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            
            for (let x = 50; x < 350; x += 40) {
                for (let y = 50; y < 350; y += 40) {
                    const dx = x - 200;
                    const dy = y - 200;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distance > 10) {
                        const fluxX = -conductivity * dx / distance * 20;
                        const fluxY = -conductivity * dy / distance * 20;
                        
                        drawArrow(ctx, x, y, fluxX, fluxY, '#ffff00', '');
                    }
                }
            }
        }

        // Event listeners for sliders
        document.getElementById('sigma11').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('sigma11Value').textContent = value;
            const canvas = document.getElementById('stressCanvas');
            const ctx = canvas.getContext('2d');
            const sigma22 = parseFloat(document.getElementById('sigma22').value);
            const tau12 = parseFloat(document.getElementById('tau12').value);
            drawStressVisualization(ctx, parseFloat(value), sigma22, tau12);
            updateStressTensor();
            updatePrincipalStresses();
        });

        document.getElementById('sigma22').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('sigma22Value').textContent = value;
            const canvas = document.getElementById('stressCanvas');
            const ctx = canvas.getContext('2d');
            const sigma11 = parseFloat(document.getElementById('sigma11').value);
            const tau12 = parseFloat(document.getElementById('tau12').value);
            drawStressVisualization(ctx, sigma11, parseFloat(value), tau12);
            updateStressTensor();
            updatePrincipalStresses();
        });

        document.getElementById('tau12').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('tau12Value').textContent = value;
            const canvas = document.getElementById('stressCanvas');
            const ctx = canvas.getContext('2d');
            const sigma11 = parseFloat(document.getElementById('sigma11').value);
            const sigma22 = parseFloat(document.getElementById('sigma22').value);
            drawStressVisualization(ctx, sigma11, sigma22, parseFloat(value));
            updateStressTensor();
            updatePrincipalStresses();
        });

        document.getElementById('lambda1').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('lambda1Value').textContent = value;
            const canvas = document.getElementById('deformationCanvas');
            const ctx = canvas.getContext('2d');
            const lambda2 = parseFloat(document.getElementById('lambda2').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            drawDeformationGrid(ctx, parseFloat(value), lambda2, gamma);
            updateStrainValues();
        });

        document.getElementById('lambda2').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('lambda2Value').textContent = value;
            const canvas = document.getElementById('deformationCanvas');
            const ctx = canvas.getContext('2d');
            const lambda1 = parseFloat(document.getElementById('lambda1').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            drawDeformationGrid(ctx, lambda1, parseFloat(value), gamma);
            updateStrainValues();
        });

        document.getElementById('gamma').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('gammaValue').textContent = value;
            const canvas = document.getElementById('deformationCanvas');
            const ctx = canvas.getContext('2d');
            const lambda1 = parseFloat(document.getElementById('lambda1').value);
            const lambda2 = parseFloat(document.getElementById('lambda2').value);
            drawDeformationGrid(ctx, lambda1, lambda2, parseFloat(value));
            updateStrainValues();
        });

        document.getElementById('velocity').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('velocityValue').textContent = value;
            if (isFlowRunning) {
                const canvas = document.getElementById('fluidCanvas');
                const ctx = canvas.getContext('2d');
                drawFluidField(ctx);
            }
        });

        document.getElementById('viscosity').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('viscosityValue').textContent = value;
            updateReynoldsNumber();
        });

        document.getElementById('reynolds').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('reynoldsValue').textContent = value;
        });

        document.getElementById('conductivity').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('conductivityValue').textContent = value;
            if (isHeatRunning) {
                const canvas = document.getElementById('heatCanvas');
                const ctx = canvas.getContext('2d');
                drawHeatField(ctx);
            }
        });

        document.getElementById('heatSource').addEventListener('input', function() {
            const value = this.value;
            document.getElementById('heatSourceValue').textContent = value;
            if (isHeatRunning) {
                const canvas = document.getElementById('heatCanvas');
                const ctx = canvas.getContext('2d');
                drawHeatField(ctx);
            }
        });

        // Control functions
        function resetStress() {
            document.getElementById('sigma11').value = 10;
            document.getElementById('sigma22').value = 5;
            document.getElementById('tau12').value = 2;
            document.getElementById('sigma11Value').textContent = '10';
            document.getElementById('sigma22Value').textContent = '5';
            document.getElementById('tau12Value').textContent = '2';
            
            const canvas = document.getElementById('stressCanvas');
            const ctx = canvas.getContext('2d');
            drawStressVisualization(ctx, 10, 5, 2);
            updateStressTensor();
            updatePrincipalStresses();
        }

        function animateStress() {
            let time = 0;
            stressAnimationId = setInterval(() => {
                const sigma11 = 10 + 20 * Math.sin(time * 0.05);
                const sigma22 = 5 + 15 * Math.sin(time * 0.03);
                const tau12 = 2 + 10 * Math.sin(time * 0.07);
                
                document.getElementById('sigma11').value = sigma11;
                document.getElementById('sigma22').value = sigma22;
                document.getElementById('tau12').value = tau12;
                document.getElementById('sigma11Value').textContent = sigma11.toFixed(1);
                document.getElementById('sigma22Value').textContent = sigma22.toFixed(1);
                document.getElementById('tau12Value').textContent = tau12.toFixed(1);
                
                const canvas = document.getElementById('stressCanvas');
                const ctx = canvas.getContext('2d');
                drawStressVisualization(ctx, sigma11, sigma22, tau12);
                updateStressTensor();
                updatePrincipalStresses();
                
                time++;
                if (time > 200) {
                    clearInterval(stressAnimationId);
                }
            }, 100);
        }

        function resetDeformation() {
            document.getElementById('lambda1').value = 1.0;
            document.getElementById('lambda2').value = 1.0;
            document.getElementById('gamma').value = 0.0;
            document.getElementById('lambda1Value').textContent = '1.0';
            document.getElementById('lambda2Value').textContent = '1.0';
            document.getElementById('gammaValue').textContent = '0.0';
            
            const canvas = document.getElementById('deformationCanvas');
            const ctx = canvas.getContext('2d');
            drawDeformationGrid(ctx, 1.0, 1.0, 0.0);
            updateStrainValues();
        }

        function animateDeformation() {
            let time = 0;
            deformationAnimationId = setInterval(() => {
                const lambda1 = 1.0 + 0.5 * Math.sin(time * 0.05);
                const lambda2 = 1.0 + 0.3 * Math.sin(time * 0.03);
                const gamma = 0.5 * Math.sin(time * 0.07);
                
                document.getElementById('lambda1').value = lambda1;
                document.getElementById('lambda2').value = lambda2;
                document.getElementById('gamma').value = gamma;
                document.getElementById('lambda1Value').textContent = lambda1.toFixed(2);
                document.getElementById('lambda2Value').textContent = lambda2.toFixed(2);
                document.getElementById('gammaValue').textContent = gamma.toFixed(2);
                
                const canvas = document.getElementById('deformationCanvas');
                const ctx = canvas.getContext('2d');
                drawDeformationGrid(ctx, lambda1, lambda2, gamma);
                updateStrainValues();
                
                time++;
                if (time > 200) {
                    clearInterval(deformationAnimationId);
                }
            }, 100);
        }

        function startFlowAnimation() {
            isFlowRunning = true;
            fluidAnimationId = setInterval(() => {
                const canvas = document.getElementById('fluidCanvas');
                const ctx = canvas.getContext('2d');
                drawFluidField(ctx);
            }, 100);
        }

        function pauseFlowAnimation() {
            isFlowRunning = false;
            clearInterval(fluidAnimationId);
        }

        function resetFlowField() {
            pauseFlowAnimation();
            document.getElementById('velocity').value = 1.0;
            document.getElementById('viscosity').value = 0.1;
            document.getElementById('reynolds').value = 10;
            document.getElementById('velocityValue').textContent = '1.0';
            document.getElementById('viscosityValue').textContent = '0.1';
            document.getElementById('reynoldsValue').textContent = '10';
            
            const canvas = document.getElementById('fluidCanvas');
            const ctx = canvas.getContext('2d');
            drawFluidField(ctx);
        }

        function startHeatSimulation() {
            isHeatRunning = true;
            heatAnimationId = setInterval(() => {
                const canvas = document.getElementById('heatCanvas');
                const ctx = canvas.getContext('2d');
                drawHeatField(ctx);
            }, 200);
        }

        function pauseHeatSimulation() {
            isHeatRunning = false;
            clearInterval(heatAnimationId);
        }

        function resetHeatField() {
            pauseHeatSimulation();
            document.getElementById('conductivity').value = 1.0;
            document.getElementById('heatSource').value = 100;
            document.getElementById('conductivityValue').textContent = '1.0';
            document.getElementById('heatSourceValue').textContent = '100';
            
            const canvas = document.getElementById('heatCanvas');
            const ctx = canvas.getContext('2d');
            drawHeatField(ctx);
        }

        function updateReynoldsNumber() {
            const velocity = parseFloat(document.getElementById('velocity').value);
            const viscosity = parseFloat(document.getElementById('viscosity').value);
            const density = 1000; // kg/m¬≥ (water)
            const length = 0.1; // m (characteristic length)
            
            const reynolds = (density * velocity * length) / (viscosity * 1000);
            document.getElementById('reynolds').value = Math.round(reynolds);
            document.getElementById('reynoldsValue').textContent = Math.round(reynolds);
        }

        // Initialize all visualizations when page loads
        window.addEventListener('load', function() {
            setTimeout(() => {
                initializeStressVisualization();
                initializeDeformationVisualization();
                initializeFluidVisualization();
                initializeHeatVisualization();
            }, 1000);
        });
    </script>
</body>
</html>
