<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Kinematics & Dynamics - Interactive Physics</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 50%, #4a5568 100%);
            color: #ffffff;
            min-height: 100vh;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #63b3ed;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .intro {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #63b3ed;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }
        
        .demo-box {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(99, 179, 237, 0.3);
        }
        
        .demo-box h3 {
            color: #63b3ed;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls {
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .controls label {
            color: #e2e8f0;
            margin-right: 5px;
        }
        
        .controls input, .controls select {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }
        
        .controls button {
            padding: 8px 15px;
            background: linear-gradient(45deg, #4299e1, #63b3ed);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        .controls button:hover {
            transform: scale(1.05);
        }
        
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            position: relative;
        }
        
        canvas {
            border: 2px solid #63b3ed;
            border-radius: 8px;
            width: 100%;
            height: 300px;
            display: block;
        }
        
        .visualization-container {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .info-panel {
            background: rgba(99, 179, 237, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #63b3ed;
        }
        
        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #63b3ed;
            font-family: 'Courier New', monospace;
        }
        
        .particle {
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 10px #ff6b6b;
        }
        
        .trail {
            stroke: #ff6b6b;
            stroke-width: 2;
            fill: none;
            opacity: 0.6;
        }
        
        .vector {
            stroke: #4ecdc4;
            stroke-width: 3;
            marker-end: url(#arrowhead);
        }
        
        .phase-space-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .status-display {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .math-explanation {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }
        
        .exercise-box {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Kinematics & Dynamics</h1>
        
        <div class="intro">
            <h2>Understanding Motion and Forces</h2>
            <p>Explore the fundamental principles of mechanics through interactive simulations. Kinematics describes motion without considering causes, while dynamics examines the forces that produce motion.</p>
            
            <div class="equation-box">
                <strong>Key Equations:</strong><br>
                Position: \(x(t) = x_0 + v_0 t + \frac{1}{2}a t^2\)<br>
                Velocity: \(v(t) = v_0 + at\)<br>
                Newton's Second Law: \(F = ma\)<br>
                Kinetic Energy: \(KE = \frac{1}{2}mv^2\)
            </div>
        </div>

        <div class="demo-grid">
            <!-- 1D Motion Simulation -->
            <div class="demo-box">
                <h3>üèÉ‚Äç‚ôÇÔ∏è 1D Motion Simulator</h3>
                <div class="controls">
                    <label>Initial Velocity:</label>
                    <input type="range" id="v0-1d" min="-50" max="50" value="20" step="1">
                    <span id="v0-1d-val">20</span> m/s
                    <br>
                    <label>Acceleration:</label>
                    <input type="range" id="a-1d" min="-20" max="20" value="-9.8" step="0.1">
                    <span id="a-1d-val">-9.8</span> m/s¬≤
                    <br>
                    <button onclick="resetMotion1D()">Reset</button>
                    <button onclick="togglePlay1D()" id="play-btn-1d">Play</button>
                </div>
                <div class="canvas-container">
                    <canvas id="motion1d" width="400" height="200"></canvas>
                </div>
                <div class="status-display" id="status-1d">
                    Position: 0 m | Velocity: 20 m/s | Time: 0 s
                </div>
            </div>

            <!-- Projectile Motion -->
            <div class="demo-box">
                <h3>üéØ Projectile Motion</h3>
                <div class="controls">
                    <label>Launch Angle:</label>
                    <input type="range" id="angle" min="0" max="90" value="45" step="1">
                    <span id="angle-val">45</span>¬∞
                    <br>
                    <label>Launch Speed:</label>
                    <input type="range" id="speed" min="10" max="100" value="50" step="1">
                    <span id="speed-val">50</span> m/s
                    <br>
                    <button onclick="launchProjectile()">Launch</button>
                    <button onclick="resetProjectile()">Reset</button>
                </div>
                <div class="canvas-container">
                    <canvas id="projectile" width="400" height="300"></canvas>
                </div>
                <div class="status-display" id="status-projectile">
                    Range: 0 m | Max Height: 0 m | Flight Time: 0 s
                </div>
            </div>

            <!-- Force and Acceleration -->
            <div class="demo-box">
                <h3>‚ö° Force & Acceleration</h3>
                <div class="controls">
                    <label>Mass:</label>
                    <input type="range" id="mass" min="1" max="20" value="5" step="0.5">
                    <span id="mass-val">5</span> kg
                    <br>
                    <label>Applied Force:</label>
                    <input type="range" id="force" min="0" max="100" value="25" step="1">
                    <span id="force-val">25</span> N
                    <br>
                    <label>Friction:</label>
                    <input type="range" id="friction" min="0" max="0.5" value="0.1" step="0.01">
                    <span id="friction-val">0.1</span>
                    <br>
                    <button onclick="applyForce()">Apply Force</button>
                    <button onclick="resetForce()">Reset</button>
                </div>
                <div class="canvas-container">
                    <canvas id="force-demo" width="400" height="200"></canvas>
                </div>
                <div class="status-display" id="status-force">
                    Acceleration: 0 m/s¬≤ | Net Force: 0 N
                </div>
            </div>

            <!-- Oscillatory Motion -->
            <div class="demo-box">
                <h3>üåä Simple Harmonic Motion</h3>
                <div class="controls">
                    <label>Amplitude:</label>
                    <input type="range" id="amplitude" min="10" max="100" value="50" step="5">
                    <span id="amplitude-val">50</span> pixels
                    <br>
                    <label>Frequency:</label>
                    <input type="range" id="frequency" min="0.1" max="3" value="1" step="0.1">
                    <span id="frequency-val">1</span> Hz
                    <br>
                    <button onclick="toggleOscillation()" id="osc-btn">Start</button>
                    <button onclick="resetOscillation()">Reset</button>
                </div>
                <div class="canvas-container">
                    <canvas id="oscillation" width="400" height="300"></canvas>
                </div>
                <div class="status-display" id="status-osc">
                    Position: 0 | Velocity: 0 | Energy: 0
                </div>
            </div>
        </div>

        <!-- Phase Space Visualization -->
        <div class="visualization-container">
            <h3>üìä Phase Space Analysis</h3>
            <p>Phase space plots show the relationship between position and velocity (or momentum) for dynamic systems.</p>
            
            <div class="phase-space-grid">
                <div>
                    <h4>Simple Harmonic Oscillator</h4>
                    <canvas id="phase-sho" width="300" height="300"></canvas>
                </div>
                <div>
                    <h4>Damped Oscillator</h4>
                    <canvas id="phase-damped" width="300" height="300"></canvas>
                </div>
            </div>
            
            <div class="math-explanation">
                <h4>Mathematical Foundation</h4>
                <p>For a simple harmonic oscillator: \(x(t) = A\cos(\omega t + \phi)\)</p>
                <p>The phase space trajectory is an ellipse: \(\frac{x^2}{A^2} + \frac{v^2}{A^2\omega^2} = 1\)</p>
                <p>For a damped oscillator: \(m\ddot{x} + b\dot{x} + kx = 0\)</p>
            </div>
        </div>

        <!-- Energy Conservation -->
        <div class="visualization-container">
            <h3>‚ö° Energy in Motion</h3>
            <div class="controls">
                <label>System Type:</label>
                <select id="energy-system">
                    <option value="pendulum">Pendulum</option>
                    <option value="spring">Spring-Mass</option>
                    <option value="projectile">Projectile</option>
                </select>
                <button onclick="startEnergyDemo()" id="energy-btn">Start</button>
                <button onclick="resetEnergyDemo()">Reset</button>
            </div>
            
            <div class="demo-grid">
                <div class="canvas-container">
                    <canvas id="energy-motion" width="400" height="300"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="energy-chart" width="400" height="300"></canvas>
                </div>
            </div>
            
            <div class="info-panel" id="energy-info">
                <strong>Energy Conservation:</strong> Total mechanical energy remains constant in conservative systems.
                <br><strong>Kinetic Energy:</strong> <span id="ke-val">0</span> J
                <br><strong>Potential Energy:</strong> <span id="pe-val">0</span> J
                <br><strong>Total Energy:</strong> <span id="te-val">0</span> J
            </div>
        </div>

        <!-- Interactive Exercises -->
        <div class="exercise-box">
            <h3>üéì Interactive Exercises</h3>
            
            <div class="demo-grid">
                <div>
                    <h4>Exercise 1: Projectile Range</h4>
                    <p>Find the angle that maximizes range for a given initial speed.</p>
                    <div class="controls">
                        <label>Your Prediction:</label>
                        <input type="number" id="angle-guess" min="0" max="90" placeholder="degrees">
                        <button onclick="checkAnglePrediction()">Check</button>
                    </div>
                    <div id="angle-result"></div>
                </div>
                
                <div>
                    <h4>Exercise 2: Force Calculation</h4>
                    <p>A 10 kg object accelerates at 5 m/s¬≤. What force is applied?</p>
                    <div class="controls">
                        <label>Your Answer:</label>
                        <input type="number" id="force-guess" placeholder="Newtons">
                        <button onclick="checkForceCalculation()">Check</button>
                    </div>
                    <div id="force-result"></div>
                </div>
            </div>
        </div>

        <div class="math-explanation">
            <h3>üßÆ Mathematical Foundations</h3>
            <h4>Kinematic Equations</h4>
            <p>For constant acceleration:</p>
            <ul>
                <li>\(v = v_0 + at\)</li>
                <li>\(x = x_0 + v_0 t + \frac{1}{2}at^2\)</li>
                <li>\(v^2 = v_0^2 + 2a(x - x_0)\)</li>
                <li>\(x = x_0 + \frac{v_0 + v}{2}t\)</li>
            </ul>
            
            <h4>Newton's Laws</h4>
            <ul>
                <li><strong>First Law:</strong> Objects in motion stay in motion unless acted upon by a force</li>
                <li><strong>Second Law:</strong> \(F = ma\) (Force equals mass times acceleration)</li>
                <li><strong>Third Law:</strong> For every action, there is an equal and opposite reaction</li>
            </ul>
            
            <h4>Energy Relations</h4>
            <ul>
                <li><strong>Kinetic Energy:</strong> \(KE = \frac{1}{2}mv^2\)</li>
                <li><strong>Gravitational PE:</strong> \(PE = mgh\)</li>
                <li><strong>Spring PE:</strong> \(PE = \frac{1}{2}kx^2\)</li>
                <li><strong>Work-Energy Theorem:</strong> \(W = \Delta KE\)</li>
            </ul>
        </div>
    </div>

    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            }
        };

        // Global variables for animations
        let animations = {
            motion1d: null,
            projectile: null,
            force: null,
            oscillation: null,
            energy: null
        };

        let state = {
            motion1d: { x: 0, v: 20, t: 0, playing: false },
            projectile: { x: 0, y: 0, vx: 0, vy: 0, t: 0, launched: false },
            force: { x: 0, v: 0, a: 0, applied: false },
            oscillation: { t: 0, playing: false },
            energy: { t: 0, playing: false, system: 'pendulum' }
        };

        // Initialize all demos
        function init() {
            setupCanvas();
            setupEventListeners();
            drawInitialStates();
            initPhaseSpace();
        }

        function setupCanvas() {
            // Set up all canvas contexts
            window.ctx1d = document.getElementById('motion1d').getContext('2d');
            window.ctxProj = document.getElementById('projectile').getContext('2d');
            window.ctxForce = document.getElementById('force-demo').getContext('2d');
            window.ctxOsc = document.getElementById('oscillation').getContext('2d');
            window.ctxPhaseSHO = document.getElementById('phase-sho').getContext('2d');
            window.ctxPhaseDamped = document.getElementById('phase-damped').getContext('2d');
            window.ctxEnergyMotion = document.getElementById('energy-motion').getContext('2d');
            window.ctxEnergyChart = document.getElementById('energy-chart').getContext('2d');
        }

        function setupEventListeners() {
            // 1D Motion controls
            document.getElementById('v0-1d').addEventListener('input', function() {
                document.getElementById('v0-1d-val').textContent = this.value;
                state.motion1d.v = parseFloat(this.value);
            });

            document.getElementById('a-1d').addEventListener('input', function() {
                document.getElementById('a-1d-val').textContent = this.value;
            });

            // Projectile controls
            document.getElementById('angle').addEventListener('input', function() {
                document.getElementById('angle-val').textContent = this.value;
            });

            document.getElementById('speed').addEventListener('input', function() {
                document.getElementById('speed-val').textContent = this.value;
            });

            // Force controls
            document.getElementById('mass').addEventListener('input', function() {
                document.getElementById('mass-val').textContent = this.value;
            });

            document.getElementById('force').addEventListener('input', function() {
                document.getElementById('force-val').textContent = this.value;
            });

            document.getElementById('friction').addEventListener('input', function() {
                document.getElementById('friction-val').textContent = this.value;
            });

            // Oscillation controls
            document.getElementById('amplitude').addEventListener('input', function() {
                document.getElementById('amplitude-val').textContent = this.value;
            });

            document.getElementById('frequency').addEventListener('input', function() {
                document.getElementById('frequency-val').textContent = this.value;
            });
        }

        function drawInitialStates() {
            draw1DMotion();
            drawProjectile();
            drawForceDemo();
            drawOscillation();
            drawEnergyDemo();
        }

        // 1D Motion Functions
        function resetMotion1D() {
            state.motion1d = { x: 0, v: parseFloat(document.getElementById('v0-1d').value), t: 0, playing: false };
            if (animations.motion1d) {
                cancelAnimationFrame(animations.motion1d);
                animations.motion1d = null;
            }
            document.getElementById('play-btn-1d').textContent = 'Play';
            draw1DMotion();
        }

        function togglePlay1D() {
            if (state.motion1d.playing) {
                cancelAnimationFrame(animations.motion1d);
                animations.motion1d = null;
                state.motion1d.playing = false;
                document.getElementById('play-btn-1d').textContent = 'Play';
            } else {
                state.motion1d.playing = true;
                document.getElementById('play-btn-1d').textContent = 'Pause';
                animate1DMotion();
            }
        }

        function animate1DMotion() {
            if (!state.motion1d.playing) return;

            const dt = 0.02;
            const a = parseFloat(document.getElementById('a-1d').value);
            
            state.motion1d.x += state.motion1d.v * dt + 0.5 * a * dt * dt;
            state.motion1d.v += a * dt;
            state.motion1d.t += dt;

            draw1DMotion();
            updateStatus1D();

            // Stop if object goes out of bounds
            if (state.motion1d.x > 400 || state.motion1d.x < -50) {
                togglePlay1D();
                return;
            }

            animations.motion1d = requestAnimationFrame(animate1DMotion);
        }

        function draw1DMotion() {
            const canvas = document.getElementById('motion1d');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 150);
            ctx.lineTo(canvas.width, 150);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = 'rgba(99, 179, 237, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }

            // Draw object
            const x = 50 + state.motion1d.x * 0.8; // Scale for canvas
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(x, 140, 8, 0, 2 * Math.PI);
            ctx.fill();

            // Draw velocity vector
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, 140);
            ctx.lineTo(x + state.motion1d.v * 2, 140);
            ctx.stroke();

            // Draw arrow head
            const vx = state.motion1d.v * 2;
            if (Math.abs(vx) > 5) {
                ctx.beginPath();
                ctx.moveTo(x + vx, 140);
                ctx.lineTo(x + vx - 8 * Math.sign(vx), 135);
                ctx.lineTo(x + vx - 8 * Math.sign(vx), 145);
                ctx.closePath();
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();
            }
        }

        function updateStatus1D() {
            document.getElementById('status-1d').textContent = 
                `Position: ${state.motion1d.x.toFixed(1)} m | Velocity: ${state.motion1d.v.toFixed(1)} m/s | Time: ${state.motion1d.t.toFixed(1)} s`;
        }

        // Projectile Motion Functions
        function launchProjectile() {
            const angle = parseFloat(document.getElementById('angle').value) * Math.PI / 180;
            const speed = parseFloat(document.getElementById('speed').value);
            
            state.projectile = {
                x: 0, y: 0,
                vx: speed * Math.cos(angle),
                vy: speed * Math.sin(angle),
                t: 0,
                launched: true,
                trail: []
            };

            animateProjectile();
        }

        function resetProjectile() {
            state.projectile = { x: 0, y: 0, vx: 0, vy: 0, t: 0, launched: false, trail: [] };
            if (animations.projectile) {
                cancelAnimationFrame(animations.projectile);
                animations.projectile = null;
            }
            drawProjectile();
        }

        function animateProjectile() {
            if (!state.projectile.launched) return;

            const dt = 0.02;
            const g = 9.8;

            state.projectile.x += state.projectile.vx * dt;
            state.projectile.y += state.projectile.vy * dt;
            state.projectile.vy -= g * dt;
            state.projectile.t += dt;

            // Add to trail
            state.projectile.trail.push({x: state.projectile.x, y: state.projectile.y});
            if (state.projectile.trail.length > 100) {
                state.projectile.trail.shift();
            }

            drawProjectile();
            updateProjectileStatus();

            // Stop if hits ground
            if (state.projectile.y <= 0 && state.projectile.t > 0.1) {
                state.projectile.launched = false;
                return;
            }

            animations.projectile = requestAnimationFrame(animateProjectile);
        }

        function drawProjectile() {
            const canvas = document.getElementById('projectile');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = 'rgba(99, 179, 237, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // Draw trail
            if (state.projectile.trail.length > 1) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < state.projectile.trail.length; i++) {
                    const point = state.projectile.trail[i];
                    const x = 20 + point.x * 3;
                    const y = canvas.height - 20 - point.y * 3;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // Draw projectile
            if (state.projectile.launched || state.projectile.t === 0) {
                const x = 20 + state.projectile.x * 3;
                const y = canvas.height - 20 - state.projectile.y * 3;
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Draw velocity vector
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + state.projectile.vx * 2, y - state.projectile.vy * 2);
                ctx.stroke();
            }
        }

        function updateProjectileStatus() {
            const range = state.projectile.x;
            const maxHeight = Math.max(...state.projectile.trail.map(p => p.y));
            const flightTime = state.projectile.t;
            
            document.getElementById('status-projectile').textContent = 
                `Range: ${range.toFixed(1)} m | Max Height: ${maxHeight.toFixed(1)} m | Flight Time: ${flightTime.toFixed(1)} s`;
        }

        // Force and Acceleration Functions
        function applyForce() {
            const mass = parseFloat(document.getElementById('mass').value);
            const force = parseFloat(document.getElementById('force').value);
            const friction = parseFloat(document.getElementById('friction').value);
            
            const g = 9.8;
            const normalForce = mass * g;
            const frictionForce = friction * normalForce;
            const netForce = force - frictionForce;
            
            state.force.a = netForce / mass;
            state.force.applied = true;
            
            animateForce();
        }

        function resetForce() {
            state.force = { x: 0, v: 0, a: 0, applied: false };
            if (animations.force) {
                cancelAnimationFrame(animations.force);
                animations.force = null;
            }
            drawForceDemo();
        }

        function animateForce() {
            if (!state.force.applied) return;

            const dt = 0.02;
            
            state.force.v += state.force.a * dt;
            state.force.x += state.force.v * dt;

            drawForceDemo();
            updateForceStatus();

            if (state.force.x > 300 || state.force.x < -50) {
                state.force.applied = false;
                return;
            }

            animations.force = requestAnimationFrame(animateForce);
        }

        function drawForceDemo() {
            const canvas = document.getElementById('force-demo');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw surface
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 150);
            ctx.lineTo(canvas.width, 150);
            ctx.stroke();

            // Draw object
            const x = 50 + state.force.x;
            const mass = parseFloat(document.getElementById('mass').value);
            const size = Math.sqrt(mass) * 3 + 5;
            
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(x - size/2, 150 - size, size, size);

            // Draw applied force vector
            const force = parseFloat(document.getElementById('force').value);
            if (force > 0) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - size/2 - 10, 150 - size/2);
                ctx.lineTo(x - size/2 - 10 - force * 2, 150 - size/2);
                ctx.stroke();
                
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(x - size/2 - 10 - force * 2, 150 - size/2);
                ctx.lineTo(x - size/2 - 10 - force * 2 + 8, 150 - size/2 - 5);
                ctx.lineTo(x - size/2 - 10 - force * 2 + 8, 150 - size/2 + 5);
                ctx.closePath();
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();
            }

            // Draw friction force vector
            const friction = parseFloat(document.getElementById('friction').value);
            if (friction > 0 && state.force.v !== 0) {
                const frictionForce = friction * mass * 9.8;
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + size/2 + 10, 150 - size/2);
                ctx.lineTo(x + size/2 + 10 + frictionForce * 2 * Math.sign(state.force.v), 150 - size/2);
                ctx.stroke();
            }
        }

        function updateForceStatus() {
            const mass = parseFloat(document.getElementById('mass').value);
            const force = parseFloat(document.getElementById('force').value);
            const friction = parseFloat(document.getElementById('friction').value);
            const frictionForce = friction * mass * 9.8;
            const netForce = force - frictionForce;
            
            document.getElementById('status-force').textContent = 
                `Acceleration: ${state.force.a.toFixed(2)} m/s¬≤ | Net Force: ${netForce.toFixed(1)} N`;
        }

        // Oscillation Functions
        function toggleOscillation() {
            if (state.oscillation.playing) {
                cancelAnimationFrame(animations.oscillation);
                animations.oscillation = null;
                state.oscillation.playing = false;
                document.getElementById('osc-btn').textContent = 'Start';
            } else {
                state.oscillation.playing = true;
                state.oscillation.t = 0;
                document.getElementById('osc-btn').textContent = 'Stop';
                animateOscillation();
            }
        }

        function resetOscillation() {
            state.oscillation = { t: 0, playing: false };
            if (animations.oscillation) {
                cancelAnimationFrame(animations.oscillation);
                animations.oscillation = null;
            }
            document.getElementById('osc-btn').textContent = 'Start';
            drawOscillation();
        }

        function animateOscillation() {
            if (!state.oscillation.playing) return;

            state.oscillation.t += 0.02;
            drawOscillation();
            updateOscillationStatus();

            animations.oscillation = requestAnimationFrame(animateOscillation);
        }

        function drawOscillation() {
            const canvas = document.getElementById('oscillation');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const amplitude = parseFloat(document.getElementById('amplitude').value);
            const frequency = parseFloat(document.getElementById('frequency').value);
            const omega = 2 * Math.PI * frequency;

            // Draw equilibrium line
            ctx.strokeStyle = 'rgba(99, 179, 237, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();

            // Draw spring
            const centerY = canvas.height / 2;
            const springLength = 100;
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            for (let i = 0; i < springLength; i += 10) {
                const y = centerY + (i % 20 - 10) * 2;
                ctx.lineTo(50 + i, y);
            }
            ctx.stroke();

            // Draw mass
            const x = amplitude * Math.cos(omega * state.oscillation.t);
            const massX = 150 + x;
            
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(massX - 15, centerY - 15, 30, 30);

            // Draw position graph
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < state.oscillation.t * 100; i++) {
                const t = i / 100;
                const pos = amplitude * Math.cos(omega * t);
                const graphX = 250 + t * 50;
                const graphY = centerY + pos * 0.5;
                if (i === 0) {
                    ctx.moveTo(graphX, graphY);
                } else {
                    ctx.lineTo(graphX, graphY);
                }
            }
            ctx.stroke();
        }

        function updateOscillationStatus() {
            const amplitude = parseFloat(document.getElementById('amplitude').value);
            const frequency = parseFloat(document.getElementById('frequency').value);
            const omega = 2 * Math.PI * frequency;
            
            const position = amplitude * Math.cos(omega * state.oscillation.t);
            const velocity = -amplitude * omega * Math.sin(omega * state.oscillation.t);
            const energy = 0.5 * Math.pow(amplitude * omega, 2); // Assuming unit mass
            
            document.getElementById('status-osc').textContent = 
                `Position: ${position.toFixed(1)} | Velocity: ${velocity.toFixed(1)} | Energy: ${energy.toFixed(1)}`;
        }

        // Phase Space Functions
        function initPhaseSpace() {
            drawPhaseSpaceSHO();
            drawPhaseSpaceDamped();
        }

        function drawPhaseSpaceSHO() {
            const canvas = document.getElementById('phase-sho');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.moveTo(0, canvas.height/2);
            ctx.lineTo(canvas.width, canvas.height/2);
            ctx.stroke();

            // Draw elliptical trajectory
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t <= 2 * Math.PI; t += 0.1) {
                const x = 80 * Math.cos(t);
                const v = -80 * Math.sin(t);
                const canvasX = canvas.width/2 + x;
                const canvasY = canvas.height/2 - v;
                if (t === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.fillText('Position', canvas.width - 60, canvas.height/2 - 10);
            ctx.save();
            ctx.translate(10, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Velocity', 0, 0);
            ctx.restore();
        }

        function drawPhaseSpaceDamped() {
            const canvas = document.getElementById('phase-damped');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.moveTo(0, canvas.height/2);
            ctx.lineTo(canvas.width, canvas.height/2);
            ctx.stroke();

            // Draw spiral trajectory (damped oscillator)
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let x = 80, v = 0;
            const dt = 0.02;
            const omega = 5;
            const gamma = 0.5;
            
            for (let i = 0; i < 500; i++) {
                const canvasX = canvas.width/2 + x;
                const canvasY = canvas.height/2 - v;
                
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
                
                const a = -omega * omega * x - 2 * gamma * v;
                v += a * dt;
                x += v * dt;
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.fillText('Position', canvas.width - 60, canvas.height/2 - 10);
            ctx.save();
            ctx.translate(10, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Velocity', 0, 0);
            ctx.restore();
        }

        // Energy Demo Functions
        function startEnergyDemo() {
            state.energy.playing = true;
            state.energy.t = 0;
            state.energy.system = document.getElementById('energy-system').value;
            document.getElementById('energy-btn').textContent = 'Stop';
            animateEnergyDemo();
        }

        function resetEnergyDemo() {
            state.energy = { t: 0, playing: false, system: 'pendulum' };
            if (animations.energy) {
                cancelAnimationFrame(animations.energy);
                animations.energy = null;
            }
            document.getElementById('energy-btn').textContent = 'Start';
            drawEnergyDemo();
        }

        function animateEnergyDemo() {
            if (!state.energy.playing) return;

            state.energy.t += 0.02;
            drawEnergyDemo();
            updateEnergyInfo();

            animations.energy = requestAnimationFrame(animateEnergyDemo);
        }

        function drawEnergyDemo() {
            const canvas = document.getElementById('energy-motion');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const system = state.energy.system;

            if (system === 'pendulum') {
                drawPendulum(ctx);
            } else if (system === 'spring') {
                drawSpringMass(ctx);
            } else if (system === 'projectile') {
                drawProjectileEnergy(ctx);
            }

            drawEnergyChart();
        }

        function drawPendulum(ctx) {
            const length = 150;
            const amplitude = Math.PI / 4; // 45 degrees
            const omega = Math.sqrt(9.8 / length);
            const theta = amplitude * Math.cos(omega * state.energy.t);
            
            const anchorX = 200;
            const anchorY = 50;
            const bobX = anchorX + length * Math.sin(theta);
            const bobY = anchorY + length * Math.cos(theta);

            // Draw string
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(anchorX, anchorY);
            ctx.lineTo(bobX, bobY);
            ctx.stroke();

            // Draw anchor
            ctx.fillStyle = '#4a5568';
            ctx.fillRect(anchorX - 5, anchorY - 5, 10, 10);

            // Draw bob
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(bobX, bobY, 12, 0, 2 * Math.PI);
            ctx.fill();

            // Store values for energy calculation
            state.energy.theta = theta;
            state.energy.omega_val = omega;
            state.energy.length = length;
        }

        function drawSpringMass(ctx) {
            const amplitude = 50;
            const omega = 3;
            const x = amplitude * Math.cos(omega * state.energy.t);
            
            const centerX = 200;
            const centerY = 150;
            const massX = centerX + x;

            // Draw spring
            ctx.strokeStyle = '#63b3ed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            const segments = 20;
            for (let i = 0; i <= segments; i++) {
                const springX = 50 + (massX - 50 - 20) * i / segments;
                const springY = centerY + (i % 2 === 0 ? 0 : 10) * Math.sin(i * 0.5);
                ctx.lineTo(springX, springY);
            }
            ctx.stroke();

            // Draw mass
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(massX - 15, centerY - 15, 30, 30);

            // Store values for energy calculation
            state.energy.x = x;
            state.energy.v = -amplitude * omega * Math.sin(omega * state.energy.t);
            state.energy.amplitude = amplitude;
            state.energy.omega_val = omega;
        }

        function drawProjectileEnergy(ctx) {
            const v0 = 40;
            const angle = Math.PI / 4;
            const vx = v0 * Math.cos(angle);
            const vy = v0 * Math.sin(angle) - 9.8 * state.energy.t;
            const x = vx * state.energy.t;
            const y = v0 * Math.sin(angle) * state.energy.t - 0.5 * 9.8 * state.energy.t * state.energy.t;

            if (y < 0) {
                resetEnergyDemo();
                return;
            }

            const canvasX = 50 + x * 2;
            const canvasY = 250 - y * 2;

            // Draw trajectory
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t <= state.energy.t; t += 0.02) {
                const trailX = vx * t;
                const trailY = v0 * Math.sin(angle) * t - 0.5 * 9.8 * t * t;
                const trailCanvasX = 50 + trailX * 2;
                const trailCanvasY = 250 - trailY * 2;
                if (t === 0) {
                    ctx.moveTo(trailCanvasX, trailCanvasY);
                } else {
                    ctx.lineTo(trailCanvasX, trailCanvasY);
                }
            }
            ctx.stroke();

            // Draw projectile
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 8, 0, 2 * Math.PI);
            ctx.fill();

            // Store values for energy calculation
            state.energy.x = x;
            state.energy.y = y;
            state.energy.vx = vx;
            state.energy.vy = vy;
        }

        function drawEnergyChart() {
            const canvas = document.getElementById('energy-chart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate energies based on system type
            let ke = 0, pe = 0, te = 0;
            const m = 1; // Assume unit mass

            if (state.energy.system === 'pendulum') {
                const theta = state.energy.theta || 0;
                const omega = state.energy.omega_val || 0;
                const length = state.energy.length || 150;
                const v = length * omega * Math.sin(omega * state.energy.t) * (Math.PI / 4);
                ke = 0.5 * m * v * v;
                pe = m * 9.8 * length * (1 - Math.cos(theta));
                te = ke + pe;
            } else if (state.energy.system === 'spring') {
                const x = state.energy.x || 0;
                const v = state.energy.v || 0;
                const k = 1; // Spring constant
                ke = 0.5 * m * v * v;
                pe = 0.5 * k * x * x;
                te = ke + pe;
            } else if (state.energy.system === 'projectile') {
                const vx = state.energy.vx || 0;
                const vy = state.energy.vy || 0;
                const y = state.energy.y || 0;
                ke = 0.5 * m * (vx * vx + vy * vy);
                pe = m * 9.8 * y / 100; // Scale factor
                te = ke + pe;
            }

            // Draw energy bars
            const barWidth = 60;
            const maxHeight = 200;
            const maxEnergy = Math.max(te, 100);

            // KE bar
            const keHeight = (ke / maxEnergy) * maxHeight;
            ctx.fillStyle = '#4ecdc4';
            ctx.fillRect(50, canvas.height - 50 - keHeight, barWidth, keHeight);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('KE', 65, canvas.height - 30);

            // PE bar
            const peHeight = (pe / maxEnergy) * maxHeight;
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(150, canvas.height - 50 - peHeight, barWidth, peHeight);
            ctx.fillText('PE', 165, canvas.height - 30);

            // Total energy line
            const teHeight = (te / maxEnergy) * maxHeight;
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(30, canvas.height - 50 - teHeight);
            ctx.lineTo(230, canvas.height - 50 - teHeight);
            ctx.stroke();
            ctx.fillText('Total', 250, canvas.height - 50 - teHeight + 5);

            // Update energy display
            document.getElementById('ke-val').textContent = ke.toFixed(2);
            document.getElementById('pe-val').textContent = pe.toFixed(2);
            document.getElementById('te-val').textContent = te.toFixed(2);
        }

        function updateEnergyInfo() {
            // This function is called from animateEnergyDemo
        }

        // Exercise Functions
        function checkAnglePrediction() {
            const guess = parseFloat(document.getElementById('angle-guess').value);
            const correct = 45;
            const result = document.getElementById('angle-result');
            
            if (Math.abs(guess - correct) < 2) {
                result.innerHTML = '<span style="color: #4caf50;">‚úì Correct! Maximum range occurs at 45¬∞</span>';
            } else {
                result.innerHTML = `<span style="color: #f44336;">‚úó Not quite. The optimal angle is ${correct}¬∞. You guessed ${guess}¬∞</span>`;
            }
        }

        function checkForceCalculation() {
            const guess = parseFloat(document.getElementById('force-guess').value);
            const correct = 50; // F = ma = 10 * 5 = 50 N
            const result = document.getElementById('force-result');
            
            if (Math.abs(guess - correct) < 1) {
                result.innerHTML = '<span style="color: #4caf50;">‚úì Correct! F = ma = 10 kg √ó 5 m/s¬≤ = 50 N</span>';
            } else {
                result.innerHTML = `<span style="color: #f44336;">‚úó Not quite. F = ma = 10 √ó 5 = 50 N. You guessed ${guess} N</span>`;
            }
        }

        // Initialize everything when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
