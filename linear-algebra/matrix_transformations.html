<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Transformations - Theory and Interactive Visualization</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            background: #111;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.6;
        }
        
        .nav-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 15px 0;
            border-bottom: 1px solid #333;
        }
        
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .nav-tab {
            padding: 10px 25px;
            background: #333;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .nav-tab:hover {
            background: #555;
        }
        
        .nav-tab.active {
            background: #0ff;
            color: #000;
        }
        
        .section {
            display: none;
            padding: 80px 20px 20px;
            min-height: 100vh;
        }
        
        .section.active {
            display: block;
        }
        
        .theory-content {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 40px;
        }
        
        .theory-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .theory-header h1 {
            color: #0ff;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .theory-header p {
            font-size: 1.2em;
            color: #aaa;
            margin: 0;
        }
        
        .theory-section {
            margin: 40px 0;
            padding: 30px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            border-left: 4px solid #0ff;
        }
        
        .theory-section h2 {
            color: #0ff;
            font-size: 1.8em;
            margin-bottom: 20px;
        }
        
        .theory-section h3 {
            color: #f39c12;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }
        
        .definition {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .definition h4 {
            color: #0ff;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        
        .example {
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid #f39c12;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .example h4 {
            color: #f39c12;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        
        .theorem {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid #e74c3c;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .theorem h4 {
            color: #e74c3c;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        
        .matrix-display {
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
        }
        
        .transformation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .transformation-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #333;
        }
        
        .transformation-card h4 {
            color: #0ff;
            margin: 0 0 15px 0;
        }
        
        .interactive-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
        }
        
        canvas {
            background: #000;
            border: 1px solid #444;
        }
        
        .controls {
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-left: 1px solid #444;
            overflow-y: auto;
        }
        
        .control-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #0ff;
            font-size: 16px;
        }
        
        .transformation-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .transformation-buttons button {
            padding: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .transformation-buttons button:hover {
            background: #555;
        }
        
        .transformation-buttons button.active {
            background: #0ff;
            color: #000;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-size: 12px;
            color: #0ff;
            text-align: right;
        }
        
        .matrix-display {
            background: rgba(0, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .matrix-display .matrix {
            text-align: center;
            margin: 10px 0;
        }
        
        .vector-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .vector-inputs input {
            padding: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            width: 100%;
        }
        
        .reset-button {
            width: 100%;
            padding: 12px;
            background: #f39c12;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .reset-button:hover {
            background: #e67e22;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
            z-index: 10;
        }
        
        .legend {
            font-size: 11px;
            margin-top: 10px;
            line-height: 1.4;
        }
        
        .legend-item {
            margin: 3px 0;
        }
    </style>





</head>
<body>
    <!-- Navigation -->
    <div class="nav-container">
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showSection('theory')">üìö Theory</button>
            <button class="nav-tab" onclick="showSection('interactive')">üéÆ Interactive</button>
        </div>
    </div>

    <!-- Theory Section -->
    <div id="theory" class="section active">
        <div class="theory-content">
            <div class="theory-header">
                <h1>Matrix Transformations</h1>
                <p>Mathematical foundations of linear transformations in 2D space</p>
            </div>

            <div class="theory-section">
                <h2>1. Introduction to Linear Transformations</h2>
                
                <div class="definition">
                    <h4>Definition: Linear Transformation</h4>
                    <p>A <strong>linear transformation</strong> $T: \mathbb{R}^2 \to \mathbb{R}^2$ is a function that satisfies:</p>
                    <ul>
                        <li><strong>Additivity:</strong> $T(\vec{u} + \vec{v}) = T(\vec{u}) + T(\vec{v})$</li>
                        <li><strong>Scalar multiplication:</strong> $T(c\vec{u}) = cT(\vec{u})$</li>
                    </ul>
                    <p>These properties ensure that lines remain lines and the origin maps to itself.</p>
                </div>

                <div class="theorem">
                    <h4>Fundamental Theorem</h4>
                    <p>Every linear transformation $T: \mathbb{R}^2 \to \mathbb{R}^2$ can be represented as matrix multiplication:</p>
                    <div class="matrix-display">
                        $$T\begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} a & b \\ c & d \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} ax + by \\ cx + dy \end{pmatrix}$$
                    </div>
                    <p>The matrix columns are the images of the standard basis vectors: $T(\vec{e_1}) = \begin{pmatrix} a \\ c \end{pmatrix}$ and $T(\vec{e_2}) = \begin{pmatrix} b \\ d \end{pmatrix}$</p>
                </div>

                <h3>Matrix Representation</h3>
                <p>The transformation matrix $A = \begin{pmatrix} a & b \\ c & d \end{pmatrix}$ completely determines the linear transformation. The action on any vector $\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}$ is given by:</p>
                <div class="matrix-display">
                    $$A\vec{v} = \begin{pmatrix} a & b \\ c & d \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} ax + by \\ cx + dy \end{pmatrix}$$
                </div>
            </div>

            <div class="theory-section">
                <h2>2. Fundamental Transformation Types</h2>

                <div class="transformation-grid">
                    <div class="transformation-card">
                        <h4>Identity Transformation</h4>
                        <div class="matrix-display">
                            $$I = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> No change to any vector</p>
                        <p><strong>Properties:</strong> $I\vec{v} = \vec{v}$ for all $\vec{v}$</p>
                    </div>

                    <div class="transformation-card">
                        <h4>Scaling Transformation</h4>
                        <div class="matrix-display">
                            $$S = \begin{pmatrix} s_x & 0 \\ 0 & s_y \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> Stretches/shrinks along axes</p>
                        <p><strong>Properties:</strong> $s_x, s_y > 0$ (no reflection)</p>
                        <p><strong>Special cases:</strong> Uniform scaling when $s_x = s_y$</p>
                    </div>

                    <div class="transformation-card">
                        <h4>Rotation Transformation</h4>
                        <div class="matrix-display">
                            $$R_\theta = \begin{pmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> Rotates by angle $\theta$ counterclockwise</p>
                        <p><strong>Properties:</strong> Preserves distances and angles</p>
                        <p><strong>Determinant:</strong> $\det(R_\theta) = 1$ (area-preserving)</p>
                    </div>

                    <div class="transformation-card">
                        <h4>Shear Transformation</h4>
                        <div class="matrix-display">
                            $$\text{Shear}_x = \begin{pmatrix} 1 & k \\ 0 & 1 \end{pmatrix}, \quad \text{Shear}_y = \begin{pmatrix} 1 & 0 \\ k & 1 \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> Skews along one axis</p>
                        <p><strong>Properties:</strong> Preserves area ($\det = 1$)</p>
                        <p><strong>Parameter:</strong> $k$ controls shear amount</p>
                    </div>

                    <div class="transformation-card">
                        <h4>Reflection Transformation</h4>
                        <div class="matrix-display">
                            $$\text{Ref}_x = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}, \quad \text{Ref}_y = \begin{pmatrix} -1 & 0 \\ 0 & 1 \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> Mirrors across axis</p>
                        <p><strong>Properties:</strong> $\det = -1$ (orientation-reversing)</p>
                        <p><strong>General line:</strong> More complex formula for arbitrary lines</p>
                    </div>

                    <div class="transformation-card">
                        <h4>Projection Transformation</h4>
                        <div class="matrix-display">
                            $$\text{Proj}_x = \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}, \quad \text{Proj}_y = \begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}$$
                        </div>
                        <p><strong>Effect:</strong> Projects onto axis</p>
                        <p><strong>Properties:</strong> $\det = 0$ (reduces dimension)</p>
                        <p><strong>Note:</strong> Not invertible (singular)</p>
                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h2>3. Matrix Properties and Geometric Interpretation</h2>

                <h3>Determinant</h3>
                <p>For matrix $A = \begin{pmatrix} a & b \\ c & d \end{pmatrix}$, the determinant is:</p>
                <div class="matrix-display">
                    $$\det(A) = ad - bc$$
                </div>

                <div class="example">
                    <h4>Geometric Meaning of Determinant</h4>
                    <ul>
                        <li><strong>$|\det(A)|$:</strong> Factor by which areas are scaled</li>
                        <li><strong>$\det(A) > 0$:</strong> Orientation is preserved</li>
                        <li><strong>$\det(A) < 0$:</strong> Orientation is reversed</li>
                        <li><strong>$\det(A) = 0$:</strong> Transformation is singular (not invertible)</li>
                        <li><strong>$|\det(A)| = 1$:</strong> Area-preserving transformation</li>
                    </ul>
                </div>

                <h3>Eigenvalues and Eigenvectors</h3>
                <p>For a transformation matrix $A$, an <strong>eigenvector</strong> $\vec{v}$ satisfies:</p>
                <div class="matrix-display">
                    $$A\vec{v} = \lambda\vec{v}$$
                </div>
                <p>where $\lambda$ is the corresponding <strong>eigenvalue</strong>. Eigenvectors point in directions that are only scaled, not rotated.</p>

                <div class="theorem">
                    <h4>Characteristic Polynomial</h4>
                    <p>Eigenvalues are found by solving:</p>
                    <div class="matrix-display">
                        $$\det(A - \lambda I) = 0$$
                    </div>
                    <p>For 2√ó2 matrices: $\lambda^2 - (a+d)\lambda + (ad-bc) = 0$</p>
                </div>
            </div>

            <div class="theory-section">
                <h2>4. Composition of Transformations</h2>

                <p>When applying multiple transformations in sequence, we multiply their matrices. If transformation $T_1$ is applied first, then $T_2$, the composite transformation is:</p>
                <div class="matrix-display">
                    $$(T_2 \circ T_1)(\vec{v}) = T_2(T_1(\vec{v})) = A_2(A_1\vec{v}) = (A_2A_1)\vec{v}$$
                </div>

                <div class="example">
                    <h4>Example: Rotation followed by Scaling</h4>
                    <p>Rotate by 45¬∞ then scale by factor 2:</p>
                    <div class="matrix-display">
                        $$A_{composite} = \begin{pmatrix} 2 & 0 \\ 0 & 2 \end{pmatrix} \begin{pmatrix} \frac{\sqrt{2}}{2} & -\frac{\sqrt{2}}{2} \\ \frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2} \end{pmatrix} = \begin{pmatrix} \sqrt{2} & -\sqrt{2} \\ \sqrt{2} & \sqrt{2} \end{pmatrix}$$
                    </div>
                    <p><strong>Note:</strong> Matrix multiplication is not commutative: $A_2A_1 \neq A_1A_2$ in general</p>
                </div>

                <h3>Inverse Transformations</h3>
                <p>If $\det(A) \neq 0$, the transformation is invertible with inverse:</p>
                <div class="matrix-display">
                    $$A^{-1} = \frac{1}{\det(A)} \begin{pmatrix} d & -b \\ -c & a \end{pmatrix}$$
                </div>
                <p>The inverse transformation "undoes" the original: $A^{-1}A = AA^{-1} = I$</p>
            </div>

            <div class="theory-section">
                <h2>5. Advanced Topics</h2>

                <h3>Singular Value Decomposition (SVD)</h3>
                <p>Any 2√ó2 matrix can be decomposed as:</p>
                <div class="matrix-display">
                    $$A = U\Sigma V^T$$
                </div>
                <p>where $U$ and $V$ are rotation matrices and $\Sigma$ is a scaling matrix. This reveals the geometric interpretation: every linear transformation is a composition of rotation, scaling, and rotation.</p>

                <h3>Matrix Norms</h3>
                <div class="definition">
                    <h4>Important Matrix Norms</h4>
                    <ul>
                        <li><strong>Frobenius norm:</strong> $\|A\|_F = \sqrt{a^2 + b^2 + c^2 + d^2}$</li>
                        <li><strong>Operator norm:</strong> $\|A\|_2 = \sigma_{max}$ (largest singular value)</li>
                        <li><strong>Condition number:</strong> $\kappa(A) = \frac{\sigma_{max}}{\sigma_{min}}$ (measures numerical stability)</li>
                    </ul>
                </div>

                <h3>Applications</h3>
                <div class="example">
                    <h4>Real-World Applications</h4>
                    <ul>
                        <li><strong>Computer Graphics:</strong> 3D rotations, scaling, transformations</li>
                        <li><strong>Image Processing:</strong> Geometric corrections, filtering</li>
                        <li><strong>Robotics:</strong> Coordinate frame transformations</li>
                        <li><strong>Physics:</strong> Stress/strain tensors, electromagnetic fields</li>
                        <li><strong>Data Science:</strong> Principal Component Analysis (PCA)</li>
                        <li><strong>Economics:</strong> Input-output models, Markov chains</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Interactive Section -->
    <div id="interactive" class="section">
        <div class="interactive-container">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
                <div class="info-panel">
                    <strong>üîÑ Matrix Transformations</strong><br/>
                    Select a transformation type and adjust parameters to see how matrices affect geometric shapes.
                    <div class="legend">
                        <div class="legend-item" style="color: #0ff;">üîµ Original Shape</div>
                        <div class="legend-item" style="color: #f39c12;">üü† Transformed Shape</div>
                        <div class="legend-item" style="color: #e74c3c;">üî¥ Transformation Vector</div>
                        <div class="legend-item" style="color: #555;">üìê Grid Lines</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-section">
                    <h3>Transformation Type</h3>
                    <div class="transformation-buttons">
                        <button id="identity" class="active">Identity</button>
                        <button id="scale">Scale</button>
                        <button id="rotation">Rotation</button>
                        <button id="shear">Shear</button>
                        <button id="reflection">Reflection</button>
                        <button id="custom">Custom</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Parameters</h3>
                    <div id="scaleControls" class="parameter-controls">
                        <div class="slider-group">
                            <label>Scale X:</label>
                            <input type="range" id="scaleX" min="0.1" max="3" step="0.1" value="1">
                            <div class="slider-value" id="scaleXValue">1.0</div>
                        </div>
                        <div class="slider-group">
                            <label>Scale Y:</label>
                            <input type="range" id="scaleY" min="0.1" max="3" step="0.1" value="1">
                            <div class="slider-value" id="scaleYValue">1.0</div>
                        </div>
                    </div>
                    
                    <div id="rotationControls" class="parameter-controls" style="display: none;">
                        <div class="slider-group">
                            <label>Angle (degrees):</label>
                            <input type="range" id="rotationAngle" min="0" max="360" step="5" value="0">
                            <div class="slider-value" id="rotationAngleValue">0¬∞</div>
                        </div>
                    </div>
                    
                    <div id="shearControls" class="parameter-controls" style="display: none;">
                        <div class="slider-group">
                            <label>Shear X:</label>
                            <input type="range" id="shearX" min="-2" max="2" step="0.1" value="0">
                            <div class="slider-value" id="shearXValue">0.0</div>
                        </div>
                        <div class="slider-group">
                            <label>Shear Y:</label>
                            <input type="range" id="shearY" min="-2" max="2" step="0.1" value="0">
                            <div class="slider-value" id="shearYValue">0.0</div>
                        </div>
                    </div>
                    
                    <div id="reflectionControls" class="parameter-controls" style="display: none;">
                        <div class="slider-group">
                            <label>Reflection Axis:</label>
                            <select id="reflectionAxis" style="width: 100%; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                                <option value="x">X-axis</option>
                                <option value="y">Y-axis</option>
                                <option value="origin">Through Origin</option>
                                <option value="line">Custom Line y=mx</option>
                            </select>
                        </div>
                        <div class="slider-group" id="reflectionSlope" style="display: none;">
                            <label>Line Slope (m):</label>
                            <input type="range" id="reflectionM" min="-3" max="3" step="0.1" value="1">
                            <div class="slider-value" id="reflectionMValue">1.0</div>
                        </div>
                    </div>
                    
                    <div id="customControls" class="parameter-controls" style="display: none;">
                        <div class="slider-group">
                            <label>Matrix Elements:</label>
                            <div class="vector-inputs">
                                <input type="number" id="m11" step="0.1" value="1" placeholder="a">
                                <input type="number" id="m12" step="0.1" value="0" placeholder="b">
                                <input type="number" id="m21" step="0.1" value="0" placeholder="c">
                                <input type="number" id="m22" step="0.1" value="1" placeholder="d">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Current Transformation Matrix</h3>
                    <div class="matrix-display">
                        <div class="matrix">
                            [<span id="matrix11">1.0</span>  <span id="matrix12">0.0</span>]<br>
                            [<span id="matrix21">0.0</span>  <span id="matrix22">1.0</span>]
                        </div>
                        <div style="margin-top: 10px; font-size: 12px;">
                            det = <span id="determinant">1.0</span><br>
                            <span id="matrixProperties">Identity Matrix</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Test Vector</h3>
                    <div class="vector-inputs">
                        <input type="number" id="vectorX" step="0.5" value="2" placeholder="x">
                        <input type="number" id="vectorY" step="0.5" value="1" placeholder="y">
                    </div>
                    <div style="margin-top: 10px; font-size: 12px;">
                        Original: (<span id="origVector">2, 1</span>)<br>
                        Transformed: (<span id="transVector">2, 1</span>)
                    </div>
                    <button class="reset-button" onclick="resetTransformation()">Reset All</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation functionality
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Reinitialize canvas if switching to interactive
            if (sectionId === 'interactive') {
                setTimeout(() => {
                    initializeCanvas();
                    draw();
                }, 100);
            }
        }

        // Canvas and interactive functionality
        let canvas, ctx;
        const width = 800;
        const height = 600;
        let centerX, centerY;
        const scale = 50; // pixels per unit
        
        // Current transformation matrix
        let transformMatrix = {
            a: 1, b: 0,
            c: 0, d: 1
        };
        
        let currentTransformation = 'identity';
        
        // Original shape (unit square and some other shapes)
        const originalShapes = {
            square: [
                {x: -1, y: -1}, {x: 1, y: -1}, {x: 1, y: 1}, {x: -1, y: 1}
            ],
            triangle: [
                {x: 0, y: 1}, {x: -0.866, y: -0.5}, {x: 0.866, y: -0.5}
            ],
            house: [
                {x: -1, y: -1}, {x: 1, y: -1}, {x: 1, y: 0}, 
                {x: 0, y: 1}, {x: -1, y: 0}
            ]
        };
        
        function initializeCanvas() {
            canvas = document.getElementById('canvas');
            if (!canvas) return;
            
            ctx = canvas.getContext('2d');
            centerX = width / 2;
            centerY = height / 2;
        }
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function applyTransformation(point) {
            return {
                x: transformMatrix.a * point.x + transformMatrix.b * point.y,
                y: transformMatrix.c * point.x + transformMatrix.d * point.y
            };
        }
        
        function drawGrid() {
            if (!ctx) return;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = -10; x <= 10; x++) {
                const canvasX = toCanvasX(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = -10; y <= 10; y++) {
                const canvasY = toCanvasY(y);
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(width, canvasY);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawShape(points, color, lineWidth = 2) {
            if (points.length === 0 || !ctx) return;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            const firstPoint = points[0];
            ctx.moveTo(toCanvasX(firstPoint.x), toCanvasY(firstPoint.y));
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(toCanvasX(points[i].x), toCanvasY(points[i].y));
            }
            
            ctx.closePath();
            ctx.stroke();
        }
        
        function drawVector(from, to, color) {
            if (!ctx) return;
            
            const canvasFromX = toCanvasX(from.x);
            const canvasFromY = toCanvasY(from.y);
            const canvasToX = toCanvasX(to.x);
            const canvasToY = toCanvasY(to.y);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(canvasFromX, canvasFromY);
            ctx.lineTo(canvasToX, canvasToY);
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(canvasToY - canvasFromY, canvasToX - canvasFromX);
            const arrowLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(canvasToX, canvasToY);
            ctx.lineTo(
                canvasToX - arrowLength * Math.cos(angle - Math.PI / 6),
                canvasToY - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(canvasToX, canvasToY);
            ctx.lineTo(
                canvasToX - arrowLength * Math.cos(angle + Math.PI / 6),
                canvasToY - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }
        
        function draw() {
            if (!canvas || !ctx) return;
            
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            
            // Draw original shapes
            drawShape(originalShapes.square, '#0ff', 2);
            drawShape(originalShapes.triangle, '#0ff', 1);
            
            // Draw transformed shapes
            const transformedSquare = originalShapes.square.map(applyTransformation);
            const transformedTriangle = originalShapes.triangle.map(applyTransformation);
            
            drawShape(transformedSquare, '#f39c12', 2);
            drawShape(transformedTriangle, '#f39c12', 1);
            
            // Draw test vector and its transformation
            const vectorXEl = document.getElementById('vectorX');
            const vectorYEl = document.getElementById('vectorY');
            if (!vectorXEl || !vectorYEl) return;
            
            const vectorX = parseFloat(vectorXEl.value) || 0;
            const vectorY = parseFloat(vectorYEl.value) || 0;
            const originalVector = {x: vectorX, y: vectorY};
            const transformedVector = applyTransformation(originalVector);
            
            drawVector({x: 0, y: 0}, originalVector, '#0ff');
            drawVector({x: 0, y: 0}, transformedVector, '#e74c3c');
            
            // Update vector display
            const origVectorEl = document.getElementById('origVector');
            const transVectorEl = document.getElementById('transVector');
            if (origVectorEl && transVectorEl) {
                origVectorEl.textContent = `${originalVector.x.toFixed(1)}, ${originalVector.y.toFixed(1)}`;
                transVectorEl.textContent = `${transformedVector.x.toFixed(1)}, ${transformedVector.y.toFixed(1)}`;
            }
        }
        
        function updateMatrix() {
            // Update matrix display
            const elements = ['matrix11', 'matrix12', 'matrix21', 'matrix22'];
            const values = [transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d];
            
            elements.forEach((id, index) => {
                const el = document.getElementById(id);
                if (el) el.textContent = values[index].toFixed(2);
            });
            
            // Calculate determinant
            const det = transformMatrix.a * transformMatrix.d - transformMatrix.b * transformMatrix.c;
            const detEl = document.getElementById('determinant');
            if (detEl) detEl.textContent = det.toFixed(2);
            
            // Determine matrix properties
            let properties = [];
            if (Math.abs(det) < 0.001) {
                properties.push('Singular (non-invertible)');
            }
            if (Math.abs(det - 1) < 0.001) {
                properties.push('Area-preserving');
            }
            if (det < 0) {
                properties.push('Orientation-reversing');
            }
            if (transformMatrix.a === 1 && transformMatrix.b === 0 && 
                transformMatrix.c === 0 && transformMatrix.d === 1) {
                properties.push('Identity Matrix');
            }
            
            const propsEl = document.getElementById('matrixProperties');
            if (propsEl) {
                propsEl.textContent = properties.length > 0 ? properties.join(', ') : 'General transformation';
            }
            
            draw();
        }
        
        function setTransformation(type) {
            // Remove active class from all buttons
            document.querySelectorAll('.transformation-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to clicked button
            const btn = document.getElementById(type);
            if (btn) btn.classList.add('active');
            
            // Hide all parameter controls
            document.querySelectorAll('.parameter-controls').forEach(control => {
                control.style.display = 'none';
            });
            
            currentTransformation = type;
            
            switch(type) {
                case 'identity':
                    transformMatrix = {a: 1, b: 0, c: 0, d: 1};
                    break;
                case 'scale':
                    const scaleEl = document.getElementById('scaleControls');
                    if (scaleEl) scaleEl.style.display = 'block';
                    updateScaleTransformation();
                    break;
                case 'rotation':
                    const rotEl = document.getElementById('rotationControls');
                    if (rotEl) rotEl.style.display = 'block';
                    updateRotationTransformation();
                    break;
                case 'shear':
                    const shearEl = document.getElementById('shearControls');
                    if (shearEl) shearEl.style.display = 'block';
                    updateShearTransformation();
                    break;
                case 'reflection':
                    const reflEl = document.getElementById('reflectionControls');
                    if (reflEl) reflEl.style.display = 'block';
                    updateReflectionTransformation();
                    break;
                case 'custom':
                    const customEl = document.getElementById('customControls');
                    if (customEl) customEl.style.display = 'block';
                    updateCustomTransformation();
                    break;
            }
            
            updateMatrix();
        }
        
        function updateScaleTransformation() {
            const scaleXEl = document.getElementById('scaleX');
            const scaleYEl = document.getElementById('scaleY');
            if (!scaleXEl || !scaleYEl) return;
            
            const scaleX = parseFloat(scaleXEl.value);
            const scaleY = parseFloat(scaleYEl.value);
            
            transformMatrix = {
                a: scaleX, b: 0,
                c: 0, d: scaleY
            };
            
            const scaleXValueEl = document.getElementById('scaleXValue');
            const scaleYValueEl = document.getElementById('scaleYValue');
            if (scaleXValueEl) scaleXValueEl.textContent = scaleX.toFixed(1);
            if (scaleYValueEl) scaleYValueEl.textContent = scaleY.toFixed(1);
            
            updateMatrix();
        }
        
        function updateRotationTransformation() {
            const angleEl = document.getElementById('rotationAngle');
            if (!angleEl) return;
            
            const angleDeg = parseFloat(angleEl.value);
            const angleRad = angleDeg * Math.PI / 180;
            
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            
            transformMatrix = {
                a: cos, b: -sin,
                c: sin, d: cos
            };
            
            const angleValueEl = document.getElementById('rotationAngleValue');
            if (angleValueEl) angleValueEl.textContent = angleDeg.toFixed(0) + '¬∞';
            
            updateMatrix();
        }
        
        function updateShearTransformation() {
            const shearXEl = document.getElementById('shearX');
            const shearYEl = document.getElementById('shearY');
            if (!shearXEl || !shearYEl) return;
            
            const shearX = parseFloat(shearXEl.value);
            const shearY = parseFloat(shearYEl.value);
            
            transformMatrix = {
                a: 1, b: shearX,
                c: shearY, d: 1
            };
            
            const shearXValueEl = document.getElementById('shearXValue');
            const shearYValueEl = document.getElementById('shearYValue');
            if (shearXValueEl) shearXValueEl.textContent = shearX.toFixed(1);
            if (shearYValueEl) shearYValueEl.textContent = shearY.toFixed(1);
            
            updateMatrix();
        }
        
        function updateReflectionTransformation() {
            const axisEl = document.getElementById('reflectionAxis');
            if (!axisEl) return;
            
            const axis = axisEl.value;
            
            switch(axis) {
                case 'x':
                    transformMatrix = {a: 1, b: 0, c: 0, d: -1};
                    const slopeEl1 = document.getElementById('reflectionSlope');
                    if (slopeEl1) slopeEl1.style.display = 'none';
                    break;
                case 'y':
                    transformMatrix = {a: -1, b: 0, c: 0, d: 1};
                    const slopeEl2 = document.getElementById('reflectionSlope');
                    if (slopeEl2) slopeEl2.style.display = 'none';
                    break;
                case 'origin':
                    transformMatrix = {a: -1, b: 0, c: 0, d: -1};
                    const slopeEl3 = document.getElementById('reflectionSlope');
                    if (slopeEl3) slopeEl3.style.display = 'none';
                    break;
                case 'line':
                    const slopeEl4 = document.getElementById('reflectionSlope');
                    if (slopeEl4) slopeEl4.style.display = 'block';
                    const mEl = document.getElementById('reflectionM');
                    if (mEl) {
                        const m = parseFloat(mEl.value);
                        const denom = 1 + m * m;
                        transformMatrix = {
                            a: (1 - m*m) / denom, 
                            b: 2*m / denom,
                            c: 2*m / denom, 
                            d: (m*m - 1) / denom
                        };
                        const mValueEl = document.getElementById('reflectionMValue');
                        if (mValueEl) mValueEl.textContent = m.toFixed(1);
                    }
                    break;
            }
            
            updateMatrix();
        }
        
        function updateCustomTransformation() {
            const m11El = document.getElementById('m11');
            const m12El = document.getElementById('m12');
            const m21El = document.getElementById('m21');
            const m22El = document.getElementById('m22');
            
            if (!m11El || !m12El || !m21El || !m22El) return;
            
            transformMatrix = {
                a: parseFloat(m11El.value) || 0,
                b: parseFloat(m12El.value) || 0,
                c: parseFloat(m21El.value) || 0,
                d: parseFloat(m22El.value) || 0
            };
            
            updateMatrix();
        }
        
        function resetTransformation() {
            // Reset all sliders and inputs
            const elements = [
                'scaleX', 'scaleY', 'rotationAngle', 'shearX', 'shearY',
                'reflectionAxis', 'reflectionM', 'm11', 'm12', 'm21', 'm22',
                'vectorX', 'vectorY'
            ];
            
            const values = [1, 1, 0, 0, 0, 'x', 1, 1, 0, 0, 1, 2, 1];
            
            elements.forEach((id, index) => {
                const el = document.getElementById(id);
                if (el) el.value = values[index];
            });
            
            setTransformation('identity');
        }
        
        // Event listeners setup
        function setupEventListeners() {
            const buttonIds = ['identity', 'scale', 'rotation', 'shear', 'reflection', 'custom'];
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.addEventListener('click', () => setTransformation(id));
            });
            
            const sliderIds = [
                'scaleX', 'scaleY', 'rotationAngle', 'shearX', 'shearY', 'reflectionM',
                'm11', 'm12', 'm21', 'm22', 'vectorX', 'vectorY'
            ];
            
            const updateFunctions = [
                updateScaleTransformation, updateScaleTransformation, updateRotationTransformation,
                updateShearTransformation, updateShearTransformation, updateReflectionTransformation,
                updateCustomTransformation, updateCustomTransformation, updateCustomTransformation,
                updateCustomTransformation, draw, draw
            ];
            
            sliderIds.forEach((id, index) => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateFunctions[index]);
            });
            
            const reflAxis = document.getElementById('reflectionAxis');
            if (reflAxis) reflAxis.addEventListener('change', updateReflectionTransformation);
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            
            // Initialize canvas if in interactive section
            const interactiveSection = document.getElementById('interactive');
            if (interactiveSection && interactiveSection.classList.contains('active')) {
                setTimeout(() => {
                    initializeCanvas();
                    setTransformation('identity');
                }, 100);
            }
        });
    </script>
</body>
</html>