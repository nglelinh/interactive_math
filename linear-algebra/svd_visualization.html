<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singular Value Decomposition (SVD) - Theory & Interactive</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Navigation Styles */
        .nav-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .nav-tabs {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
        }

        .nav-tab {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-tab.active {
            color: #81c784;
            border-bottom-color: #81c784;
            background: rgba(129, 199, 132, 0.1);
        }

        /* Section Styles */
        .section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Theory Section Styles */
        .theory-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .theory-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
        }

        .theory-header h1 {
            font-size: 3em;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #81c784, #a5d6a7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .theory-header p {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.8);
        }

        .theory-section {
            margin-bottom: 40px;
            background: rgba(0, 0, 0, 0.2);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .theory-section h2 {
            color: #81c784;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(129, 199, 132, 0.3);
            padding-bottom: 10px;
        }

        .theory-section h3 {
            color: #a5d6a7;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .definition, .theorem, .example {
            background: rgba(129, 199, 132, 0.1);
            border-left: 4px solid #81c784;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .definition h4, .theorem h4, .example h4 {
            color: #81c784;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .applications-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .application-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(129, 199, 132, 0.3);
            transition: transform 0.3s ease;
        }

        .application-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(129, 199, 132, 0.2);
        }

        .application-card h4 {
            color: #81c784;
            margin-bottom: 10px;
        }

        /* Interactive Section Styles */
        .interactive-container {
            display: flex;
            height: calc(100vh - 60px);
            background: #111;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
        }
        
        canvas {
            background: #000;
            border: 1px solid #444;
        }
        
        .controls {
            width: 420px;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .control-section h3 {
            margin: 0 0 15px 0;
            color: #81c784;
            font-size: 16px;
        }

        .matrix-input {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .matrix-input input {
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        button {
            background: linear-gradient(45deg, #81c784, #a5d6a7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 3px;
            transition: transform 0.2s;
            font-size: 12px;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        .svd-display {
            background: rgba(129, 199, 132, 0.1);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .matrix-component {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .u-matrix {
            border-left: 3px solid #e74c3c;
        }
        
        .sigma-matrix {
            border-left: 3px solid #f39c12;
        }
        
        .v-matrix {
            border-left: 3px solid #2ecc71;
        }
        
        .toggle-button {
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
        }
        
        .toggle-button.active {
            background: #81c784;
            color: #000;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <div class="nav-container">
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showSection('theory')">📚 Theory</button>
            <button class="nav-tab" onclick="showSection('interactive')">🎮 Interactive</button>
        </div>
    </div>

    <!-- Theory Section -->
    <div id="theory" class="section active">
        <div class="theory-content">
            <div class="theory-header">
                <h1>Singular Value Decomposition (SVD)</h1>
                <p>The most powerful matrix factorization technique in machine learning and data science</p>
            </div>

            <div class="theory-section">
                <h2>1. Fundamental Concept</h2>
                
                <div class="definition">
                    <h4>Definition: Singular Value Decomposition</h4>
                    <p>For any $m \times n$ matrix $A$, the SVD is a factorization:</p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$A = U\Sigma V^T$$
                    </div>
                    <p>where:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>$U$:</strong> $m \times m$ orthogonal matrix (left singular vectors)</li>
                        <li><strong>$\Sigma$:</strong> $m \times n$ diagonal matrix (singular values)</li>
                        <li><strong>$V^T$:</strong> $n \times n$ orthogonal matrix (right singular vectors)</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Key Properties</h4>
                    <p><strong>Orthogonality:</strong> $U^TU = I$ and $V^TV = I$</p>
                    <p><strong>Singular Values:</strong> $\sigma_1 \geq \sigma_2 \geq \cdots \geq \sigma_r \geq 0$</p>
                    <p><strong>Rank:</strong> Number of non-zero singular values equals rank of $A$</p>
                    <p><strong>Universality:</strong> Every matrix has an SVD (unlike eigendecomposition!)</p>
                </div>

                <h3>Geometric Interpretation</h3>
                <div class="theorem">
                    <h4>Three-Step Transformation</h4>
                    <p>Any linear transformation can be decomposed into three steps:</p>
                    <ol style="margin: 10px 0 0 20px;">
                        <li><strong>$V^T$:</strong> Rotate in input space (align with principal axes)</li>
                        <li><strong>$\Sigma$:</strong> Scale along principal axes (stretch/compress)</li>
                        <li><strong>$U$:</strong> Rotate in output space (final orientation)</li>
                    </ol>
                    <p><strong>Intuition:</strong> Like aligning a 3D object, scaling it optimally, then rotating to final position!</p>
                </div>
            </div>

            <div class="theory-section">
                <h2>2. Computing the SVD</h2>

                <h3>Connection to Eigenvalue Decomposition</h3>
                <div class="theorem">
                    <h4>Key Relationships</h4>
                    <p>The SVD connects to eigenvalue problems:</p>
                    
                    <p><strong>For $A^TA$ (Gram matrix):</strong></p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$A^TA = V\Sigma^T\Sigma V^T = V\Lambda V^T$$
                    </div>
                    <p>where $\Lambda = \text{diag}(\sigma_1^2, \sigma_2^2, \ldots)$</p>
                    
                    <p><strong>For $AA^T$ (covariance-type matrix):</strong></p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$AA^T = U\Sigma\Sigma^T U^T = U\Lambda U^T$$
                    </div>
                    
                    <p><strong>Therefore:</strong> SVD singular values are square roots of eigenvalues!</p>
                </div>

                <div class="example">
                    <h4>Algorithm Outline</h4>
                    <ol style="margin: 10px 0 0 20px;">
                        <li><strong>Compute $A^TA$:</strong> Find right singular vectors $V$</li>
                        <li><strong>Find eigenvalues:</strong> $\sigma_i^2$ are eigenvalues of $A^TA$</li>
                        <li><strong>Compute $U$:</strong> Use $U = AV\Sigma^{-1}$ (for non-zero $\sigma_i$)</li>
                        <li><strong>Order by size:</strong> $\sigma_1 \geq \sigma_2 \geq \cdots$</li>
                    </ol>
                </div>

                <h3>Example: 2×2 Matrix</h3>
                <div class="example">
                    <h4>Let's decompose $A = \begin{pmatrix} 3 & 1 \\ 1 & 3 \end{pmatrix}$</h4>
                    
                    <p><strong>Step 1:</strong> Compute $A^TA$</p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$A^TA = \begin{pmatrix} 3 & 1 \\ 1 & 3 \end{pmatrix}\begin{pmatrix} 3 & 1 \\ 1 & 3 \end{pmatrix} = \begin{pmatrix} 10 & 6 \\ 6 & 10 \end{pmatrix}$$
                    </div>
                    
                    <p><strong>Step 2:</strong> Find eigenvalues of $A^TA$</p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$\det(A^TA - \lambda I) = (10-\lambda)^2 - 36 = 0$$
                        $$\lambda_1 = 16, \quad \lambda_2 = 4$$
                    </div>
                    
                    <p><strong>Step 3:</strong> Singular values and vectors</p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$\sigma_1 = 4, \quad \sigma_2 = 2$$
                        $$V = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$
                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h2>3. Low-Rank Approximation</h2>

                <div class="theorem">
                    <h4>Eckart-Young Theorem</h4>
                    <p>The best rank-$k$ approximation to matrix $A$ is:</p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$A_k = \sum_{i=1}^k \sigma_i u_i v_i^T$$
                    </div>
                    <p>This minimizes $\|A - A_k\|_F$ (Frobenius norm) over all rank-$k$ matrices!</p>
                </div>

                <div class="example">
                    <h4>Truncated SVD</h4>
                    <p>Keep only the $k$ largest singular values:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>$U_k$:</strong> First $k$ columns of $U$</li>
                        <li><strong>$\Sigma_k$:</strong> Top-left $k \times k$ block of $\Sigma$</li>
                        <li><strong>$V_k^T$:</strong> First $k$ rows of $V^T$</li>
                    </ul>
                    <p>Then $A_k = U_k\Sigma_k V_k^T$ is the optimal rank-$k$ approximation!</p>
                </div>

                <h3>Information Content</h3>
                <div class="definition">
                    <h4>Energy and Compression</h4>
                    <p>The <strong>energy</strong> captured by first $k$ components:</p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\text{Energy Ratio} = \frac{\sum_{i=1}^k \sigma_i^2}{\sum_{i=1}^r \sigma_i^2}$$
                    </div>
                    <p>This tells us how much information we retain with $k$ components!</p>
                    <p><strong>Storage:</strong> Original matrix: $mn$ numbers. SVD: $k(m+n+1)$ numbers.</p>
                </div>
            </div>

            <div class="theory-section">
                <h2>4. Applications in Machine Learning</h2>

                <div class="applications-grid">
                    <div class="application-card">
                        <h4>Principal Component Analysis (PCA)</h4>
                        <p><strong>Method:</strong> SVD of centered data matrix</p>
                        <p><strong>Result:</strong> $V$ gives principal components, $\Sigma$ gives explained variance</p>
                        <p><strong>Use:</strong> Dimensionality reduction, data visualization</p>
                    </div>

                    <div class="application-card">
                        <h4>Collaborative Filtering</h4>
                        <p><strong>Setup:</strong> User-item rating matrix with missing entries</p>
                        <p><strong>Method:</strong> Low-rank SVD approximation</p>
                        <p><strong>Result:</strong> Predicts missing ratings for recommendations</p>
                    </div>

                    <div class="application-card">
                        <h4>Image Compression</h4>
                        <p><strong>Method:</strong> SVD of image matrix (treat as grayscale)</p>
                        <p><strong>Compression:</strong> Keep only top $k$ singular values</p>
                        <p><strong>Trade-off:</strong> Quality vs storage size</p>
                    </div>

                    <div class="application-card">
                        <h4>Latent Semantic Analysis (LSA)</h4>
                        <p><strong>Setup:</strong> Document-term matrix</p>
                        <p><strong>Method:</strong> SVD to find latent topics</p>
                        <p><strong>Result:</strong> Semantic relationships between documents</p>
                    </div>

                    <div class="application-card">
                        <h4>Pseudoinverse</h4>
                        <p><strong>Moore-Penrose Inverse:</strong> $A^+ = V\Sigma^+ U^T$</p>
                        <p><strong>$\Sigma^+$:</strong> Transpose with reciprocals of non-zero values</p>
                        <p><strong>Use:</strong> Solving least squares, overdetermined systems</p>
                    </div>

                    <div class="application-card">
                        <h4>Noise Reduction</h4>
                        <p><strong>Principle:</strong> Signal lives in low-dimensional subspace</p>
                        <p><strong>Method:</strong> Project onto top singular vectors</p>
                        <p><strong>Applications:</strong> Signal processing, image denoising</p>
                    </div>
                </div>

                <div class="example">
                    <h4>PCA via SVD Example</h4>
                    <p><strong>Data Matrix:</strong> $X$ with $n$ samples, $p$ features</p>
                    <ol style="margin: 10px 0 0 20px;">
                        <li><strong>Center data:</strong> $\tilde{X} = X - \mu$ (subtract mean)</li>
                        <li><strong>Compute SVD:</strong> $\tilde{X} = U\Sigma V^T$</li>
                        <li><strong>Principal components:</strong> Columns of $V$</li>
                        <li><strong>Projected data:</strong> $Y = \tilde{X}V_k$ (first $k$ components)</li>
                        <li><strong>Explained variance:</strong> $\sigma_i^2/(n-1)$ for component $i$</li>
                    </ol>
                    <p><strong>Why SVD > Eigendecomposition?</strong> More numerically stable, works for non-square matrices!</p>
                </div>
            </div>

            <div class="theory-section">
                <h2>5. Advanced Properties</h2>

                <h3>Matrix Norms and SVD</h3>
                <div class="theorem">
                    <h4>Norm Relationships</h4>
                    <p>SVD reveals matrix norms:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Operator norm:</strong> $\|A\|_2 = \sigma_1$ (largest singular value)</li>
                        <li><strong>Frobenius norm:</strong> $\|A\|_F = \sqrt{\sum_i \sigma_i^2}$</li>
                        <li><strong>Nuclear norm:</strong> $\|A\|_* = \sum_i \sigma_i$ (sum of singular values)</li>
                    </ul>
                </div>

                <h3>Condition Number</h3>
                <div class="definition">
                    <h4>Matrix Conditioning</h4>
                    <p>The <strong>condition number</strong> measures how sensitive solutions are to input changes:</p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$\kappa(A) = \frac{\sigma_1}{\sigma_r}$$
                    </div>
                    <p>where $\sigma_r$ is the smallest non-zero singular value.</p>
                    <p><strong>Interpretation:</strong> Large $\kappa(A)$ means matrix is nearly singular (ill-conditioned)!</p>
                </div>

                <h3>Matrix Rank and Nullspace</h3>
                <div class="theorem">
                    <h4>Fundamental Spaces</h4>
                    <p>SVD reveals the four fundamental subspaces:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Column space:</strong> Span of first $r$ columns of $U$</li>
                        <li><strong>Row space:</strong> Span of first $r$ columns of $V$</li>
                        <li><strong>Null space:</strong> Span of last $n-r$ columns of $V$</li>
                        <li><strong>Left null space:</strong> Span of last $m-r$ columns of $U$</li>
                    </ul>
                    <p>where $r$ is the rank (number of non-zero singular values).</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Interactive Section -->
    <div id="interactive" class="section">
        <div class="interactive-container">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-section">
                    <h3>Matrix Input (2×2)</h3>
                    <div class="matrix-input">
                        <input type="number" id="a11" value="3" step="0.1">
                        <input type="number" id="a12" value="1" step="0.1">
                        <input type="number" id="a21" value="1" step="0.1">
                        <input type="number" id="a22" value="3" step="0.1">
                    </div>
                    <div class="preset-buttons">
                        <button onclick="loadPreset('identity')">Identity</button>
                        <button onclick="loadPreset('stretch')">Stretch</button>
                        <button onclick="loadPreset('rotation')">Rotation</button>
                        <button onclick="loadPreset('shear')">Shear</button>
                        <button onclick="loadPreset('random')">Random</button>
                        <button onclick="loadPreset('singular')">Singular</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Current Matrix A</h3>
                    <div class="svd-display">
                        A = [<span id="matrix-a11">3.0</span>  <span id="matrix-a12">1.0</span>]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;[<span id="matrix-a21">1.0</span>  <span id="matrix-a22">3.0</span>]
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>SVD Components</h3>
                    
                    <div class="matrix-component u-matrix">
                        <h4>U (Left Singular Vectors)</h4>
                        <div class="svd-display">
                            U = [<span id="u11">0.71</span>  <span id="u12">0.71</span>]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;[<span id="u21">0.71</span>  <span id="u22">-0.71</span>]
                        </div>
                    </div>
                    
                    <div class="matrix-component sigma-matrix">
                        <h4>Σ (Singular Values)</h4>
                        <div class="svd-display">
                            Σ = [<span id="sigma1">4.0</span>   0.0]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;[0.0   <span id="sigma2">2.0</span>]
                        </div>
                    </div>
                    
                    <div class="matrix-component v-matrix">
                        <h4>V^T (Right Singular Vectors)</h4>
                        <div class="svd-display">
                            V^T = [<span id="vt11">0.71</span>  <span id="vt12">0.71</span>]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span id="vt21">0.71</span>  <span id="vt22">-0.71</span>]
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Visualization Options</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                        <button class="toggle-button active" id="showOriginal" onclick="toggleVisualization('original')">Original Vectors</button>
                        <button class="toggle-button active" id="showTransformed" onclick="toggleVisualization('transformed')">Transformed</button>
                        <button class="toggle-button active" id="showSingularVectors" onclick="toggleVisualization('singular')">Singular Vectors</button>
                        <button class="toggle-button" id="showSteps" onclick="toggleVisualization('steps')">Show Steps</button>
                        <button class="toggle-button" id="showGrid" onclick="toggleVisualization('grid')">Transform Grid</button>
                        <button class="toggle-button" id="showCircle" onclick="toggleVisualization('circle')">Unit Circle</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Matrix Properties</h3>
                    <div class="svd-display">
                        Rank: <span id="rank">2</span><br>
                        Condition Number: <span id="condition">2.0</span><br>
                        Determinant: <span id="determinant">8.0</span><br>
                        Frobenius Norm: <span id="frobenius">4.47</span>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Low-Rank Approximation</h3>
                    <button onclick="showApproximation(1)">Rank-1 Approx</button>
                    <button onclick="showApproximation(2)">Full Rank</button>
                    <div class="svd-display" style="margin-top: 10px;">
                        Energy Ratio: <span id="energy-ratio">100%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        // Navigation functions
        function showSection(sectionName) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Initialize canvas when interactive section is shown
            if (sectionName === 'interactive' && !window.canvasInitialized) {
                initializeCanvas();
                window.canvasInitialized = true;
            }
        }

        // Canvas and visualization variables
        let canvas, ctx;
        let visualization = {
            original: true,
            transformed: true,
            singular: true,
            steps: false,
            grid: false,
            circle: false
        };
        
        // Matrix and SVD components
        let matrix = { a11: 3, a12: 1, a21: 1, a22: 3 };
        let svd = {
            U: [[0, 0], [0, 0]],
            Sigma: [0, 0],
            VT: [[0, 0], [0, 0]]
        };

        function initializeCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set up event listeners for matrix inputs
            ['a11', 'a12', 'a21', 'a22'].forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', updateMatrix);
            });
            
            updateMatrix();
            draw();
        }

        function updateMatrix() {
            // Get matrix values from inputs
            matrix.a11 = parseFloat(document.getElementById('a11').value) || 0;
            matrix.a12 = parseFloat(document.getElementById('a12').value) || 0;
            matrix.a21 = parseFloat(document.getElementById('a21').value) || 0;
            matrix.a22 = parseFloat(document.getElementById('a22').value) || 0;
            
            // Update matrix display
            document.getElementById('matrix-a11').textContent = matrix.a11.toFixed(1);
            document.getElementById('matrix-a12').textContent = matrix.a12.toFixed(1);
            document.getElementById('matrix-a21').textContent = matrix.a21.toFixed(1);
            document.getElementById('matrix-a22').textContent = matrix.a22.toFixed(1);
            
            // Compute SVD
            computeSVD();
            updateDisplays();
            draw();
        }

        function computeSVD() {
            const A = [
                [matrix.a11, matrix.a12],
                [matrix.a21, matrix.a22]
            ];
            
            // Compute A^T * A
            const ATA = [
                [A[0][0]*A[0][0] + A[1][0]*A[1][0], A[0][0]*A[0][1] + A[1][0]*A[1][1]],
                [A[0][1]*A[0][0] + A[1][1]*A[1][0], A[0][1]*A[0][1] + A[1][1]*A[1][1]]
            ];
            
            // Compute eigenvalues of A^T * A
            const trace = ATA[0][0] + ATA[1][1];
            const det = ATA[0][0] * ATA[1][1] - ATA[0][1] * ATA[1][0];
            const discriminant = trace * trace - 4 * det;
            
            let lambda1, lambda2;
            if (discriminant >= 0) {
                lambda1 = (trace + Math.sqrt(discriminant)) / 2;
                lambda2 = (trace - Math.sqrt(discriminant)) / 2;
            } else {
                lambda1 = lambda2 = trace / 2;
            }
            
            // Singular values
            svd.Sigma[0] = Math.sqrt(Math.max(0, lambda1));
            svd.Sigma[1] = Math.sqrt(Math.max(0, lambda2));
            
            // Compute V (eigenvectors of A^T * A)
            if (Math.abs(ATA[0][1]) > 1e-10) {
                // First eigenvector
                let v1x = 1;
                let v1y = (lambda1 - ATA[0][0]) / ATA[0][1];
                let norm1 = Math.sqrt(v1x * v1x + v1y * v1y);
                svd.VT[0][0] = v1x / norm1;
                svd.VT[1][0] = v1y / norm1;
                
                // Second eigenvector
                let v2x = 1;
                let v2y = (lambda2 - ATA[0][0]) / ATA[0][1];
                let norm2 = Math.sqrt(v2x * v2x + v2y * v2y);
                svd.VT[0][1] = v2x / norm2;
                svd.VT[1][1] = v2y / norm2;
            } else {
                // Diagonal case
                svd.VT[0][0] = 1; svd.VT[1][0] = 0;
                svd.VT[0][1] = 0; svd.VT[1][1] = 1;
            }
            
            // Compute U = A * V * Sigma^(-1)
            for (let i = 0; i < 2; i++) {
                if (svd.Sigma[i] > 1e-10) {
                    let ux = (A[0][0] * svd.VT[0][i] + A[0][1] * svd.VT[1][i]) / svd.Sigma[i];
                    let uy = (A[1][0] * svd.VT[0][i] + A[1][1] * svd.VT[1][i]) / svd.Sigma[i];
                    svd.U[0][i] = ux;
                    svd.U[1][i] = uy;
                } else {
                    svd.U[0][i] = 1;
                    svd.U[1][i] = 0;
                }
            }
        }

        function updateDisplays() {
            // Update SVD component displays
            document.getElementById('u11').textContent = svd.U[0][0].toFixed(2);
            document.getElementById('u12').textContent = svd.U[0][1].toFixed(2);
            document.getElementById('u21').textContent = svd.U[1][0].toFixed(2);
            document.getElementById('u22').textContent = svd.U[1][1].toFixed(2);
            
            document.getElementById('sigma1').textContent = svd.Sigma[0].toFixed(2);
            document.getElementById('sigma2').textContent = svd.Sigma[1].toFixed(2);
            
            document.getElementById('vt11').textContent = svd.VT[0][0].toFixed(2);
            document.getElementById('vt12').textContent = svd.VT[0][1].toFixed(2);
            document.getElementById('vt21').textContent = svd.VT[1][0].toFixed(2);
            document.getElementById('vt22').textContent = svd.VT[1][1].toFixed(2);
            
            // Update matrix properties
            const rank = (svd.Sigma[0] > 1e-10 ? 1 : 0) + (svd.Sigma[1] > 1e-10 ? 1 : 0);
            const condition = svd.Sigma[1] > 1e-10 ? svd.Sigma[0] / svd.Sigma[1] : Infinity;
            const determinant = matrix.a11 * matrix.a22 - matrix.a12 * matrix.a21;
            const frobenius = Math.sqrt(svd.Sigma[0] * svd.Sigma[0] + svd.Sigma[1] * svd.Sigma[1]);
            
            document.getElementById('rank').textContent = rank;
            document.getElementById('condition').textContent = isFinite(condition) ? condition.toFixed(2) : '∞';
            document.getElementById('determinant').textContent = determinant.toFixed(2);
            document.getElementById('frobenius').textContent = frobenius.toFixed(2);
        }

        function draw() {
            if (!ctx) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set up coordinate system
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(1, -1); // Flip y-axis
            
            const scale = 60;
            
            // Draw grid if enabled
            if (visualization.grid) {
                drawTransformedGrid(scale);
            }
            
            // Draw unit circle if enabled
            if (visualization.circle) {
                drawTransformedCircle(scale);
            }
            
            // Draw coordinate axes
            drawAxes(scale);
            
            // Draw vectors and transformations
            if (visualization.original) {
                drawOriginalVectors(scale);
            }
            
            if (visualization.transformed) {
                drawTransformedVectors(scale);
            }
            
            if (visualization.singular) {
                drawSingularVectors(scale);
            }
            
            ctx.restore();
        }

        function drawAxes(scale) {
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                
                ctx.beginPath();
                ctx.moveTo(i * scale, -canvas.height);
                ctx.lineTo(i * scale, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(-canvas.width, i * scale);
                ctx.lineTo(canvas.width, i * scale);
                ctx.stroke();
            }
            
            // Main axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(-canvas.width, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, -canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();
        }

        function drawOriginalVectors(scale) {
            const vectors = [
                [1, 0], [0, 1], [1, 1], [-1, 1]
            ];
            
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            
            vectors.forEach(v => {
                drawArrow(0, 0, v[0] * scale, v[1] * scale);
            });
        }

        function drawTransformedVectors(scale) {
            const vectors = [
                [1, 0], [0, 1], [1, 1], [-1, 1]
            ];
            
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            
            vectors.forEach(v => {
                const tx = matrix.a11 * v[0] + matrix.a12 * v[1];
                const ty = matrix.a21 * v[0] + matrix.a22 * v[1];
                drawArrow(0, 0, tx * scale, ty * scale);
            });
        }

        function drawSingularVectors(scale) {
            ctx.lineWidth = 3;
            
            // Right singular vectors (V)
            ctx.strokeStyle = '#2ecc71';
            drawArrow(0, 0, svd.VT[0][0] * scale * 1.5, svd.VT[1][0] * scale * 1.5);
            drawArrow(0, 0, svd.VT[0][1] * scale * 1.5, svd.VT[1][1] * scale * 1.5);
            
            // Left singular vectors (U), scaled by singular values
            ctx.strokeStyle = '#e74c3c';
            drawArrow(0, 0, svd.U[0][0] * svd.Sigma[0] * scale * 0.3, svd.U[1][0] * svd.Sigma[0] * scale * 0.3);
            drawArrow(0, 0, svd.U[0][1] * svd.Sigma[1] * scale * 0.3, svd.U[1][1] * svd.Sigma[1] * scale * 0.3);
        }

        function drawArrow(x1, y1, x2, y2) {
            const headSize = 8;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Draw arrowhead
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - headSize * Math.cos(angle - Math.PI / 6),
                y2 - headSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - headSize * Math.cos(angle + Math.PI / 6),
                y2 - headSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }

        function drawTransformedGrid(scale) {
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = -3; i <= 3; i++) {
                for (let j = -3; j <= 3; j++) {
                    const x = i * scale * 0.5;
                    const y = j * scale * 0.5;
                    
                    const tx = matrix.a11 * x + matrix.a12 * y;
                    const ty = matrix.a21 * x + matrix.a22 * y;
                    
                    if (i < 3) {
                        const x2 = (i + 1) * scale * 0.5;
                        const y2 = j * scale * 0.5;
                        const tx2 = matrix.a11 * x2 + matrix.a12 * y2;
                        const ty2 = matrix.a21 * x2 + matrix.a22 * y2;
                        
                        ctx.beginPath();
                        ctx.moveTo(tx, ty);
                        ctx.lineTo(tx2, ty2);
                        ctx.stroke();
                    }
                    
                    if (j < 3) {
                        const x2 = i * scale * 0.5;
                        const y2 = (j + 1) * scale * 0.5;
                        const tx2 = matrix.a11 * x2 + matrix.a12 * y2;
                        const ty2 = matrix.a21 * x2 + matrix.a22 * y2;
                        
                        ctx.beginPath();
                        ctx.moveTo(tx, ty);
                        ctx.lineTo(tx2, ty2);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawTransformedCircle(scale) {
            ctx.strokeStyle = 'rgba(255, 255, 100, 0.6)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * 2 * Math.PI;
                const x = Math.cos(theta) * scale * 0.8;
                const y = Math.sin(theta) * scale * 0.8;
                
                const tx = matrix.a11 * x + matrix.a12 * y;
                const ty = matrix.a21 * x + matrix.a22 * y;
                
                if (i === 0) {
                    ctx.moveTo(tx, ty);
                } else {
                    ctx.lineTo(tx, ty);
                }
            }
            ctx.stroke();
            
            // Original circle
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, scale * 0.8, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function toggleVisualization(type) {
            visualization[type] = !visualization[type];
            const button = document.getElementById('show' + type.charAt(0).toUpperCase() + type.slice(1));
            button.classList.toggle('active');
            draw();
        }

        function loadPreset(type) {
            const presets = {
                identity: { a11: 1, a12: 0, a21: 0, a22: 1 },
                stretch: { a11: 2, a12: 0, a21: 0, a22: 0.5 },
                rotation: { a11: 0.8, a12: -0.6, a21: 0.6, a22: 0.8 },
                shear: { a11: 1, a12: 1, a21: 0, a22: 1 },
                random: { 
                    a11: (Math.random() - 0.5) * 4, 
                    a12: (Math.random() - 0.5) * 4,
                    a21: (Math.random() - 0.5) * 4,
                    a22: (Math.random() - 0.5) * 4
                },
                singular: { a11: 2, a12: 1, a21: 4, a22: 2 }
            };
            
            const preset = presets[type];
            if (preset) {
                Object.keys(preset).forEach(key => {
                    document.getElementById(key).value = preset[key].toFixed(1);
                });
                updateMatrix();
            }
        }

        function showApproximation(rank) {
            // This would show the rank-k approximation
            // For now, just update the energy ratio display
            let energyRatio;
            if (rank === 1) {
                const totalEnergy = svd.Sigma[0] * svd.Sigma[0] + svd.Sigma[1] * svd.Sigma[1];
                energyRatio = totalEnergy > 0 ? (svd.Sigma[0] * svd.Sigma[0] / totalEnergy * 100) : 0;
            } else {
                energyRatio = 100;
            }
            document.getElementById('energy-ratio').textContent = energyRatio.toFixed(1) + '%';
        }
    </script>
</body>
</html>
            border-radius: 5px;
            font-size: 12px;
            max-width: 350px;
            z-index: 10;
        }
        
        .legend {
            font-size: 11px;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .legend-item {
            margin: 3px 0;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 12px;
            color: #0ff;
            text-align: right;
            margin-top: 2px;
        }
        
        .step-display {
            background: rgba(255, 255, 0, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 13px;
            border-left: 3px solid #ffff00;
        }
    </style>





</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div class="info-panel">
                <strong>🔍 SVD Decomposition</strong><br/>
                Interactive exploration of A = UΣV^T decomposition showing rotation-scaling-rotation.
                <div class="legend">
                    <div class="legend-item" style="color: #0ff;">🔵 Unit Circle (Original)</div>
                    <div class="legend-item" style="color: #e74c3c;">🔴 Step 1: V^T (Rotation)</div>
                    <div class="legend-item" style="color: #f39c12;">🟠 Step 2: Σ (Scaling)</div>
                    <div class="legend-item" style="color: #2ecc71;">🟢 Step 3: U (Final Rotation)</div>
                    <div class="legend-item" style="color: #9b59b6;">🟣 Singular Vectors</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>2×2 Matrix Input</h3>
                <div class="matrix-input">
                    <input type="number" id="a11" step="0.1" value="3" placeholder="a₁₁">
                    <input type="number" id="a12" step="0.1" value="1" placeholder="a₁₂">
                    <input type="number" id="a21" step="0.1" value="1" placeholder="a₂₁">
                    <input type="number" id="a22" step="0.1" value="2" placeholder="a₂₂">
                </div>
                <div class="preset-buttons">
                    <button onclick="loadPreset('identity')">Identity</button>
                    <button onclick="loadPreset('scale')">Scale</button>
                    <button onclick="loadPreset('rotation')">Rotation</button>
                    <button onclick="loadPreset('shear')">Shear</button>
                    <button onclick="loadPreset('asymmetric')">Asymmetric</button>
                    <button onclick="loadPreset('singular')">Near-Singular</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>SVD Decomposition: A = UΣV^T</h3>
                <div id="svd-display" class="svd-display">
                    <!-- SVD components will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>Step-by-Step Animation</h3>
                <div class="step-display" id="step-display">
                    Step 1: Apply V^T (First Rotation)
                </div>
                <div class="slider-group">
                    <label>Animation Progress:</label>
                    <input type="range" id="animProgress" min="0" max="3" step="0.05" value="3">
                    <div class="slider-value" id="animProgressValue">Complete (3.0)</div>
                </div>
                <div class="toggle-section">
                    <div class="toggle-button" id="toggle-animation" onclick="toggleAnimation()">
                        ▶ Auto Play
                    </div>
                    <div class="toggle-button" onclick="resetAnimation()">
                        🔄 Reset
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visualization Options</h3>
                <div class="toggle-section">
                    <div class="toggle-button active" id="toggle-steps" onclick="toggleVisualization('steps')">
                        Show Steps
                    </div>
                    <div class="toggle-button active" id="toggle-vectors" onclick="toggleVisualization('vectors')">
                        Singular Vectors
                    </div>
                    <div class="toggle-button active" id="toggle-grid" onclick="toggleVisualization('grid')">
                        Grid Lines
                    </div>
                    <div class="toggle-button active" id="toggle-labels" onclick="toggleVisualization('labels')">
                        Labels
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 80;
        
        // Matrix elements
        let matrix = {
            a11: 3, a12: 1,
            a21: 1, a22: 2
        };
        
        // SVD components
        let svdData = {
            U: [[1, 0], [0, 1]],
            S: [1, 1],
            VT: [[1, 0], [0, 1]]
        };
        
        // Animation state
        let animationId = null;
        let animationProgress = 3;
        let isAnimating = false;
        let animationSpeed = 0.02;
        
        // Visualization options
        let showOptions = {
            steps: true,
            vectors: true,
            grid: true,
            labels: true
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function matrixMultiply(A, B) {
            return [
                [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
                [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
            ];
        }
        
        function applyMatrix(point, mat) {
            if (Array.isArray(mat)) {
                // 2x2 matrix format
                return {
                    x: mat[0][0] * point.x + mat[0][1] * point.y,
                    y: mat[1][0] * point.x + mat[1][1] * point.y
                };
            } else {
                // Object format
                return {
                    x: mat.a11 * point.x + mat.a12 * point.y,
                    y: mat.a21 * point.x + mat.a22 * point.y
                };
            }
        }
        
        function calculateSVD() {
            const a = matrix.a11;
            const b = matrix.a12;
            const c = matrix.a21;
            const d = matrix.a22;
            
            // Compute A^T * A
            const ATA = [
                [a*a + c*c, a*b + c*d],
                [a*b + c*d, b*b + d*d]
            ];
            
            // Eigenvalues of A^T * A
            const trace = ATA[0][0] + ATA[1][1];
            const det = ATA[0][0] * ATA[1][1] - ATA[0][1] * ATA[1][0];
            const discriminant = trace * trace - 4 * det;
            
            let lambda1, lambda2;
            if (discriminant >= 0) {
                const sqrt_disc = Math.sqrt(discriminant);
                lambda1 = (trace + sqrt_disc) / 2;
                lambda2 = (trace - sqrt_disc) / 2;
            } else {
                lambda1 = trace / 2;
                lambda2 = trace / 2;
            }
            
            // Singular values
            const s1 = Math.sqrt(Math.max(0, lambda1));
            const s2 = Math.sqrt(Math.max(0, lambda2));
            
            // V matrix (eigenvectors of A^T * A)
            let v1 = [1, 0];
            let v2 = [0, 1];
            
            if (Math.abs(ATA[0][1]) > 1e-10) {
                const ratio1 = (lambda1 - ATA[0][0]) / ATA[0][1];
                const norm1 = Math.sqrt(1 + ratio1 * ratio1);
                v1 = [1 / norm1, ratio1 / norm1];
                
                const ratio2 = (lambda2 - ATA[0][0]) / ATA[0][1];
                const norm2 = Math.sqrt(1 + ratio2 * ratio2);
                v2 = [1 / norm2, ratio2 / norm2];
            } else if (lambda1 !== lambda2) {
                if (Math.abs(lambda1 - ATA[0][0]) < 1e-10) {
                    v1 = [1, 0];
                    v2 = [0, 1];
                } else {
                    v1 = [0, 1];
                    v2 = [1, 0];
                }
            }
            
            const V = [v1, v2];
            const VT = [[V[0][0], V[1][0]], [V[0][1], V[1][1]]]; // Transpose
            
            // U matrix calculation
            let u1 = [1, 0];
            let u2 = [0, 1];
            
            if (s1 > 1e-10) {
                const Av1 = [a * v1[0] + b * v1[1], c * v1[0] + d * v1[1]];
                const norm = Math.sqrt(Av1[0] * Av1[0] + Av1[1] * Av1[1]);
                u1 = [Av1[0] / norm, Av1[1] / norm];
            }
            
            if (s2 > 1e-10) {
                const Av2 = [a * v2[0] + b * v2[1], c * v2[0] + d * v2[1]];
                const norm = Math.sqrt(Av2[0] * Av2[0] + Av2[1] * Av2[1]);
                u2 = [Av2[0] / norm, Av2[1] / norm];
            }
            
            // Ensure proper orientation
            if (u1[0] * u2[1] - u1[1] * u2[0] < 0) {
                u2 = [-u2[0], -u2[1]];
            }
            
            const U = [[u1[0], u2[0]], [u1[1], u2[1]]];
            
            svdData = {
                U: U,
                S: [s1, s2],
                VT: VT
            };
            
            updateSVDDisplay();
        }
        
        function updateSVDDisplay() {
            const display = document.getElementById('svd-display');
            const U = svdData.U;
            const S = svdData.S;
            const VT = svdData.VT;
            
            const html = `
                <div class="matrix-component u-matrix">
                    <strong>U (Final Rotation)</strong><br/>
                    [${U[0][0].toFixed(3)}  ${U[0][1].toFixed(3)}]<br/>
                    [${U[1][0].toFixed(3)}  ${U[1][1].toFixed(3)}]
                </div>
                <div class="matrix-component sigma-matrix">
                    <strong>Σ (Scaling)</strong><br/>
                    [${S[0].toFixed(3)}  0.000]<br/>
                    [0.000  ${S[1].toFixed(3)}]
                </div>
                <div class="matrix-component v-matrix">
                    <strong>V^T (First Rotation)</strong><br/>
                    [${VT[0][0].toFixed(3)}  ${VT[0][1].toFixed(3)}]<br/>
                    [${VT[1][0].toFixed(3)}  ${VT[1][1].toFixed(3)}]
                </div>
            `;
            
            display.innerHTML = html;
        }
        
        function drawGrid() {
            if (!showOptions.grid) return;
            
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -10; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawCircle(transformation = null, color = '#0ff', lineWidth = 2) {
            const numPoints = 100;
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                let point = { x: Math.cos(angle), y: Math.sin(angle) };
                
                if (transformation) {
                    point = applyMatrix(point, transformation);
                }
                
                points.push(point);
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (i === 0) {
                    ctx.moveTo(toCanvasX(p.x), toCanvasY(p.y));
                } else {
                    ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
                }
            }
            
            ctx.closePath();
            ctx.stroke();
        }
        
        function drawArrow(from, to, color, lineWidth = 2) {
            const fromX = toCanvasX(from.x);
            const fromY = toCanvasY(from.y);
            const toX = toCanvasX(to.x);
            const toY = toCanvasY(to.y);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            
            // Arrow body
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLength = 8;
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }
        
        function drawSingularVectors() {
            if (!showOptions.vectors) return;
            
            const U = svdData.U;
            const VT = svdData.VT;
            const S = svdData.S;
            
            // Draw V vectors (right singular vectors)
            const v1 = { x: VT[0][0], y: VT[1][0] };
            const v2 = { x: VT[0][1], y: VT[1][1] };
            
            drawArrow({ x: 0, y: 0 }, { x: v1.x * 1.5, y: v1.y * 1.5 }, '#2ecc71', 2);
            drawArrow({ x: 0, y: 0 }, { x: v2.x * 1.5, y: v2.y * 1.5 }, '#2ecc71', 2);
            
            // Draw U vectors (left singular vectors)
            const u1 = { x: U[0][0] * S[0], y: U[1][0] * S[0] };
            const u2 = { x: U[0][1] * S[1], y: U[1][1] * S[1] };
            
            drawArrow({ x: 0, y: 0 }, { x: u1.x * 0.8, y: u1.y * 0.8 }, '#e74c3c', 2);
            drawArrow({ x: 0, y: 0 }, { x: u2.x * 0.8, y: u2.y * 0.8 }, '#e74c3c', 2);
            
            if (showOptions.labels) {
                ctx.fillStyle = '#2ecc71';
                ctx.font = '12px Arial';
                ctx.fillText('v₁', toCanvasX(v1.x * 1.7), toCanvasY(v1.y * 1.7));
                ctx.fillText('v₂', toCanvasX(v2.x * 1.7), toCanvasY(v2.y * 1.7));
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillText('σ₁u₁', toCanvasX(u1.x * 0.9), toCanvasY(u1.y * 0.9));
                ctx.fillText('σ₂u₂', toCanvasX(u2.x * 0.9), toCanvasY(u2.y * 0.9));
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            
            // Draw original unit circle
            drawCircle(null, '#0ff', 2);
            
            if (showOptions.steps) {
                const progress = animationProgress;
                
                if (progress >= 1) {
                    // Step 1: Apply V^T
                    drawCircle(svdData.VT, '#e74c3c', 2);
                }
                
                if (progress >= 2) {
                    // Step 2: Apply Σ (scaling)
                    const sigma = [[svdData.S[0], 0], [0, svdData.S[1]]];
                    const step2Matrix = matrixMultiply(sigma, svdData.VT);
                    drawCircle(step2Matrix, '#f39c12', 2);
                }
                
                if (progress >= 3) {
                    // Step 3: Apply U (final transformation)
                    drawCircle(matrix, '#2ecc71', 3);
                }
                
                // Intermediate steps for smooth animation
                if (progress > 0 && progress < 1) {
                    const t = progress;
                    const interpolatedVT = [
                        [1 + t * (svdData.VT[0][0] - 1), t * svdData.VT[0][1]],
                        [t * svdData.VT[1][0], 1 + t * (svdData.VT[1][1] - 1)]
                    ];
                    drawCircle(interpolatedVT, '#e74c3c', 2);
                } else if (progress > 1 && progress < 2) {
                    const t = progress - 1;
                    const sigma = [[1 + t * (svdData.S[0] - 1), 0], [0, 1 + t * (svdData.S[1] - 1)]];
                    const step2Matrix = matrixMultiply(sigma, svdData.VT);
                    drawCircle(step2Matrix, '#f39c12', 2);
                } else if (progress > 2 && progress < 3) {
                    const t = progress - 2;
                    const sigma = [[svdData.S[0], 0], [0, svdData.S[1]]];
                    const step2Matrix = matrixMultiply(sigma, svdData.VT);
                    const partialU = [
                        [1 + t * (svdData.U[0][0] - 1), t * svdData.U[0][1]],
                        [t * svdData.U[1][0], 1 + t * (svdData.U[1][1] - 1)]
                    ];
                    const step3Matrix = matrixMultiply(partialU, step2Matrix);
                    drawCircle(step3Matrix, '#2ecc71', 3);
                }
            } else {
                // Just show final transformation
                drawCircle(matrix, '#2ecc71', 3);
            }
            
            drawSingularVectors();
        }
        
        function updateStepDisplay() {
            const progress = animationProgress;
            const display = document.getElementById('step-display');
            
            if (progress < 1) {
                display.textContent = "Step 1: Apply V^T (First Rotation)";
                display.style.borderLeftColor = "#e74c3c";
            } else if (progress < 2) {
                display.textContent = "Step 2: Apply Σ (Scaling)";
                display.style.borderLeftColor = "#f39c12";
            } else if (progress < 3) {
                display.textContent = "Step 3: Apply U (Final Rotation)";
                display.style.borderLeftColor = "#2ecc71";
            } else {
                display.textContent = "Complete: A = UΣV^T";
                display.style.borderLeftColor = "#0ff";
            }
        }
        
        function updateMatrix() {
            matrix.a11 = parseFloat(document.getElementById('a11').value) || 0;
            matrix.a12 = parseFloat(document.getElementById('a12').value) || 0;
            matrix.a21 = parseFloat(document.getElementById('a21').value) || 0;
            matrix.a22 = parseFloat(document.getElementById('a22').value) || 0;
            
            calculateSVD();
            draw();
        }
        
        function loadPreset(type) {
            const presets = {
                identity: [1, 0, 0, 1],
                scale: [2, 0, 0, 0.5],
                rotation: [0.707, -0.707, 0.707, 0.707],
                shear: [1, 0.5, 0.3, 1],
                asymmetric: [2, 1, 0.5, 1.5],
                singular: [2, 1, 2, 1]
            };
            
            const values = presets[type];
            document.getElementById('a11').value = values[0];
            document.getElementById('a12').value = values[1];
            document.getElementById('a21').value = values[2];
            document.getElementById('a22').value = values[3];
            
            updateMatrix();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const button = document.getElementById('toggle-animation');
            
            if (isAnimating) {
                button.textContent = '⏸ Pause';
                animate();
            } else {
                button.textContent = '▶ Auto Play';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        function animate() {
            if (!isAnimating) return;
            
            animationProgress += animationSpeed;
            if (animationProgress > 3) {
                animationProgress = 0;
            }
            
            document.getElementById('animProgress').value = animationProgress;
            document.getElementById('animProgressValue').textContent = 
                animationProgress === 3 ? 'Complete (3.0)' : `Step ${Math.floor(animationProgress) + 1} (${animationProgress.toFixed(2)})`;
            
            updateStepDisplay();
            draw();
            
            animationId = requestAnimationFrame(animate);
        }
        
        function resetAnimation() {
            isAnimating = false;
            animationProgress = 0;
            document.getElementById('toggle-animation').textContent = '▶ Auto Play';
            document.getElementById('animProgress').value = 0;
            document.getElementById('animProgressValue').textContent = 'Step 1 (0.00)';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            updateStepDisplay();
            draw();
        }
        
        // Event listeners
        document.getElementById('a11').addEventListener('input', updateMatrix);
        document.getElementById('a12').addEventListener('input', updateMatrix);
        document.getElementById('a21').addEventListener('input', updateMatrix);
        document.getElementById('a22').addEventListener('input', updateMatrix);
        
        document.getElementById('animProgress').addEventListener('input', function() {
            animationProgress = parseFloat(this.value);
            document.getElementById('animProgressValue').textContent = 
                animationProgress === 3 ? 'Complete (3.0)' : `Step ${Math.floor(animationProgress) + 1} (${animationProgress.toFixed(2)})`;
            updateStepDisplay();
            draw();
        });
        
        // Initialize
        updateMatrix();
        updateStepDisplay();
        draw();
    </script>
</body>
</html>
