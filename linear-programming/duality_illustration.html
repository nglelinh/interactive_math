<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minh h·ªça Duality trong Linear Programming</title>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin: 0;
            padding: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-size: 2.5em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        
        label {
            min-width: 120px;
            font-weight: bold;
            color: #555;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .canvas-container {
            text-align: center;
            padding: 20px;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
        }
        
        .info-panel {
            padding: 20px;
            background: #f8f9fa;
        }
        
        .info-panel h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .formula {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .duality-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
        
        .optimization-info {
            background: #d1ecf1;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #17a2b8;
        }
        
        .problem-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .problem-selector button {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
        }
        
        .problem-selector button.active {
            background: linear-gradient(45deg, #28a745, #20c997);
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .comparison-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        /* Mathematical Theory Styles */
        .mathematical-theory {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .theorem-section {
            margin: 20px 0;
        }
        
        .theorem-box {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.1);
        }
        
        .theorem-box h5 {
            color: #667eea;
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid #667eea;
            padding-bottom: 8px;
        }
        
        .formula-display {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            border-radius: 5px;
        }
        
        .duality-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .duality-table th,
        .duality-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }
        
        .duality-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
        }
        
        .duality-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .interpretation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .interpretation-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .interpretation-card h5 {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.1em;
        }
        
        .shadow-price-analysis {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }
        
        .application-examples {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .example-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .example-card h5 {
            color: #2c3e50;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .algorithm-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .algorithm-card h5 {
            color: #764ba2;
            margin-top: 0;
            font-size: 1.1em;
        }
        
        .sensitivity-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .sensitivity-content h5 {
            color: #2c3e50;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .interpretation-grid,
            .algorithm-grid {
                grid-template-columns: 1fr;
            }
            
            .duality-table {
                font-size: 0.9em;
            }
            
            .duality-table th,
            .duality-table td {
                padding: 8px;
            }
        }
    </style>





</head>
<body>
    <div class="container">
        <h1>üîÑ Minh h·ªça Duality trong Linear Programming</h1>
        
        <div class="controls">
            <div class="control-group">
                <h3>üìä Primal Problem</h3>
                <div class="problem-selector">
                    <button onclick="setProblem('simple')" class="active">Simple LP</button>
                    <button onclick="setProblem('svm')">SVM</button>
                </div>
                <div class="control-row">
                    <label>c‚ÇÅ:</label>
                    <input type="range" id="c1" min="1" max="5" value="3" step="0.5">
                    <input type="number" id="c1Value" value="3" min="1" max="5" step="0.5">
                </div>
                <div class="control-row">
                    <label>c‚ÇÇ:</label>
                    <input type="range" id="c2" min="1" max="5" value="4" step="0.5">
                    <input type="number" id="c2Value" value="4" min="1" max="5" step="0.5">
                </div>
                <div class="control-row">
                    <label>b‚ÇÅ:</label>
                    <input type="range" id="b1" min="5" max="10" value="7" step="0.5">
                    <input type="number" id="b1Value" value="7" min="5" max="10" step="0.5">
                </div>
                <div class="control-row">
                    <label>b‚ÇÇ:</label>
                    <input type="range" id="b2" min="5" max="15" value="9" step="0.5">
                    <input type="number" id="b2Value" value="9" min="5" max="15" step="0.5">
                </div>
                <div class="duality-info">
                    <strong>Primal Problem:</strong><br>
                    <span id="primalProblem">ƒêang t√≠nh...</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üéØ Dual Problem</h3>
                <div class="control-row">
                    <label>y‚ÇÅ:</label>
                    <input type="range" id="y1" min="0" max="3" value="1" step="0.1">
                    <input type="number" id="y1Value" value="1" min="0" max="3" step="0.1">
                </div>
                <div class="control-row">
                    <label>y‚ÇÇ:</label>
                    <input type="range" id="y2" min="0" max="3" value="0.5" step="0.1">
                    <input type="number" id="y2Value" value="0.5" min="0" max="3" step="0.1">
                </div>
                <div class="control-row">
                    <button onclick="solveDual()">üîç Gi·∫£i Dual</button>
                    <button onclick="checkDuality()">‚úÖ Ki·ªÉm tra Duality</button>
                </div>
                <div class="optimization-info">
                    <strong>Dual Problem:</strong><br>
                    <span id="dualProblem">ƒêang t√≠nh...</span>
                </div>
                <div class="duality-info">
                    <strong>Duality Results:</strong><br>
                    <span id="dualityResult">Ch∆∞a t√≠nh</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="dualityCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="info-panel">
            <h3>üìö Th√¥ng tin Chi ti·∫øt</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>üìä Primal Problem</h4>
                    <div class="formula">
                        <strong>Minimize:</strong> c‚ÇÅx‚ÇÅ + c‚ÇÇx‚ÇÇ<br>
                        <strong>Subject to:</strong><br>
                        ‚Ä¢ x‚ÇÅ + 2x‚ÇÇ ‚â• b‚ÇÅ<br>
                        ‚Ä¢ 3x‚ÇÅ + x‚ÇÇ ‚â• b‚ÇÇ<br>
                        ‚Ä¢ x‚ÇÅ, x‚ÇÇ ‚â• 0
                    </div>
                    <ul>
                        <li>Decision variables: x‚ÇÅ, x‚ÇÇ</li>
                        <li>Objective: minimize cost</li>
                        <li>Constraints: resource requirements</li>
                        <li>Feasible region: convex polyhedron</li>
                    </ul>
                </div>
                
                <div class="comparison-card">
                    <h4>üéØ Dual Problem</h4>
                    <div class="formula">
                        <strong>Maximize:</strong> b‚ÇÅy‚ÇÅ + b‚ÇÇy‚ÇÇ<br>
                        <strong>Subject to:</strong><br>
                        ‚Ä¢ y‚ÇÅ + 3y‚ÇÇ ‚â§ c‚ÇÅ<br>
                        ‚Ä¢ 2y‚ÇÅ + y‚ÇÇ ‚â§ c‚ÇÇ<br>
                        ‚Ä¢ y‚ÇÅ, y‚ÇÇ ‚â• 0
                    </div>
                    <ul>
                        <li>Dual variables: y‚ÇÅ, y‚ÇÇ</li>
                        <li>Objective: maximize value</li>
                        <li>Constraints: price constraints</li>
                        <li>Shadow prices interpretation</li>
                    </ul>
                </div>
            </div>
            
            <div class="formula">
                <strong>Weak Duality:</strong> b·µÄy ‚â§ c·µÄx (for any feasible x, y)<br>
                <strong>Strong Duality:</strong> b·µÄy* = c·µÄx* (at optimal solutions)<br>
                <strong>Complementary Slackness:</strong> y·µ¢(Ax - b)·µ¢ = 0, x‚±º(c - A·µÄy)‚±º = 0
            </div>
            
            <div class="mathematical-theory">
                <h3>üî¨ Mathematical Foundation of Duality Theory</h3>
                
                <div class="theorem-section">
                    <h4>üìê Fundamental Duality Theorems</h4>
                    
                    <div class="theorem-box">
                        <h5>Theorem 1: Weak Duality</h5>
                        <p><strong>Statement:</strong> If x* is feasible for the primal and y* is feasible for the dual, then:</p>
                        <div class="formula-display">
                            $$\mathbf{b}^T\mathbf{y}^* \leq \mathbf{c}^T\mathbf{x}^*$$
                        </div>
                        <p><strong>Proof:</strong> Since x* is primal feasible: ùêÄx* ‚â• ùêõ, and y* is dual feasible: ùêÄ·µÄy* ‚â§ ùêú with y* ‚â• ùüé, x* ‚â• ùüé</p>
                        <div class="formula-display">
                            $$\mathbf{b}^T\mathbf{y}^* \leq (\mathbf{A}\mathbf{x}^*)^T\mathbf{y}^* = (\mathbf{x}^*)^T\mathbf{A}^T\mathbf{y}^* \leq (\mathbf{x}^*)^T\mathbf{c} = \mathbf{c}^T\mathbf{x}^*$$
                        </div>
                        <p><strong>Corollary:</strong> If primal is unbounded below, then dual is infeasible. If dual is unbounded above, then primal is infeasible.</p>
                    </div>
                    
                    <div class="theorem-box">
                        <h5>Theorem 2: Strong Duality</h5>
                        <p><strong>Statement:</strong> If the primal LP has a finite optimal solution x*, then the dual LP has a finite optimal solution y*, and:</p>
                        <div class="formula-display">
                            $$\mathbf{c}^T\mathbf{x}^* = \mathbf{b}^T\mathbf{y}^*$$
                        </div>
                        <p><strong>Economic Interpretation:</strong> The minimum cost equals the maximum value of resources at optimal shadow prices.</p>
                    </div>
                    
                    <div class="theorem-box">
                        <h5>Theorem 3: Complementary Slackness</h5>
                        <p><strong>Statement:</strong> Let x* and y* be optimal solutions to primal and dual respectively. Then:</p>
                        <div class="formula-display">
                            $$\begin{align}
                            y_i^* > 0 &\Rightarrow \text{primal constraint } i \text{ is tight: } (\mathbf{A}\mathbf{x}^*)_i = b_i \\
                            (\mathbf{A}\mathbf{x}^*)_i > b_i &\Rightarrow y_i^* = 0 \\
                            x_j^* > 0 &\Rightarrow \text{dual constraint } j \text{ is tight: } (\mathbf{A}^T\mathbf{y}^*)_j = c_j \\
                            (\mathbf{A}^T\mathbf{y}^*)_j < c_j &\Rightarrow x_j^* = 0
                            \end{align}$$
                        </div>
                        <p><strong>Intuition:</strong> Either a constraint is binding, or its corresponding dual variable is zero.</p>
                    </div>
                </div>
                
                <div class="duality-rules">
                    <h4>üîÑ Comprehensive Duality Rules</h4>
                    <table class="duality-table">
                        <thead>
                            <tr>
                                <th>Primal</th>
                                <th>‚ü∑</th>
                                <th>Dual</th>
                                <th>Mathematical Relationship</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>minimize ùêú·µÄùê±</td>
                                <td>‚ü∑</td>
                                <td>maximize ùêõ·µÄùê≤</td>
                                <td>Objectives are transposes</td>
                            </tr>
                            <tr>
                                <td>ùêÄùê± ‚â• ùêõ</td>
                                <td>‚ü∑</td>
                                <td>ùê≤ ‚â• ùüé</td>
                                <td>‚â• constraint ‚ü∑ ‚â• 0 variable</td>
                            </tr>
                            <tr>
                                <td>ùêÄùê± ‚â§ ùêõ</td>
                                <td>‚ü∑</td>
                                <td>ùê≤ ‚â§ ùüé</td>
                                <td>‚â§ constraint ‚ü∑ ‚â§ 0 variable</td>
                            </tr>
                            <tr>
                                <td>ùêÄùê± = ùêõ</td>
                                <td>‚ü∑</td>
                                <td>ùê≤ free</td>
                                <td>= constraint ‚ü∑ unrestricted variable</td>
                            </tr>
                            <tr>
                                <td>ùê± ‚â• ùüé</td>
                                <td>‚ü∑</td>
                                <td>ùêÄ·µÄùê≤ ‚â§ ùêú</td>
                                <td>‚â• 0 variable ‚ü∑ ‚â§ constraint</td>
                            </tr>
                            <tr>
                                <td>ùê± ‚â§ ùüé</td>
                                <td>‚ü∑</td>
                                <td>ùêÄ·µÄùê≤ ‚â• ùêú</td>
                                <td>‚â§ 0 variable ‚ü∑ ‚â• constraint</td>
                            </tr>
                            <tr>
                                <td>ùê± free</td>
                                <td>‚ü∑</td>
                                <td>ùêÄ·µÄùê≤ = ùêú</td>
                                <td>unrestricted variable ‚ü∑ = constraint</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="economic-interpretation">
                    <h4>üí∞ Economic Interpretation of Duality</h4>
                    
                    <div class="interpretation-grid">
                        <div class="interpretation-card">
                            <h5>üè≠ Primal Problem (Producer's Perspective)</h5>
                            <ul>
                                <li><strong>Variables:</strong> Production quantities (x‚ÇÅ, x‚ÇÇ, ...)</li>
                                <li><strong>Objective:</strong> Minimize production cost</li>
                                <li><strong>Constraints:</strong> Meet demand requirements</li>
                                <li><strong>Question:</strong> "How much to produce?"</li>
                            </ul>
                        </div>
                        
                        <div class="interpretation-card">
                            <h5>üíº Dual Problem (Consumer's Perspective)</h5>
                            <ul>
                                <li><strong>Variables:</strong> Shadow prices (y‚ÇÅ, y‚ÇÇ, ...)</li>
                                <li><strong>Objective:</strong> Maximize value of resources</li>
                                <li><strong>Constraints:</strong> Don't exceed production costs</li>
                                <li><strong>Question:</strong> "What are resources worth?"</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="shadow-price-analysis">
                        <h5>üìä Shadow Price Analysis</h5>
                        <p>Shadow price y*·µ¢ represents the <strong>marginal value</strong> of resource i:</p>
                        <div class="formula-display">
                            $$y_i^* = \frac{\partial z^*}{\partial b_i}$$
                        </div>
                        <ul>
                            <li><strong>Positive shadow price:</strong> Resource is scarce and valuable</li>
                            <li><strong>Zero shadow price:</strong> Resource is abundant (non-binding constraint)</li>
                            <li><strong>Range of validity:</strong> Shadow prices valid only within certain ranges</li>
                        </ul>
                    </div>
                </div>
                
                <div class="advanced-applications">
                    <h4>üöÄ Advanced Duality Applications</h4>
                    
                    <div class="application-examples">
                        <div class="example-card">
                            <h5>ü§ñ Support Vector Machines (SVM)</h5>
                            <div class="formula-display">
                                <strong>Primal:</strong> 
                                $$\min_{\mathbf{w},b,\boldsymbol{\xi}} \frac{1}{2}\|\mathbf{w}\|^2 + C\sum_{i=1}^n \xi_i$$
                                $$\text{s.t. } y_i(\mathbf{w}^T\mathbf{x}_i + b) \geq 1 - \xi_i, \quad \xi_i \geq 0$$
                            </div>
                            <div class="formula-display">
                                <strong>Dual:</strong>
                                $$\max_{\boldsymbol{\alpha}} \sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j=1}^n \alpha_i\alpha_j y_i y_j \mathbf{x}_i^T\mathbf{x}_j$$
                                $$\text{s.t. } \sum_{i=1}^n \alpha_i y_i = 0, \quad 0 \leq \alpha_i \leq C$$
                            </div>
                            <p><strong>Advantage:</strong> Dual depends only on inner products ‚Üí Kernel trick!</p>
                        </div>
                        
                        <div class="example-card">
                            <h5>üìà Portfolio Optimization</h5>
                            <div class="formula-display">
                                <strong>Primal:</strong> 
                                $$\min_{\mathbf{x}} \mathbf{x}^T\Sigma\mathbf{x}$$
                                $$\text{s.t. } \boldsymbol{\mu}^T\mathbf{x} = r, \quad \mathbf{1}^T\mathbf{x} = 1, \quad \mathbf{x} \geq \mathbf{0}$$
                            </div>
                            <div class="formula-display">
                                <strong>Dual:</strong>
                                $$\max_{\lambda,\nu} -\frac{1}{2}(\lambda\boldsymbol{\mu} + \nu\mathbf{1})^T\Sigma^{-1}(\lambda\boldsymbol{\mu} + \nu\mathbf{1}) + \lambda r + \nu$$
                            </div>
                            <p><strong>Interpretation:</strong> Œª = marginal utility of return, ŒΩ = marginal cost of budget constraint</p>
                        </div>
                        
                        <div class="example-card">
                            <h5>‚ö° Network Flow</h5>
                            <div class="formula-display">
                                <strong>Min-Cost Flow Primal:</strong>
                                $$\min \sum_{(i,j)} c_{ij}x_{ij}$$
                                $$\text{s.t. } \sum_j x_{ij} - \sum_j x_{ji} = b_i \quad \forall i$$
                            </div>
                            <div class="formula-display">
                                <strong>Dual (Node Potentials):</strong>
                                $$\max \sum_i b_i \pi_i$$
                                $$\text{s.t. } \pi_i - \pi_j \leq c_{ij} \quad \forall (i,j)$$
                            </div>
                            <p><strong>Interpretation:</strong> œÄ·µ¢ = potential at node i, reduced cost = c·µ¢‚±º - œÄ·µ¢ + œÄ‚±º</p>
                        </div>
                    </div>
                </div>
                
                <div class="computational-aspects">
                    <h4>üîß Computational Aspects of Duality</h4>
                    
                    <div class="algorithm-grid">
                        <div class="algorithm-card">
                            <h5>üîÑ Dual Simplex Method</h5>
                            <ul>
                                <li><strong>Strategy:</strong> Maintain dual feasibility, achieve primal feasibility</li>
                                <li><strong>Advantage:</strong> Excellent for reoptimization after constraint changes</li>
                                <li><strong>Applications:</strong> Branch-and-bound, sensitivity analysis</li>
                                <li><strong>Complexity:</strong> Same as primal simplex in practice</li>
                            </ul>
                        </div>
                        
                        <div class="algorithm-card">
                            <h5>‚ö° Interior Point Methods</h5>
                            <ul>
                                <li><strong>Strategy:</strong> Solve primal and dual simultaneously</li>
                                <li><strong>Barrier function:</strong> -Œº‚àëln(x‚±º) - Œº‚àëln(y·µ¢)</li>
                                <li><strong>Complexity:</strong> Polynomial time O(n¬≥L)</li>
                                <li><strong>Advantage:</strong> Better for very large problems</li>
                            </ul>
                        </div>
                        
                        <div class="algorithm-card">
                            <h5>üéØ Lagrangian Duality</h5>
                            <ul>
                                <li><strong>Lagrangian:</strong> L(x,Œª,Œº) = f(x) + Œª·µÄ(Ax-b) + Œº·µÄ(-x)</li>
                                <li><strong>Dual function:</strong> g(Œª,Œº) = inf_{x} L(x,Œª,Œº)</li>
                                <li><strong>Dual problem:</strong> max g(Œª,Œº) s.t. Œª‚â•0, Œº‚â•0</li>
                                <li><strong>Applications:</strong> Nonlinear programming, convex optimization</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="sensitivity-analysis">
                    <h4>üìä Sensitivity Analysis via Duality</h4>
                    
                    <div class="sensitivity-content">
                        <h5>üéØ Parameter Changes and Optimal Value</h5>
                        <div class="formula-display">
                            $$\frac{\partial z^*}{\partial b_i} = y_i^*, \quad \frac{\partial z^*}{\partial c_j} = x_j^*$$
                        </div>
                        
                        <h5>üìà Right-Hand-Side Sensitivity</h5>
                        <p>For changes Œîb in the right-hand side:</p>
                        <div class="formula-display">
                            $$z^*(b + \Delta b) \approx z^*(b) + (\mathbf{y}^*)^T\Delta b$$
                        </div>
                        <p><strong>Valid range:</strong> As long as new solution remains optimal basis</p>
                        
                        <h5>üí∞ Cost Coefficient Sensitivity</h5>
                        <p>For changes Œîc in objective coefficients:</p>
                        <div class="formula-display">
                            $$z^*(c + \Delta c) \approx z^*(c) + (\mathbf{x}^*)^T\Delta c$$
                        </div>
                        
                        <h5>üîÑ Adding New Variables/Constraints</h5>
                        <ul>
                            <li><strong>New variable:</strong> Check reduced cost = c‚±º - (ùêÄ‚±º)·µÄùê≤*</li>
                            <li><strong>New constraint:</strong> Check violation in current optimal solution</li>
                            <li><strong>Dual solution provides immediate insight</strong> without resolving</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="formula">
                <strong>SVM Duality:</strong><br>
                <strong>Primal:</strong> min ¬Ω||w||¬≤ + CŒ£Œæ·µ¢ s.t. y·µ¢(w¬∑x·µ¢ + b) ‚â• 1 - Œæ·µ¢<br>
                <strong>Dual:</strong> max Œ£Œ±·µ¢ - ¬ΩŒ£Œ±·µ¢Œ±‚±ºy·µ¢y‚±º(x·µ¢¬∑x‚±º) s.t. 0 ‚â§ Œ±·µ¢ ‚â§ C
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('dualityCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let currentProblem = 'simple';
        let c1 = 3, c2 = 4, b1 = 7, b2 = 9;
        let y1 = 1, y2 = 0.5;
        let primalSolution = { x1: 0, x2: 0 };
        let dualSolution = { y1: 0, y2: 0 };
        
        // Update parameters
        function updateParameters() {
            c1 = parseFloat(document.getElementById('c1Value').value);
            c2 = parseFloat(document.getElementById('c2Value').value);
            b1 = parseFloat(document.getElementById('b1Value').value);
            b2 = parseFloat(document.getElementById('b2Value').value);
            y1 = parseFloat(document.getElementById('y1Value').value);
            y2 = parseFloat(document.getElementById('y2Value').value);
        }
        
        // Set problem
        function setProblem(problemName) {
            currentProblem = problemName;
            document.querySelectorAll('.problem-selector button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            updateProblemInfo();
            drawVisualization();
        }
        
        // Update problem info
        function updateProblemInfo() {
            if (currentProblem === 'simple') {
                document.getElementById('primalProblem').innerHTML = `
                    <strong>Minimize:</strong> ${c1}x‚ÇÅ + ${c2}x‚ÇÇ<br>
                    <strong>Subject to:</strong><br>
                    ‚Ä¢ x‚ÇÅ + 2x‚ÇÇ ‚â• ${b1}<br>
                    ‚Ä¢ 3x‚ÇÅ + x‚ÇÇ ‚â• ${b2}<br>
                    ‚Ä¢ x‚ÇÅ, x‚ÇÇ ‚â• 0
                `;
                
                document.getElementById('dualProblem').innerHTML = `
                    <strong>Maximize:</strong> ${b1}y‚ÇÅ + ${b2}y‚ÇÇ<br>
                    <strong>Subject to:</strong><br>
                    ‚Ä¢ y‚ÇÅ + 3y‚ÇÇ ‚â§ ${c1}<br>
                    ‚Ä¢ 2y‚ÇÅ + y‚ÇÇ ‚â§ ${c2}<br>
                    ‚Ä¢ y‚ÇÅ, y‚ÇÇ ‚â• 0
                `;
            } else {
                document.getElementById('primalProblem').innerHTML = `
                    <strong>SVM Primal:</strong><br>
                    <strong>Minimize:</strong> ¬Ω||w||¬≤ + CŒ£Œæ·µ¢<br>
                    <strong>Subject to:</strong><br>
                    ‚Ä¢ y·µ¢(w¬∑x·µ¢ + b) ‚â• 1 - Œæ·µ¢<br>
                    ‚Ä¢ Œæ·µ¢ ‚â• 0
                `;
                
                document.getElementById('dualProblem').innerHTML = `
                    <strong>SVM Dual:</strong><br>
                    <strong>Maximize:</strong> Œ£Œ±·µ¢ - ¬ΩŒ£Œ±·µ¢Œ±‚±ºy·µ¢y‚±º(x·µ¢¬∑x‚±º)<br>
                    <strong>Subject to:</strong><br>
                    ‚Ä¢ 0 ‚â§ Œ±·µ¢ ‚â§ C<br>
                    ‚Ä¢ Œ£Œ±·µ¢y·µ¢ = 0
                `;
            }
        }
        
        // Solve dual problem
        function solveDual() {
            updateParameters();
            
            // Simple analytical solution for the dual
            // y‚ÇÅ + 3y‚ÇÇ ‚â§ c‚ÇÅ and 2y‚ÇÅ + y‚ÇÇ ‚â§ c‚ÇÇ
            // We'll find the intersection of these constraints
            
            const det = 1 * 1 - 2 * 3; // determinant of coefficient matrix
            if (Math.abs(det) > 1e-6) {
                dualSolution.y1 = (c1 * 1 - c2 * 3) / det;
                dualSolution.y2 = (c2 * 1 - c1 * 2) / det;
                
                // Ensure non-negativity
                dualSolution.y1 = Math.max(0, dualSolution.y1);
                dualSolution.y2 = Math.max(0, dualSolution.y2);
            }
            
            updateDualityResult();
            drawVisualization();
        }
        
        // Check duality conditions
        function checkDuality() {
            updateParameters();
            
            // Calculate primal objective
            const primalObj = c1 * primalSolution.x1 + c2 * primalSolution.x2;
            
            // Calculate dual objective
            const dualObj = b1 * y1 + b2 * y2;
            
            // Check weak duality
            const weakDuality = dualObj <= primalObj;
            
            // Check complementary slackness
            const constraint1 = primalSolution.x1 + 2 * primalSolution.x2 - b1;
            const constraint2 = 3 * primalSolution.x1 + primalSolution.x2 - b2;
            const dualConstraint1 = c1 - (y1 + 3 * y2);
            const dualConstraint2 = c2 - (2 * y1 + y2);
            
            const compSlack1 = y1 * constraint1;
            const compSlack2 = y2 * constraint2;
            const compSlack3 = primalSolution.x1 * dualConstraint1;
            const compSlack4 = primalSolution.x2 * dualConstraint2;
            
            const complementarySlackness = Math.abs(compSlack1) < 1e-6 && 
                                        Math.abs(compSlack2) < 1e-6 &&
                                        Math.abs(compSlack3) < 1e-6 && 
                                        Math.abs(compSlack4) < 1e-6;
            
            document.getElementById('dualityResult').innerHTML = `
                <strong>Weak Duality:</strong> ${weakDuality ? '‚úÖ' : '‚ùå'} (${dualObj.toFixed(3)} ‚â§ ${primalObj.toFixed(3)})<br>
                <strong>Complementary Slackness:</strong> ${complementarySlackness ? '‚úÖ' : '‚ùå'}<br>
                <strong>Primal Objective:</strong> ${primalObj.toFixed(3)}<br>
                <strong>Dual Objective:</strong> ${dualObj.toFixed(3)}
            `;
        }
        
        // Update duality result
        function updateDualityResult() {
            const primalObj = c1 * primalSolution.x1 + c2 * primalSolution.x2;
            const dualObj = b1 * dualSolution.y1 + b2 * dualSolution.y2;
            
            document.getElementById('dualityResult').innerHTML = `
                <strong>Primal Solution:</strong> x‚ÇÅ=${primalSolution.x1.toFixed(2)}, x‚ÇÇ=${primalSolution.x2.toFixed(2)}<br>
                <strong>Dual Solution:</strong> y‚ÇÅ=${dualSolution.y1.toFixed(2)}, y‚ÇÇ=${dualSolution.y2.toFixed(2)}<br>
                <strong>Primal Objective:</strong> ${primalObj.toFixed(3)}<br>
                <strong>Dual Objective:</strong> ${dualObj.toFixed(3)}
            `;
        }
        
        // Draw visualization
        function drawVisualization() {
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set up coordinate system
            const margin = 50;
            const width = canvas.width - 2 * margin;
            const height = canvas.height - 2 * margin;
            const xMin = 0;
            const xMax = 10;
            const yMin = 0;
            const yMax = 10;
            const scaleX = width / (xMax - xMin);
            const scaleY = height / (yMax - yMin);
            
            // Transform function
            function transform(x, y) {
                return {
                    x: margin + (x - xMin) * scaleX,
                    y: canvas.height - margin - (y - yMin) * scaleY
                };
            }
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = xMin; i <= xMax; i++) {
                const pos = transform(i, 0);
                ctx.beginPath();
                ctx.moveTo(pos.x, margin);
                ctx.lineTo(pos.x, canvas.height - margin);
                ctx.stroke();
            }
            for (let i = yMin; i <= yMax; i++) {
                const pos = transform(0, i);
                ctx.beginPath();
                ctx.moveTo(margin, pos.y);
                ctx.lineTo(canvas.width - margin, pos.y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            const origin = transform(0, 0);
            ctx.beginPath();
            ctx.moveTo(origin.x, margin);
            ctx.lineTo(origin.x, canvas.height - margin);
            ctx.moveTo(margin, origin.y);
            ctx.lineTo(canvas.width - margin, origin.y);
            ctx.stroke();
            
            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('x‚ÇÅ', canvas.width / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('x‚ÇÇ', 0, 0);
            ctx.restore();
            
            // Draw constraint lines
            // Constraint 1: x‚ÇÅ + 2x‚ÇÇ ‚â• b‚ÇÅ
            const constraint1_x1 = 0;
            const constraint1_x2 = b1 / 2;
            const constraint1_y1 = b1;
            const constraint1_y2 = 0;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(transform(constraint1_x1, constraint1_x2).x, transform(constraint1_x1, constraint1_x2).y);
            ctx.lineTo(transform(constraint1_y1, constraint1_y2).x, transform(constraint1_y1, constraint1_y2).y);
            ctx.stroke();
            
            // Constraint 2: 3x‚ÇÅ + x‚ÇÇ ‚â• b‚ÇÇ
            const constraint2_x1 = 0;
            const constraint2_x2 = b2;
            const constraint2_y1 = b2 / 3;
            const constraint2_y2 = 0;
            
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(transform(constraint2_x1, constraint2_x2).x, transform(constraint2_x1, constraint2_x2).y);
            ctx.lineTo(transform(constraint2_y1, constraint2_y2).x, transform(constraint2_y1, constraint2_y2).y);
            ctx.stroke();
            
            // Find feasible region vertices
            const vertices = [];
            
            // Intersection of constraints
            const det = 1 * 1 - 2 * 3;
            if (Math.abs(det) > 1e-6) {
                const x1 = (b1 * 1 - b2 * 2) / det;
                const x2 = (b2 * 1 - b1 * 3) / det;
                if (x1 >= 0 && x2 >= 0) {
                    vertices.push({ x: x1, y: x2 });
                }
            }
            
            // Intersection with axes
            if (b1 >= 0) vertices.push({ x: b1, y: 0 });
            if (b2 / 3 >= 0) vertices.push({ x: b2 / 3, y: 0 });
            if (b1 / 2 >= 0) vertices.push({ x: 0, y: b1 / 2 });
            if (b2 >= 0) vertices.push({ x: 0, y: b2 });
            
            // Draw feasible region
            if (vertices.length > 2) {
                ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                ctx.beginPath();
                vertices.forEach((vertex, index) => {
                    const pos = transform(vertex.x, vertex.y);
                    if (index === 0) {
                        ctx.moveTo(pos.x, pos.y);
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                });
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw objective function contours
            const contourLevels = [10, 20, 30, 40, 50];
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            contourLevels.forEach(level => {
                const x1 = 0;
                const y1 = level / c2;
                const x2 = level / c1;
                const y2 = 0;
                
                if (y1 <= yMax && x2 <= xMax) {
                    ctx.beginPath();
                    ctx.moveTo(transform(x1, y1).x, transform(x1, y1).y);
                    ctx.lineTo(transform(x2, y2).x, transform(x2, y2).y);
                    ctx.stroke();
                    
                    // Add contour label
                    const midX = (transform(x1, y1).x + transform(x2, y2).x) / 2;
                    const midY = (transform(x1, y1).y + transform(x2, y2).y) / 2;
                    ctx.fillStyle = '#667eea';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(level.toString(), midX, midY - 5);
                }
            });
            ctx.setLineDash([]);
            
            // Draw optimal solution
            if (vertices.length > 0) {
                // Find minimum objective value
                let minObj = Infinity;
                let optimalVertex = vertices[0];
                
                vertices.forEach(vertex => {
                    const obj = c1 * vertex.x + c2 * vertex.y;
                    if (obj < minObj) {
                        minObj = obj;
                        optimalVertex = vertex;
                    }
                });
                
                primalSolution = optimalVertex;
                
                // Draw optimal point
                const optimalPos = transform(optimalVertex.x, optimalVertex.y);
                ctx.fillStyle = '#28a745';
                ctx.beginPath();
                ctx.arc(optimalPos.x, optimalPos.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Optimal: (${optimalVertex.x.toFixed(2)}, ${optimalVertex.y.toFixed(2)})`, optimalPos.x + 10, optimalPos.y - 10);
                ctx.fillText(`Obj: ${minObj.toFixed(2)}`, optimalPos.x + 10, optimalPos.y + 5);
            }
            
            // Draw dual space (if selected)
            if (currentProblem === 'simple') {
                // Draw dual constraints
                const dualMargin = 50;
                const dualWidth = 200;
                const dualHeight = 200;
                const dualX = canvas.width - dualWidth - dualMargin;
                const dualY = dualMargin;
                
                // Dual constraint 1: y‚ÇÅ + 3y‚ÇÇ ‚â§ c‚ÇÅ
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(dualX, dualY + dualHeight - (c1 / 3) * (dualHeight / 3));
                ctx.lineTo(dualX + dualWidth - (c1) * (dualWidth / 3), dualY + dualHeight);
                ctx.stroke();
                
                // Dual constraint 2: 2y‚ÇÅ + y‚ÇÇ ‚â§ c‚ÇÇ
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(dualX, dualY + dualHeight - (c2) * (dualHeight / 2));
                ctx.lineTo(dualX + dualWidth - (c2 / 2) * (dualWidth / 2), dualY + dualHeight);
                ctx.stroke();
                
                // Draw dual solution
                const dualPos = {
                    x: dualX + y1 * (dualWidth / 3),
                    y: dualY + dualHeight - y2 * (dualHeight / 3)
                };
                
                ctx.fillStyle = '#ffc107';
                ctx.beginPath();
                ctx.arc(dualPos.x, dualPos.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Dual space labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Dual Space', dualX + dualWidth / 2, dualY - 10);
                ctx.fillText('y‚ÇÅ', dualX + dualWidth / 2, dualY + dualHeight + 15);
                ctx.save();
                ctx.translate(dualX - 10, dualY + dualHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('y‚ÇÇ', 0, 0);
                ctx.restore();
            }
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Constraint 1: x‚ÇÅ + 2x‚ÇÇ ‚â• ${b1}`, margin + 10, margin + 20);
            ctx.fillText(`Constraint 2: 3x‚ÇÅ + x‚ÇÇ ‚â• ${b2}`, margin + 10, margin + 40);
            ctx.fillText(`Objective: ${c1}x‚ÇÅ + ${c2}x‚ÇÇ`, margin + 10, margin + 60);
        }
        
        // Event listeners
        document.getElementById('c1').addEventListener('input', function() {
            document.getElementById('c1Value').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('c1Value').addEventListener('input', function() {
            document.getElementById('c1').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('c2').addEventListener('input', function() {
            document.getElementById('c2Value').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('c2Value').addEventListener('input', function() {
            document.getElementById('c2').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('b1').addEventListener('input', function() {
            document.getElementById('b1Value').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('b1Value').addEventListener('input', function() {
            document.getElementById('b1').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('b2').addEventListener('input', function() {
            document.getElementById('b2Value').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('b2Value').addEventListener('input', function() {
            document.getElementById('b2').value = this.value;
            updateParameters();
            updateProblemInfo();
            drawVisualization();
        });
        
        document.getElementById('y1').addEventListener('input', function() {
            document.getElementById('y1Value').value = this.value;
            updateParameters();
            checkDuality();
            drawVisualization();
        });
        
        document.getElementById('y1Value').addEventListener('input', function() {
            document.getElementById('y1').value = this.value;
            updateParameters();
            checkDuality();
            drawVisualization();
        });
        
        document.getElementById('y2').addEventListener('input', function() {
            document.getElementById('y2Value').value = this.value;
            updateParameters();
            checkDuality();
            drawVisualization();
        });
        
        document.getElementById('y2Value').addEventListener('input', function() {
            document.getElementById('y2').value = this.value;
            updateParameters();
            checkDuality();
            drawVisualization();
        });
        
        // Initialize
        updateParameters();
        updateProblemInfo();
        drawVisualization();
    </script>
</body>
</html> 
