<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network - Minh h·ªça t∆∞∆°ng t√°c</title>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.95);
        }
        .info {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .network-info {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
        .activation-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .step-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 14px;
        }
    </style>





</head>
<body>
    <div class="container">
        <h1>üß† Neural Network - Minh h·ªça t∆∞∆°ng t√°c</h1>
        
        <!-- Historical Section -->
        <div style="background: linear-gradient(135deg, #2d1b69 0%, #11998e 100%); padding: 25px; border-radius: 15px; margin-bottom: 30px; border: 2px solid rgba(255, 255, 255, 0.1);">
            <h2 style="color: #FFD700; text-align: center; margin-bottom: 25px;">üìö L·ªãch S·ª≠ Neural Networks</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div style="background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px;">
                    <h4 style="color: #00d4ff; margin-bottom: 15px;">üß† Warren McCulloch & Walter Pitts (1943)</h4>
                    <p><strong>M√¥ h√¨nh neuron ƒë·∫ßu ti√™n:</strong> "A Logical Calculus of Ideas Immanent in Nervous Activity" - ƒë·ªÅ xu·∫•t m√¥ h√¨nh to√°n h·ªçc ƒë·∫ßu ti√™n cho neuron nh√¢n t·∫°o.</p>
                </div>
                <div style="background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px;">
                    <h4 style="color: #ff6b6b; margin-bottom: 15px;">‚ö° Frank Rosenblatt (1957)</h4>
                    <p><strong>Perceptron:</strong> Ph√°t minh perceptron - neural network ƒë·∫ßu ti√™n c√≥ th·ªÉ h·ªçc. B√°o ch√≠ th·ªùi ƒë√≥ g·ªçi l√† "embryo of computer that will walk, talk, see, reproduce itself".</p>
                </div>
            </div>

            <div style="background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h4 style="color: #FFD700; margin-bottom: 15px;">üåä C√°c m·ªëc quan tr·ªçng</h4>
                <ul style="color: #ffffff; line-height: 1.8;">
                    <li><strong>1969:</strong> Minsky & Papert ch·ªâ ra h·∫°n ch·∫ø c·ªßa perceptron ‚Üí "AI Winter" ƒë·∫ßu ti√™n</li>
                    <li><strong>1986:</strong> Rumelhart, Hinton & Williams ph√°t tri·ªÉn backpropagation algorithm</li>
                    <li><strong>2006:</strong> Geoffrey Hinton ƒë·∫∑t n·ªÅn m√≥ng cho Deep Learning</li>
                    <li><strong>2012:</strong> AlexNet th·∫Øng ImageNet, b·∫Øt ƒë·∫ßu cu·ªôc c√°ch m·∫°ng AI hi·ªán ƒë·∫°i</li>
                </ul>
            </div>

            <div style="background: rgba(76, 175, 80, 0.15); padding: 20px; border-radius: 10px;">
                <h4 style="color: #4caf50; margin-bottom: 15px;">üåü K·ª∑ nguy√™n hi·ªán ƒë·∫°i</h4>
                <p>T·ª´ √Ω t∆∞·ªüng m√¥ ph·ªèng n√£o b·ªô trong nh·ªØng nƒÉm 1940, neural networks ƒë√£ tr·ªü th√†nh c√¥ng ngh·ªá c·ªët l√µi c·ªßa AI hi·ªán ƒë·∫°i, t·ª´ nh·∫≠n di·ªán gi·ªçng n√≥i ƒë·∫øn xe t·ª± l√°i v√† GPT.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Ki·∫øn tr√∫c m·∫°ng</h3>
                <label>Input neurons: <span id="input-neurons">2</span></label>
                <input type="range" id="input-neurons-slider" min="1" max="5" value="2" step="1">
                <label>Hidden neurons: <span id="hidden-neurons">3</span></label>
                <input type="range" id="hidden-neurons-slider" min="1" max="8" value="3" step="1">
                <label>Output neurons: <span id="output-neurons">1</span></label>
                <input type="range" id="output-neurons-slider" min="1" max="3" value="1" step="1">
            </div>
            
            <div class="control-group">
                <h3>Input values</h3>
                <div id="input-values">
                    <label>Input 1: <span id="input1-value">0.5</span></label>
                    <input type="range" id="input1-slider" min="0" max="1" value="0.5" step="0.1">
                    <label>Input 2: <span id="input2-value">0.3</span></label>
                    <input type="range" id="input2-slider" min="0" max="1" value="0.3" step="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <h3>Activation Function</h3>
                <div class="activation-selector">
                    <button onclick="setActivation('sigmoid')">Sigmoid</button>
                    <button onclick="setActivation('relu')">ReLU</button>
                    <button onclick="setActivation('tanh')">Tanh</button>
                    <button onclick="setActivation('linear')">Linear</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Learning Rate</h3>
                <label>Learning Rate: <span id="learning-rate">0.1</span></label>
                <input type="range" id="learning-rate-slider" min="0.01" max="0.5" value="0.1" step="0.01">
                <button onclick="trainNetwork()">Train Network</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="networkCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="control-group">
            <h3>K·∫øt qu·∫£ Forward Propagation</h3>
            <div class="network-info" id="forward-result">
                Input: [0.5, 0.3] ‚Üí Hidden: [0.6, 0.7, 0.4] ‚Üí Output: [0.8]
            </div>
        </div>
        
        <div class="info">
            <h3>üìä Th√¥ng tin Neural Network</h3>
            <div id="network-info">
                <div class="step-display">
                    <strong>Forward Propagation:</strong> z = W¬∑x + b, a = f(z)
                </div>
                <div class="step-display">
                    <strong>Backpropagation:</strong> Œ¥ = ‚àáL ‚äô f'(z)
                </div>
                <div class="step-display">
                    <strong>Weight Update:</strong> W := W - Œ±¬∑Œ¥¬∑a^T
                </div>
            </div>
            
            <h3>üéì Kh√°i ni·ªám h·ªçc ƒë∆∞·ª£c:</h3>
            <ul>
                <li><strong>Forward Propagation:</strong> T√≠nh output t·ª´ input qua c√°c layer</li>
                <li><strong>Activation Function:</strong> f(z) - th√™m t√≠nh phi tuy·∫øn</li>
                <li><strong>Weights & Biases:</strong> Tham s·ªë h·ªçc ƒë∆∞·ª£c c·ªßa m·∫°ng</li>
                <li><strong>Backpropagation:</strong> T√≠nh gradient ƒë·ªÉ c·∫≠p nh·∫≠t weights</li>
                <li><strong>Loss Function:</strong> ƒêo l∆∞·ªùng sai s·ªë gi·ªØa output v√† target</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        
        let network = {
            inputSize: 2,
            hiddenSize: 3,
            outputSize: 1,
            weights1: [],
            weights2: [],
            bias1: [],
            bias2: [],
            activation: 'sigmoid',
            learningRate: 0.1
        };
        
        let inputs = [0.5, 0.3];
        let target = 0.8;
        
        // Setup event listeners
        document.getElementById('input-neurons-slider').addEventListener('input', updateArchitecture);
        document.getElementById('hidden-neurons-slider').addEventListener('input', updateArchitecture);
        document.getElementById('output-neurons-slider').addEventListener('input', updateArchitecture);
        document.getElementById('input1-slider').addEventListener('input', updateInputs);
        document.getElementById('input2-slider').addEventListener('input', updateInputs);
        document.getElementById('learning-rate-slider').addEventListener('input', updateLearningRate);
        
        function updateArchitecture() {
            const inputSlider = document.getElementById('input-neurons-slider');
            const hiddenSlider = document.getElementById('hidden-neurons-slider');
            const outputSlider = document.getElementById('output-neurons-slider');
            
            network.inputSize = parseInt(inputSlider.value);
            network.hiddenSize = parseInt(hiddenSlider.value);
            network.outputSize = parseInt(outputSlider.value);
            
            document.getElementById('input-neurons').textContent = network.inputSize;
            document.getElementById('hidden-neurons').textContent = network.hiddenSize;
            document.getElementById('output-neurons').textContent = network.outputSize;
            
            initializeWeights();
            updateInputControls();
            drawNetwork();
            updateForwardResult();
        }
        
        function updateInputs() {
            const input1Slider = document.getElementById('input1-slider');
            const input2Slider = document.getElementById('input2-slider');
            
            inputs[0] = parseFloat(input1Slider.value);
            inputs[1] = parseFloat(input2Slider.value);
            
            document.getElementById('input1-value').textContent = inputs[0].toFixed(1);
            document.getElementById('input2-value').textContent = inputs[1].toFixed(1);
            
            drawNetwork();
            updateForwardResult();
        }
        
        function updateLearningRate() {
            const slider = document.getElementById('learning-rate-slider');
            network.learningRate = parseFloat(slider.value);
            document.getElementById('learning-rate').textContent = network.learningRate.toFixed(2);
        }
        
        function setActivation(activation) {
            network.activation = activation;
            drawNetwork();
            updateForwardResult();
        }
        
        function updateInputControls() {
            const inputValuesDiv = document.getElementById('input-values');
            inputValuesDiv.innerHTML = '';
            
            for (let i = 0; i < network.inputSize; i++) {
                const value = i < inputs.length ? inputs[i] : 0.5;
                inputs[i] = value;
                
                const label = document.createElement('label');
                label.innerHTML = `Input ${i + 1}: <span id="input${i + 1}-value">${value.toFixed(1)}</span>`;
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `input${i + 1}-slider`;
                slider.min = '0';
                slider.max = '1';
                slider.value = value;
                slider.step = '0.1';
                slider.addEventListener('input', updateInputs);
                
                inputValuesDiv.appendChild(label);
                inputValuesDiv.appendChild(slider);
            }
        }
        
        function initializeWeights() {
            // Initialize weights with random values
            network.weights1 = [];
            network.weights2 = [];
            network.bias1 = [];
            network.bias2 = [];
            
            for (let i = 0; i < network.hiddenSize; i++) {
                network.weights1[i] = [];
                for (let j = 0; j < network.inputSize; j++) {
                    network.weights1[i][j] = (Math.random() - 0.5) * 2;
                }
                network.bias1[i] = (Math.random() - 0.5) * 2;
            }
            
            for (let i = 0; i < network.outputSize; i++) {
                network.weights2[i] = [];
                for (let j = 0; j < network.hiddenSize; j++) {
                    network.weights2[i][j] = (Math.random() - 0.5) * 2;
                }
                network.bias2[i] = (Math.random() - 0.5) * 2;
            }
        }
        
        function activationFunction(x) {
            switch(network.activation) {
                case 'sigmoid':
                    return 1 / (1 + Math.exp(-x));
                case 'relu':
                    return Math.max(0, x);
                case 'tanh':
                    return Math.tanh(x);
                case 'linear':
                    return x;
                default:
                    return 1 / (1 + Math.exp(-x));
            }
        }
        
        function activationDerivative(x) {
            switch(network.activation) {
                case 'sigmoid':
                    const sig = 1 / (1 + Math.exp(-x));
                    return sig * (1 - sig);
                case 'relu':
                    return x > 0 ? 1 : 0;
                case 'tanh':
                    return 1 - Math.tanh(x) * Math.tanh(x);
                case 'linear':
                    return 1;
                default:
                    const sig2 = 1 / (1 + Math.exp(-x));
                    return sig2 * (1 - sig2);
            }
        }
        
        function forwardPropagation() {
            // Hidden layer
            const hiddenZ = [];
            const hiddenA = [];
            
            for (let i = 0; i < network.hiddenSize; i++) {
                hiddenZ[i] = network.bias1[i];
                for (let j = 0; j < network.inputSize; j++) {
                    hiddenZ[i] += network.weights1[i][j] * inputs[j];
                }
                hiddenA[i] = activationFunction(hiddenZ[i]);
            }
            
            // Output layer
            const outputZ = [];
            const outputA = [];
            
            for (let i = 0; i < network.outputSize; i++) {
                outputZ[i] = network.bias2[i];
                for (let j = 0; j < network.hiddenSize; j++) {
                    outputZ[i] += network.weights2[i][j] * hiddenA[j];
                }
                outputA[i] = activationFunction(outputZ[i]);
            }
            
            return {
                hiddenZ: hiddenZ,
                hiddenA: hiddenA,
                outputZ: outputZ,
                outputA: outputA
            };
        }
        
        function drawNetwork() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const layerSpacing = 150;
            const neuronRadius = 20;
            const startX = 100;
            const startY = 100;
            
            // Draw input layer
            const inputY = startY + (canvas.height - 200) / 2;
            for (let i = 0; i < network.inputSize; i++) {
                const x = startX;
                const y = inputY + i * 60 - (network.inputSize - 1) * 30;
                
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, neuronRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(inputs[i].toFixed(2), x, y + 4);
            }
            
            // Draw hidden layer
            const hiddenX = startX + layerSpacing;
            for (let i = 0; i < network.hiddenSize; i++) {
                const x = hiddenX;
                const y = inputY + i * 60 - (network.hiddenSize - 1) * 30;
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, y, neuronRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw connections from input
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                for (let j = 0; j < network.inputSize; j++) {
                    const inputX = startX;
                    const inputY = inputY + j * 60 - (network.inputSize - 1) * 30;
                    
                    ctx.beginPath();
                    ctx.moveTo(inputX + neuronRadius, inputY);
                    ctx.lineTo(x - neuronRadius, y);
                    ctx.stroke();
                }
            }
            
            // Draw output layer
            const outputX = startX + 2 * layerSpacing;
            for (let i = 0; i < network.outputSize; i++) {
                const x = outputX;
                const y = inputY + i * 60 - (network.outputSize - 1) * 30;
                
                ctx.fillStyle = '#45b7d1';
                ctx.beginPath();
                ctx.arc(x, y, neuronRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw connections from hidden
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                for (let j = 0; j < network.hiddenSize; j++) {
                    const hiddenY = inputY + j * 60 - (network.hiddenSize - 1) * 30;
                    
                    ctx.beginPath();
                    ctx.moveTo(hiddenX + neuronRadius, hiddenY);
                    ctx.lineTo(x - neuronRadius, y);
                    ctx.stroke();
                }
            }
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Input Layer', startX, startY - 30);
            ctx.fillText('Hidden Layer', hiddenX, startY - 30);
            ctx.fillText('Output Layer', outputX, startY - 30);
            
            // Draw activation function label
            ctx.fillText(`Activation: ${network.activation.toUpperCase()}`, canvas.width / 2, canvas.height - 20);
        }
        
        function updateForwardResult() {
            const result = forwardPropagation();
            
            let resultText = `Input: [${inputs.map(x => x.toFixed(2)).join(', ')}] ‚Üí `;
            resultText += `Hidden: [${result.hiddenA.map(x => x.toFixed(2)).join(', ')}] ‚Üí `;
            resultText += `Output: [${result.outputA.map(x => x.toFixed(2)).join(', ')}]`;
            
            document.getElementById('forward-result').textContent = resultText;
        }
        
        function trainNetwork() {
            const result = forwardPropagation();
            
            // Simple training step (backpropagation)
            const outputError = target - result.outputA[0];
            const outputDelta = outputError * activationDerivative(result.outputZ[0]);
            
            // Update output weights
            for (let i = 0; i < network.hiddenSize; i++) {
                network.weights2[0][i] += network.learningRate * outputDelta * result.hiddenA[i];
            }
            network.bias2[0] += network.learningRate * outputDelta;
            
            // Update hidden weights
            for (let i = 0; i < network.hiddenSize; i++) {
                const hiddenDelta = outputDelta * network.weights2[0][i] * activationDerivative(result.hiddenZ[i]);
                
                for (let j = 0; j < network.inputSize; j++) {
                    network.weights1[i][j] += network.learningRate * hiddenDelta * inputs[j];
                }
                network.bias1[i] += network.learningRate * hiddenDelta;
            }
            
            drawNetwork();
            updateForwardResult();
        }
        
        // Initialize
        initializeWeights();
        updateInputControls();
        drawNetwork();
        updateForwardResult();
    </script>
</body>
</html> 
