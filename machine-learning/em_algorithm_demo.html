<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expectation-Maximization Algorithm - Interactive Demo</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            line-height: 1.7;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        h2 {
            color: #FFD700;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        h3 {
            color: #87CEEB;
            margin-top: 30px;
        }
        .introduction {
            background: rgba(255, 215, 0, 0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #FFD700;
        }
        .theory-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #4CAF50;
        }
        .formula-box {
            background: linear-gradient(145deg, rgba(15, 15, 40, 0.9), rgba(25, 25, 60, 0.7));
            padding: 25px 35px;
            border-radius: 15px;
            font-family: 'KaTeX_Main', 'Times New Roman', serif;
            font-size: 20px;
            line-height: 1.8;
            text-align: center;
            margin: 25px 0;
            border: 2px solid rgba(100, 200, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
        }
        .formula-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00d4ff, #7c4dff, #ff6b6b, #4ecdc4);
            opacity: 0.8;
        }
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .canvas-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            border: 2px solid #ddd;
        }
        .controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        .control-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #FFD700;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            accent-color: #FFD700;
        }
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .step-indicator {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .algorithm-steps {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .step {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #4ECDC4;
        }
        .step.active {
            border-left-color: #FF6B6B;
            background: rgba(255, 107, 107, 0.2);
        }
        .statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD700;
        }
        .inline-formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 6px;
            color: #FFD700;
            font-family: 'KaTeX_Main', 'Times New Roman', serif;
        }
        .note {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #FFF3CD;
        }
        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
            .control-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Expectation-Maximization Algorithm</h1>
        <p style="text-align: center; font-size: 1.2em; margin-bottom: 30px;">
            Interactive demonstration of the EM algorithm for Gaussian Mixture Models
        </p>

        <div class="introduction">
            <h2>🎯 Introduction</h2>
            <p>
                The <strong>Expectation-Maximization (EM) algorithm</strong> is a powerful iterative method for finding maximum likelihood estimates in statistical models with latent (hidden) variables. It's particularly useful when we have incomplete data or when direct optimization is computationally intractable.
            </p>
            <p>
                The algorithm alternates between two steps:
            </p>
            <ul>
                <li><strong>E-step (Expectation):</strong> Calculate the expected values of latent variables given current parameter estimates</li>
                <li><strong>M-step (Maximization):</strong> Update parameters by maximizing the expected log-likelihood</li>
            </ul>
        </div>

        <div class="theory-section">
            <h2>📊 Mathematical Foundation</h2>
            
            <h3>General EM Algorithm</h3>
            <p>Given observed data <span class="inline-formula">X</span> and latent variables <span class="inline-formula">Z</span>, we want to maximize:</p>
            
            <div class="formula-box">
                <div class="formula-label">Log-Likelihood</div>
                <div class="main-formula">$$L(\theta) = \log p(X|\theta) = \log \sum_Z p(X,Z|\theta)$$</div>
            </div>

            <p>The EM algorithm maximizes the expected complete log-likelihood:</p>
            
            <div class="formula-box">
                <div class="formula-label">Expected Complete Log-Likelihood</div>
                <div class="main-formula">$$Q(\theta|\theta^{(t)}) = E_{Z|X,\theta^{(t)}}[\log p(X,Z|\theta)]$$</div>
            </div>

            <h3>For Gaussian Mixture Models</h3>
            <p>We assume data comes from K Gaussian components:</p>
            
            <div class="formula-box">
                <div class="formula-label">Mixture Model</div>
                <div class="main-formula">$$p(x_i) = \sum_{k=1}^K \pi_k \mathcal{N}(x_i|\mu_k, \sigma_k^2)$$</div>
            </div>

            <div class="formula-box">
                <div class="formula-label">E-step: Responsibilities</div>
                <div class="main-formula">$$\gamma_{ik} = \frac{\pi_k \mathcal{N}(x_i|\mu_k, \sigma_k^2)}{\sum_{j=1}^K \pi_j \mathcal{N}(x_i|\mu_j, \sigma_j^2)}$$</div>
            </div>

            <div class="formula-box">
                <div class="formula-label">M-step: Parameter Updates</div>
                <div class="main-formula">
                    $$N_k = \sum_{i=1}^n \gamma_{ik}$$
                    $$\pi_k = \frac{N_k}{n}$$
                    $$\mu_k = \frac{1}{N_k} \sum_{i=1}^n \gamma_{ik} x_i$$
                    $$\sigma_k^2 = \frac{1}{N_k} \sum_{i=1}^n \gamma_{ik} (x_i - \mu_k)^2$$
                </div>
            </div>
        </div>

        <div class="controls">
            <h2>🎮 Interactive Controls</h2>
            
            <div class="control-group">
                <div class="control-item">
                    <label for="numComponents">Number of Components (K):</label>
                    <input type="range" id="numComponents" min="1" max="5" value="2" step="1">
                    <input type="number" id="numComponentsNum" min="1" max="5" value="2" readonly>
                </div>
                
                <div class="control-item">
                    <label for="numPoints">Number of Data Points:</label>
                    <input type="range" id="numPoints" min="50" max="500" value="200" step="50">
                    <input type="number" id="numPointsNum" min="50" max="500" value="200" readonly>
                </div>
                
                <div class="control-item">
                    <label for="animationSpeed">Animation Speed:</label>
                    <input type="range" id="animationSpeed" min="1" max="10" value="5" step="1">
                    <input type="number" id="animationSpeedNum" min="1" max="10" value="5" readonly>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="generateNewData()">🎲 Generate New Data</button>
                <button onclick="randomizeInitialization()">🔄 Random Initialize</button>
                <button onclick="runEMStep()">▶️ Single EM Step</button>
                <button onclick="toggleAnimation()">⏯️ Auto Run</button>
                <button onclick="resetAlgorithm()">🔄 Reset</button>
            </div>
        </div>

        <div class="step-indicator">
            <h3>Current Step: <span id="currentStep">Initialization</span></h3>
            <p>Iteration: <span id="iterationCount">0</span> | Convergence: <span id="convergenceStatus">Not Started</span></p>
        </div>

        <div class="algorithm-steps">
            <h3>🔄 Algorithm Steps</h3>
            <div class="step" id="step0">
                <strong>Initialization:</strong> Set initial parameters π<sub>k</sub>, μ<sub>k</sub>, σ<sub>k</sub>
            </div>
            <div class="step" id="step1">
                <strong>E-step:</strong> Calculate responsibilities γ<sub>ik</sub> for each data point and component
            </div>
            <div class="step" id="step2">
                <strong>M-step:</strong> Update parameters using weighted maximum likelihood estimates
            </div>
            <div class="step" id="step3">
                <strong>Convergence:</strong> Check if log-likelihood has converged
            </div>
        </div>

        <div class="statistics">
            <div class="stat-box">
                <div>Log-Likelihood</div>
                <div class="stat-value" id="logLikelihood">0.00</div>
            </div>
            <div class="stat-box">
                <div>ΔLog-Likelihood</div>
                <div class="stat-value" id="deltaLogLikelihood">0.00</div>
            </div>
            <div class="stat-box">
                <div>AIC</div>
                <div class="stat-value" id="aic">0.00</div>
            </div>
            <div class="stat-box">
                <div>BIC</div>
                <div class="stat-value" id="bic">0.00</div>
            </div>
        </div>

        <div class="visualization-container">
            <div class="canvas-container">
                <h3 style="color: #333; text-align: center; margin-top: 0;">Data and Mixture Components</h3>
                <canvas id="dataCanvas"></canvas>
            </div>
            
            <div class="canvas-container">
                <h3 style="color: #333; text-align: center; margin-top: 0;">Convergence History</h3>
                <canvas id="convergenceCanvas"></canvas>
            </div>
        </div>

        <div class="theory-section">
            <h2>🔍 Key Concepts</h2>
            
            <div class="note">
                <h3>Responsibilities (γ<sub>ik</sub>)</h3>
                <p>The probability that data point i belongs to component k. These "soft assignments" are the key insight of EM - instead of hard clustering, we use probabilistic assignments.</p>
            </div>
            
            <div class="note">
                <h3>Convergence Criteria</h3>
                <p>The algorithm converges when the change in log-likelihood falls below a threshold (typically 10⁻⁶). The log-likelihood is guaranteed to increase at each iteration.</p>
            </div>
            
            <div class="note">
                <h3>Model Selection</h3>
                <p><strong>AIC</strong> (Akaike Information Criterion) and <strong>BIC</strong> (Bayesian Information Criterion) help choose the optimal number of components by balancing fit quality with model complexity.</p>
            </div>
        </div>

        <div class="theory-section">
            <h2>🎯 Applications</h2>
            <ul>
                <li><strong>Clustering:</strong> Gaussian Mixture Models for soft clustering</li>
                <li><strong>Missing Data:</strong> Imputation of missing values in datasets</li>
                <li><strong>Hidden Markov Models:</strong> Parameter estimation in HMMs</li>
                <li><strong>Factor Analysis:</strong> Latent factor discovery</li>
                <li><strong>Image Segmentation:</strong> Pixel clustering in computer vision</li>
                <li><strong>Bioinformatics:</strong> Gene expression analysis and sequence alignment</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let dataPoints = [];
        let trueComponents = [];
        let estimatedComponents = [];
        let responsibilities = [];
        let logLikelihoodHistory = [];
        let iteration = 0;
        let isAnimating = false;
        let animationId = null;
        let convergenceThreshold = 1e-6;
        let previousLogLikelihood = -Infinity;

        // Canvas setup
        const dataCanvas = document.getElementById('dataCanvas');
        const dataCtx = dataCanvas.getContext('2d');
        const convergenceCanvas = document.getElementById('convergenceCanvas');
        const convergenceCtx = convergenceCanvas.getContext('2d');

        // Set canvas size
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach(container => {
                const canvas = container.querySelector('canvas');
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width - 40;
                canvas.height = 400;
            });
        }

        // Initialize
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Color palette for components
        const colors = [
            'rgba(255, 99, 132, 0.8)',   // Red
            'rgba(54, 162, 235, 0.8)',   // Blue
            'rgba(255, 205, 86, 0.8)',   // Yellow
            'rgba(75, 192, 192, 0.8)',   // Teal
            'rgba(153, 102, 255, 0.8)'   // Purple
        ];

        const borderColors = [
            'rgba(255, 99, 132, 1)',
            'rgba(54, 162, 235, 1)',
            'rgba(255, 205, 86, 1)',
            'rgba(75, 192, 192, 1)',
            'rgba(153, 102, 255, 1)'
        ];

        // Utility functions
        function gaussian(x, mu, sigma) {
            return Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2)) / (sigma * Math.sqrt(2 * Math.PI));
        }

        function normalRandom(mu = 0, sigma = 1) {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * sigma + mu;
        }

        // Generate synthetic data from true mixture
        function generateData() {
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const numComponents = parseInt(document.getElementById('numComponents').value);
            
            dataPoints = [];
            trueComponents = [];
            
            // Generate true components
            for (let k = 0; k < numComponents; k++) {
                trueComponents.push({
                    weight: 0.5 + Math.random() * 0.4, // Between 0.5 and 0.9
                    mean: -2 + k * (4 / (numComponents - 1)) + (Math.random() - 0.5) * 0.5,
                    std: 0.3 + Math.random() * 0.4  // Between 0.3 and 0.7
                });
            }
            
            // Normalize weights
            const totalWeight = trueComponents.reduce((sum, comp) => sum + comp.weight, 0);
            trueComponents.forEach(comp => comp.weight /= totalWeight);
            
            // Generate data points
            for (let i = 0; i < numPoints; i++) {
                // Choose component based on weights
                let rand = Math.random();
                let cumWeight = 0;
                let chosenComponent = 0;
                
                for (let k = 0; k < numComponents; k++) {
                    cumWeight += trueComponents[k].weight;
                    if (rand <= cumWeight) {
                        chosenComponent = k;
                        break;
                    }
                }
                
                const component = trueComponents[chosenComponent];
                const point = normalRandom(component.mean, component.std);
                dataPoints.push({
                    x: point,
                    trueComponent: chosenComponent
                });
            }
        }

        // Initialize EM parameters
        function initializeEM() {
            const numComponents = parseInt(document.getElementById('numComponents').value);
            estimatedComponents = [];
            responsibilities = [];
            
            // Initialize components with random parameters
            for (let k = 0; k < numComponents; k++) {
                estimatedComponents.push({
                    weight: 1.0 / numComponents,
                    mean: -2 + Math.random() * 4,  // Between -2 and 2
                    std: 0.5 + Math.random() * 0.5  // Between 0.5 and 1.0
                });
            }
            
            // Initialize responsibilities matrix
            for (let i = 0; i < dataPoints.length; i++) {
                responsibilities[i] = new Array(numComponents).fill(0);
            }
            
            iteration = 0;
            logLikelihoodHistory = [];
            previousLogLikelihood = -Infinity;
            updateStepIndicator("Initialization");
            updateStatistics();
        }

        // E-step: Calculate responsibilities
        function eStep() {
            const numComponents = estimatedComponents.length;
            
            for (let i = 0; i < dataPoints.length; i++) {
                const x = dataPoints[i].x;
                let totalProbability = 0;
                
                // Calculate probability for each component
                for (let k = 0; k < numComponents; k++) {
                    const comp = estimatedComponents[k];
                    const probability = comp.weight * gaussian(x, comp.mean, comp.std);
                    responsibilities[i][k] = probability;
                    totalProbability += probability;
                }
                
                // Normalize to get responsibilities (posterior probabilities)
                for (let k = 0; k < numComponents; k++) {
                    responsibilities[i][k] /= totalProbability;
                }
            }
            
            highlightStep(1);
        }

        // M-step: Update parameters
        function mStep() {
            const numComponents = estimatedComponents.length;
            const n = dataPoints.length;
            
            for (let k = 0; k < numComponents; k++) {
                // Calculate effective number of points assigned to component k
                let Nk = 0;
                for (let i = 0; i < n; i++) {
                    Nk += responsibilities[i][k];
                }
                
                // Update weight
                estimatedComponents[k].weight = Nk / n;
                
                // Update mean
                let weightedSum = 0;
                for (let i = 0; i < n; i++) {
                    weightedSum += responsibilities[i][k] * dataPoints[i].x;
                }
                estimatedComponents[k].mean = weightedSum / Nk;
                
                // Update standard deviation
                let weightedSumSquares = 0;
                for (let i = 0; i < n; i++) {
                    const diff = dataPoints[i].x - estimatedComponents[k].mean;
                    weightedSumSquares += responsibilities[i][k] * diff * diff;
                }
                estimatedComponents[k].std = Math.sqrt(weightedSumSquares / Nk);
            }
            
            highlightStep(2);
        }

        // Calculate log-likelihood
        function calculateLogLikelihood() {
            let logLikelihood = 0;
            
            for (let i = 0; i < dataPoints.length; i++) {
                const x = dataPoints[i].x;
                let likelihood = 0;
                
                for (let k = 0; k < estimatedComponents.length; k++) {
                    const comp = estimatedComponents[k];
                    likelihood += comp.weight * gaussian(x, comp.mean, comp.std);
                }
                
                logLikelihood += Math.log(likelihood);
            }
            
            return logLikelihood;
        }

        // Check convergence
        function checkConvergence() {
            const currentLogLikelihood = calculateLogLikelihood();
            const delta = currentLogLikelihood - previousLogLikelihood;
            
            logLikelihoodHistory.push(currentLogLikelihood);
            
            const converged = Math.abs(delta) < convergenceThreshold;
            
            document.getElementById('convergenceStatus').textContent = 
                converged ? 'Converged' : 'In Progress';
            
            previousLogLikelihood = currentLogLikelihood;
            highlightStep(3);
            
            return converged;
        }

        // Single EM iteration
        function emIteration() {
            updateStepIndicator("E-step");
            eStep();
            
            setTimeout(() => {
                updateStepIndicator("M-step");
                mStep();
                
                setTimeout(() => {
                    updateStepIndicator("Checking Convergence");
                    const converged = checkConvergence();
                    iteration++;
                    
                    updateStatistics();
                    drawVisualization();
                    
                    if (converged) {
                        updateStepIndicator("Converged");
                        if (isAnimating) {
                            toggleAnimation();
                        }
                    } else {
                        updateStepIndicator(`Iteration ${iteration}`);
                    }
                }, 200);
            }, 200);
            
            return !checkConvergence();
        }

        // Update step indicator
        function updateStepIndicator(step) {
            document.getElementById('currentStep').textContent = step;
            document.getElementById('iterationCount').textContent = iteration;
        }

        // Highlight current step
        function highlightStep(stepIndex) {
            // Remove active class from all steps
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Add active class to current step
            if (stepIndex >= 0 && stepIndex < 4) {
                document.getElementById(`step${stepIndex}`).classList.add('active');
            }
        }

        // Update statistics display
        function updateStatistics() {
            if (logLikelihoodHistory.length > 0) {
                const currentLL = logLikelihoodHistory[logLikelihoodHistory.length - 1];
                const deltaLL = logLikelihoodHistory.length > 1 ? 
                    currentLL - logLikelihoodHistory[logLikelihoodHistory.length - 2] : 0;
                
                // Calculate AIC and BIC
                const k = estimatedComponents.length;
                const n = dataPoints.length;
                const numParams = k * 3 - 1; // 3 parameters per component minus 1 for weight constraint
                
                const aic = 2 * numParams - 2 * currentLL;
                const bic = Math.log(n) * numParams - 2 * currentLL;
                
                document.getElementById('logLikelihood').textContent = currentLL.toFixed(2);
                document.getElementById('deltaLogLikelihood').textContent = deltaLL.toFixed(6);
                document.getElementById('aic').textContent = aic.toFixed(2);
                document.getElementById('bic').textContent = bic.toFixed(2);
            }
        }

        // Draw visualization
        function drawVisualization() {
            drawDataVisualization();
            drawConvergenceVisualization();
        }

        // Draw data and components
        function drawDataVisualization() {
            dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);
            
            // Find data range
            const xMin = Math.min(...dataPoints.map(p => p.x)) - 1;
            const xMax = Math.max(...dataPoints.map(p => p.x)) + 1;
            const xRange = xMax - xMin;
            
            // Draw estimated components as curves
            for (let k = 0; k < estimatedComponents.length; k++) {
                const comp = estimatedComponents[k];
                dataCtx.strokeStyle = borderColors[k];
                dataCtx.lineWidth = 3;
                dataCtx.beginPath();
                
                let maxY = 0;
                for (let x = xMin; x <= xMax; x += 0.05) {
                    const y = comp.weight * gaussian(x, comp.mean, comp.std);
                    maxY = Math.max(maxY, y);
                }
                
                for (let x = xMin; x <= xMax; x += 0.05) {
                    const canvasX = ((x - xMin) / xRange) * dataCanvas.width;
                    const y = comp.weight * gaussian(x, comp.mean, comp.std);
                    const canvasY = dataCanvas.height - (y / maxY) * (dataCanvas.height - 100);
                    
                    if (x === xMin) {
                        dataCtx.moveTo(canvasX, canvasY);
                    } else {
                        dataCtx.lineTo(canvasX, canvasY);
                    }
                }
                dataCtx.stroke();
                
                // Draw component parameters
                dataCtx.fillStyle = colors[k];
                dataCtx.font = '12px Arial';
                const meanX = ((comp.mean - xMin) / xRange) * dataCanvas.width;
                dataCtx.fillText(
                    `μ${k+1}=${comp.mean.toFixed(2)}, σ${k+1}=${comp.std.toFixed(2)}, π${k+1}=${comp.weight.toFixed(2)}`, 
                    meanX - 50, 20 + k * 20
                );
            }
            
            // Draw data points colored by most likely component
            for (let i = 0; i < dataPoints.length; i++) {
                const point = dataPoints[i];
                const canvasX = ((point.x - xMin) / xRange) * dataCanvas.width;
                const canvasY = dataCanvas.height - 20;
                
                // Find most likely component
                let maxResponsibility = 0;
                let likelyComponent = 0;
                for (let k = 0; k < estimatedComponents.length; k++) {
                    if (responsibilities[i] && responsibilities[i][k] > maxResponsibility) {
                        maxResponsibility = responsibilities[i][k];
                        likelyComponent = k;
                    }
                }
                
                dataCtx.fillStyle = colors[likelyComponent];
                dataCtx.beginPath();
                dataCtx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                dataCtx.fill();
            }
            
            // Draw axis
            dataCtx.strokeStyle = '#333';
            dataCtx.lineWidth = 2;
            dataCtx.beginPath();
            dataCtx.moveTo(0, dataCanvas.height - 20);
            dataCtx.lineTo(dataCanvas.width, dataCanvas.height - 20);
            dataCtx.stroke();
        }

        // Draw convergence history
        function drawConvergenceVisualization() {
            convergenceCtx.clearRect(0, 0, convergenceCanvas.width, convergenceCanvas.height);
            
            if (logLikelihoodHistory.length < 2) return;
            
            // Find range
            const minLL = Math.min(...logLikelihoodHistory);
            const maxLL = Math.max(...logLikelihoodHistory);
            const range = maxLL - minLL;
            
            // Draw grid
            convergenceCtx.strokeStyle = '#ddd';
            convergenceCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * (convergenceCanvas.height - 60) + 30;
                convergenceCtx.beginPath();
                convergenceCtx.moveTo(50, y);
                convergenceCtx.lineTo(convergenceCanvas.width - 20, y);
                convergenceCtx.stroke();
            }
            
            // Draw log-likelihood curve
            convergenceCtx.strokeStyle = '#FF6B6B';
            convergenceCtx.lineWidth = 3;
            convergenceCtx.beginPath();
            
            for (let i = 0; i < logLikelihoodHistory.length; i++) {
                const x = 50 + (i / (logLikelihoodHistory.length - 1)) * (convergenceCanvas.width - 70);
                const y = range > 0 ? 
                    convergenceCanvas.height - 30 - ((logLikelihoodHistory[i] - minLL) / range) * (convergenceCanvas.height - 60) :
                    convergenceCanvas.height / 2;
                
                if (i === 0) {
                    convergenceCtx.moveTo(x, y);
                } else {
                    convergenceCtx.lineTo(x, y);
                }
            }
            convergenceCtx.stroke();
            
            // Draw points
            convergenceCtx.fillStyle = '#FF6B6B';
            for (let i = 0; i < logLikelihoodHistory.length; i++) {
                const x = 50 + (i / (logLikelihoodHistory.length - 1)) * (convergenceCanvas.width - 70);
                const y = range > 0 ? 
                    convergenceCanvas.height - 30 - ((logLikelihoodHistory[i] - minLL) / range) * (convergenceCanvas.height - 60) :
                    convergenceCanvas.height / 2;
                
                convergenceCtx.beginPath();
                convergenceCtx.arc(x, y, 4, 0, 2 * Math.PI);
                convergenceCtx.fill();
            }
            
            // Labels
            convergenceCtx.fillStyle = '#333';
            convergenceCtx.font = '12px Arial';
            convergenceCtx.fillText('Log-Likelihood', 10, 20);
            convergenceCtx.fillText('Iteration', convergenceCanvas.width / 2, convergenceCanvas.height - 5);
            
            // Y-axis labels
            for (let i = 0; i <= 5; i++) {
                const value = minLL + (i / 5) * range;
                const y = convergenceCanvas.height - 30 - (i / 5) * (convergenceCanvas.height - 60);
                convergenceCtx.fillText(value.toFixed(1), 5, y + 3);
            }
        }

        // Event handlers
        function generateNewData() {
            generateData();
            initializeEM();
            drawVisualization();
        }

        function randomizeInitialization() {
            initializeEM();
            drawVisualization();
        }

        function runEMStep() {
            if (checkConvergence() && iteration > 0) {
                updateStepIndicator("Already Converged");
                return;
            }
            emIteration();
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            
            if (isAnimating) {
                document.querySelector('button[onclick="toggleAnimation()"]').textContent = '⏸️ Pause';
                animateEM();
            } else {
                document.querySelector('button[onclick="toggleAnimation()"]').textContent = '▶️ Auto Run';
                if (animationId) {
                    clearTimeout(animationId);
                }
            }
        }

        function animateEM() {
            if (!isAnimating) return;
            
            const speed = parseInt(document.getElementById('animationSpeed').value);
            const delay = 1100 - speed * 100; // Faster speed = shorter delay
            
            if (!checkConvergence() || iteration === 0) {
                emIteration();
                animationId = setTimeout(animateEM, delay);
            } else {
                isAnimating = false;
                document.querySelector('button[onclick="toggleAnimation()"]').textContent = '▶️ Auto Run';
            }
        }

        function resetAlgorithm() {
            isAnimating = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            document.querySelector('button[onclick="toggleAnimation()"]').textContent = '▶️ Auto Run';
            
            initializeEM();
            drawVisualization();
            
            // Reset step highlighting
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            highlightStep(0);
        }

        // Control synchronization
        function syncControls() {
            // Sync sliders with number inputs
            const controls = [
                'numComponents', 'numPoints', 'animationSpeed'
            ];
            
            controls.forEach(id => {
                const slider = document.getElementById(id);
                const numberInput = document.getElementById(id + 'Num');
                
                slider.addEventListener('input', () => {
                    numberInput.value = slider.value;
                    if (id === 'numComponents' || id === 'numPoints') {
                        generateNewData();
                    }
                });
                
                numberInput.addEventListener('change', () => {
                    slider.value = numberInput.value;
                    if (id === 'numComponents' || id === 'numPoints') {
                        generateNewData();
                    }
                });
            });
        }

        // Initialize everything
        window.addEventListener('load', () => {
            syncControls();
            generateNewData();
            highlightStep(0);
            
            // Initialize MathJax
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        });
    </script>
</body>
</html>
