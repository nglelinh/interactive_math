<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Convex & Non-Convex Functions - Multiple Variables</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            margin: 0;
            padding: 30px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            font-size: 18px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 40px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            border-bottom: 4px solid #00d4ff;
            padding-bottom: 20px;
        }
        
        h2 {
            color: #00d4ff;
            font-size: 2.2em;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 6px solid #00d4ff;
            padding-left: 20px;
        }
        
        h3 {
            color: #ffffff;
            font-size: 1.6em;
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        h4 {
            color: #00d4ff;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        p, li {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
            color: #ffffff;
        }
        
        .toggle-buttons {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            gap: 20px;
        }
        
        .toggle-btn {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border: 3px solid #00d4ff;
            background: rgba(255, 255, 255, 0.1);
            color: #00d4ff;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        
        .toggle-btn.active {
            background: #00d4ff;
            color: #1a1a2e;
            transform: scale(1.05);
        }
        
        .toggle-btn:hover {
            background: #00d4ff;
            color: #1a1a2e;
            transform: scale(1.02);
        }
        
        .section {
            margin: 30px 0;
        }
        
        .example {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            font-size: 18px;
            line-height: 1.8;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .example h3, .example h4 {
            color: #fff;
            margin-top: 15px;
        }
        
        .example strong {
            color: #ffd700;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin: 20px 0;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 8px;
            color: #00d4ff;
        }
        
        .control-group select, .control-group input[type="range"] {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #00d4ff;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .control-group input[type="range"] {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 5px;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .value-display {
            font-weight: bold;
            color: #ffd700;
            font-size: 18px;
        }
        
        #threejs-container {
            border: 3px solid #00d4ff;
            border-radius: 10px;
            margin: 25px auto;
            background: #000;
            box-shadow: 0 8px 25px rgba(0,212,255,0.3);
            width: 100%;
            height: 600px;
            position: relative;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 20px;
            color: #ffffff;
        }
        
        ul {
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 12px;
        }
        
        .proof-section {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #ffd700;
        }
        
        .proof-section h5 {
            color: #ffd700;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .proof-section p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .highlight-box h3, .highlight-box h4 {
            color: white;
            margin-top: 10px;
        }
        
        .convex-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .function-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .function-card h4 {
            color: #00d4ff;
            margin-top: 0;
        }
        
        .function-card .formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Times New Roman', serif;
            font-size: 16px;
            color: #ffffff;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
            color: #ffffff;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #00d4ff;
            backdrop-filter: blur(10px);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎲 3D Convex & Non-Convex Functions - Multiple Variables</h1>
        
        <div class="toggle-buttons">
            <button class="toggle-btn active" id="theoryBtn" onclick="showSection('theory')">📚 Theory</button>
            <button class="toggle-btn" id="illustrationBtn" onclick="showSection('illustration')">🎮 3D Visualization</button>
        </div>

        <div id="theorySection" class="section theory">
            <h2>🔬 Mathematical Theory</h2>
            
            <div class="highlight-box">
                <h3>🚀 Why Convexity Matters in AI & Optimization</h3>
                <p><strong>Convex functions = Global Optimization Guarantee!</strong> Every local minimum is a global minimum. This is why linear regression, SVM, and many deep learning components use convex loss functions. No more getting stuck in bad local minima!</p>
            </div>

            <h3>Definition of Convex Functions (Multiple Variables)</h3>
            <p>
                A function \( f: \mathbb{R}^n \rightarrow \mathbb{R} \) is <strong>convex</strong> if for all \( \mathbf{x}, \mathbf{y} \in \text{domain}(f) \) and all \( \lambda \in [0,1] \):
            </p>
            <div class="math-formula">
                \[
                    f(\lambda \mathbf{x} + (1-\lambda) \mathbf{y}) \leq \lambda f(\mathbf{x}) + (1-\lambda) f(\mathbf{y})
                \]
            </div>
            <p>
                <strong>Geometric Interpretation:</strong> The function lies below the line segment connecting any two points on its graph.
            </p>

            <h3>Second-Order Characterization (Hessian Test)</h3>
            <p>
                For twice-differentiable functions, \( f \) is convex if and only if its <strong>Hessian matrix</strong> \( H_f(\mathbf{x}) \) is positive semidefinite for all \( \mathbf{x} \):
            </p>
            <div class="math-formula">
                \[
                    H_f(\mathbf{x}) = \begin{bmatrix}
                        \frac{\partial^2 f}{\partial x_1^2} & \frac{\partial^2 f}{\partial x_1 \partial x_2} \\
                        \frac{\partial^2 f}{\partial x_2 \partial x_1} & \frac{\partial^2 f}{\partial x_2^2}
                    \end{bmatrix} \succeq 0
                \]
            </div>

            <div class="convex-examples">
                <div class="function-card">
                    <h4>✅ Convex: Quadratic Bowl</h4>
                    <div class="formula">f(x,y) = x² + y²</div>
                    <p>Classic convex shape - guaranteed global minimum at origin</p>
                </div>
                
                <div class="function-card">
                    <h4>✅ Convex: Exponential</h4>
                    <div class="formula">f(x,y) = e^(x+y)</div>
                    <p>Always convex - exponential grows faster than linear</p>
                </div>
                
                <div class="function-card">
                    <h4>❌ Non-Convex: Rosenbrock</h4>
                    <div class="formula">f(x,y) = (1-x)² + 100(y-x²)²</div>
                    <p>Famous "banana valley" - challenging optimization landscape</p>
                </div>
                
                <div class="function-card">
                    <h4>❌ Non-Convex: Saddle</h4>
                    <div class="formula">f(x,y) = x² - y²</div>
                    <p>Hyperbolic paraboloid - saddle point at origin</p>
                </div>
            </div>

            <div class="example">
                <h4>🏭 Real-World Applications:</h4>
                <ul>
                    <li><strong>🎯 Portfolio Optimization:</strong> Quadratic risk functions (convex) → guaranteed optimal portfolio</li>
                    <li><strong>🏗️ Engineering Design:</strong> Weight minimization subject to strength constraints</li>
                    <li><strong>📊 Data Fitting:</strong> Least squares problems always convex</li>
                    <li><strong>🧠 Neural Networks:</strong> Loss landscape analysis for training dynamics</li>
                    <li><strong>🚀 Aerospace:</strong> Trajectory optimization with fuel constraints</li>
                </ul>
            </div>
        </div>

        <div id="illustrationSection" class="section" style="display:none;">
            <h2>🎮 Interactive 3D Visualization</h2>
            
            <div class="control-panel">
                <div class="controls-grid">
                    <div class="control-group">
                        <label>🎛️ Function Type:</label>
                        <select id="functionType" onchange="updateVisualization()">
                            <option value="quadratic_convex">✅ Convex Quadratic (x² + y²)</option>
                            <option value="quadratic_scaled">✅ Scaled Quadratic (ax² + by²)</option>
                            <option value="exponential">✅ Exponential (e^(x+y))</option>
                            <option value="log_sum_exp">✅ Log-Sum-Exp</option>
                            <option value="norm_l1">✅ L1 Norm (|x| + |y|)</option>
                            <option value="norm_l2">✅ L2 Norm (√(x² + y²))</option>
                            <option value="rosenbrock">❌ Non-Convex: Rosenbrock</option>
                            <option value="himmelblau">❌ Non-Convex: Himmelblau</option>
                            <option value="saddle">❌ Non-Convex: Saddle (x²-y²)</option>
                            <option value="sine_product">❌ Non-Convex: sin(x)sin(y)</option>
                            <option value="ackley">❌ Non-Convex: Ackley</option>
                            <option value="beale">❌ Non-Convex: Beale</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>📏 Grid Resolution: <span class="value-display" id="resolutionValue">50</span></label>
                        <input type="range" id="resolutionSlider" min="20" max="100" step="10" value="50" oninput="updateVisualization()">
                    </div>
                    
                    <div class="control-group">
                        <label>🔍 Zoom Level: <span class="value-display" id="zoomValue">5</span></label>
                        <input type="range" id="zoomSlider" min="2" max="10" step="0.5" value="5" oninput="updateVisualization()">
                    </div>
                    
                    <div class="control-group">
                        <label>🎨 Color Scheme:</label>
                        <select id="colorScheme" onchange="updateVisualization()">
                            <option value="rainbow">🌈 Rainbow</option>
                            <option value="blue_red">🔵🔴 Blue-Red</option>
                            <option value="green_yellow">🟢🟡 Green-Yellow</option>
                            <option value="purple_orange">🟣🟠 Purple-Orange</option>
                            <option value="grayscale">⚫⚪ Grayscale</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>🎮 Visualization Options:</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="showWireframe" onchange="updateVisualization()"> 🕸️ Wireframe</label>
                        <label><input type="checkbox" id="showAxes" checked onchange="updateVisualization()"> 📐 Axes</label>
                        <label><input type="checkbox" id="showContours" onchange="updateVisualization()"> 📊 Contour Lines</label>
                        <label><input type="checkbox" id="enableRotation" checked onchange="toggleRotation()"> 🔄 Auto-Rotate</label>
                    </div>
                </div>
            </div>

            <div id="threejs-container">
                <div class="camera-controls">
                    🖱️ Left Click: Rotate | 🖱️ Right Click: Pan | 🎚️ Scroll: Zoom
                </div>
            </div>
            
            <div class="info-panel">
                <h4>📊 Function Analysis:</h4>
                <div id="functionDetails">Select a function to see its mathematical properties...</div>
            </div>

            <div class="example">
                <h4>🎮 3D Interaction Guide:</h4>
                <ul>
                    <li><strong>🖱️ Mouse Controls:</strong> Left-click and drag to rotate, right-click to pan, scroll to zoom</li>
                    <li><strong>🎛️ Function Selection:</strong> Compare convex vs non-convex 3D surfaces</li>
                    <li><strong>🔍 Resolution Control:</strong> Adjust mesh density for performance vs quality</li>
                    <li><strong>🎨 Color Mapping:</strong> Height-based coloring reveals function behavior</li>
                    <li><strong>🕸️ Wireframe Mode:</strong> See the underlying mesh structure</li>
                    <li><strong>📐 Coordinate System:</strong> Red=X, Green=Y, Blue=Z axes</li>
                </ul>
            </div>
        </div>
    </div>
            <div class="math-formula">
                \[
                    H_f(\mathbf{x}) = \begin{bmatrix}
                        \frac{\partial^2 f}{\partial x_1^2} & \frac{\partial^2 f}{\partial x_1 \partial x_2} & \cdots \\
                        \frac{\partial^2 f}{\partial x_2 \partial x_1} & \frac{\partial^2 f}{\partial x_2^2} & \cdots \\
                        \vdots & \vdots & \ddots
                    \end{bmatrix} \succeq 0
                \]
            </div>

            <div class="example">
                <h4>🧠 Machine Learning Applications:</h4>
                <ul>
                    <li><strong>🎯 Linear Regression:</strong> MSE loss \( L(\mathbf{w}) = \frac{1}{2}\|\mathbf{X}\mathbf{w} - \mathbf{y}\|^2 \) is convex → guaranteed global minimum!</li>
                    <li><strong>🔍 Logistic Regression:</strong> Cross-entropy loss is convex → reliable convergence</li>
                    <li><strong>📊 SVM:</strong> Hinge loss + L2 regularization = convex optimization problem</li>
                    <li><strong>🏗️ Neural Networks:</strong> Individual layers often convex, but composition creates non-convexity</li>
                </ul>
            </div>

            <h3>Common Convex Functions (2 Variables)</h3>
            <div class="convex-examples">
                <div class="function-card">
                    <h4>Quadratic Bowl</h4>
                    <div class="formula">\( f(x,y) = ax^2 + by^2 + cxy + dx + ey + f \)</div>
                    <p><strong>Convex when:</strong> \( a > 0, b > 0, ab > \frac{c^2}{4} \)</p>
                </div>
                
                <div class="function-card">
                    <h4>Norm Functions</h4>
                    <div class="formula">\( f(x,y) = \|(x,y)\|_p \) where \( p \geq 1 \)</div>
                    <p><strong>Always convex</strong> for \( p \geq 1 \)</p>
                </div>
                
                <div class="function-card">
                    <h4>Exponential</h4>
                    <div class="formula">\( f(x,y) = e^{ax + by + c} \)</div>
                    <p><strong>Always convex</strong> for any \( a, b, c \)</p>
                </div>
                
                <div class="function-card">
                    <h4>Log-Sum-Exp</h4>
                    <div class="formula">\( f(x,y) = \log(e^x + e^y) \)</div>
                    <p><strong>Always convex</strong> - common in ML!</p>
                </div>
            </div>

            <h3>Non-Convex Functions Examples</h3>
            <div class="convex-examples">
                <div class="function-card">
                    <h4>Rosenbrock Function</h4>
                    <div class="formula">\( f(x,y) = (1-x)^2 + 100(y-x^2)^2 \)</div>
                    <p><strong>Non-convex:</strong> Banana-shaped valley with global minimum at (1,1)</p>
                </div>
                
                <div class="function-card">
                    <h4>Himmelblau's Function</h4>
                    <div class="formula">\( f(x,y) = (x^2+y-11)^2 + (x+y^2-7)^2 \)</div>
                    <p><strong>Non-convex:</strong> 4 global minima, challenging for optimization</p>
                </div>
                
                <div class="function-card">
                    <h4>Saddle Function</h4>
                    <div class="formula">\( f(x,y) = x^2 - y^2 \)</div>
                    <p><strong>Non-convex:</strong> Classic saddle point at origin</p>
                </div>
                
                <div class="function-card">
                    <h4>Sine Product</h4>
                    <div class="formula">\( f(x,y) = \sin(x) \sin(y) \)</div>
                    <p><strong>Non-convex:</strong> Oscillating surface with many local extrema</p>
                </div>
            </div>

            <div class="example">
                <h4>🔥 Optimization Implications:</h4>
                <ul>
                    <li><strong>✅ Convex Functions:</strong> Any local minimum = global minimum</li>
                    <li><strong>✅ Gradient Descent:</strong> Guaranteed to find global optimum</li>
                    <li><strong>✅ Linear Constraints:</strong> Feasible region remains convex</li>
                    <li><strong>⚠️ Non-Convex Functions:</strong> Multiple local minima possible</li>
                    <li><strong>⚠️ Global Optimization:</strong> Requires advanced techniques (simulated annealing, genetic algorithms)</li>
                </ul>
            </div>

            <h3>Mathematical Tests for Convexity</h3>
            <div class="highlight-box">
                <h4>📐 Hessian Eigenvalue Test:</h4>
                <p>For \( f(x,y) \), compute Hessian:</p>
                <div class="math-formula">
                    \[
                        H = \begin{bmatrix}
                            f_{xx} & f_{xy} \\
                            f_{yx} & f_{yy}
                        \end{bmatrix}
                    \]
                </div>
                <ul>
                    <li><strong>Convex:</strong> Both eigenvalues ≥ 0 everywhere</li>
                    <li><strong>Strictly Convex:</strong> Both eigenvalues > 0 everywhere</li>
                    <li><strong>Non-Convex:</strong> At least one eigenvalue < 0 somewhere</li>
                </ul>
            </div>

            <div class="example">
                <h4>🏭 Real-World Applications:</h4>
                <ul>
                    <li><strong>🎯 Portfolio Optimization:</strong> Quadratic risk functions (convex) → guaranteed optimal portfolio</li>
                    <li><strong>🏗️ Engineering Design:</strong> Weight minimization subject to strength constraints</li>
                    <li><strong>📊 Data Fitting:</strong> Least squares problems always convex</li>
                    <li><strong>🧠 Neural Networks:</strong> Loss landscape analysis for training dynamics</li>
                    <li><strong>🚀 Aerospace:</strong> Trajectory optimization with fuel constraints</li>
                </ul>
            </div>
        </div>

        <div id="illustrationSection" class="section" style="display:none;">
            <h2>Interactive Convex/Non-Convex Function Visualization</h2>
            
            <div class="control-panel">
                <div class="control-group">
                    <label>Function Type:</label>
                    <select id="functionType" onchange="updateVisualization()">
                        <option value="quadratic_convex">Convex Quadratic (x² + y²)</option>
                        <option value="norm_l1">L1 Norm (|x| + |y|)</option>
                        <option value="norm_l2">L2 Norm (√(x² + y²))</option>
                        <option value="exponential">Exponential (e^(x+y))</option>
                        <option value="log_sum_exp">Log-Sum-Exp</option>
                        <option value="rosenbrock">Non-Convex: Rosenbrock</option>
                        <option value="himmelblau">Non-Convex: Himmelblau</option>
                        <option value="saddle">Non-Convex: Saddle (x²-y²)</option>
                        <option value="sine_product">Non-Convex: sin(x)sin(y)</option>
                        <option value="ackley">Non-Convex: Ackley</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Point A - X: <span class="value-display" id="pointAX">-1</span></label>
                    <input type="range" id="pointAXSlider" min="-3" max="3" step="0.1" value="-1" oninput="updateVisualization()">
                </div>
                
                <div class="control-group">
                    <label>Point A - Y: <span class="value-display" id="pointAY">-1</span></label>
                    <input type="range" id="pointAYSlider" min="-3" max="3" step="0.1" value="-1" oninput="updateVisualization()">
                </div>
                
                <div class="control-group">
                    <label>Point B - X: <span class="value-display" id="pointBX">1</span></label>
                    <input type="range" id="pointBXSlider" min="-3" max="3" step="0.1" value="1" oninput="updateVisualization()">
                </div>
                
                <div class="control-group">
                    <label>Point B - Y: <span class="value-display" id="pointBY">1</span></label>
                    <input type="range" id="pointBYSlider" min="-3" max="3" step="0.1" value="1" oninput="updateVisualization()">
                </div>
                
                <div class="control-group">
                    <label>λ (Convex Combination): <span class="value-display" id="lambdaValue">0.5</span></label>
                    <input type="range" id="lambdaSlider" min="0" max="1" step="0.01" value="0.5" oninput="updateVisualization()">
                </div>
                
                <div class="control-group">
                    <label>Visualization Options:</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="showContours" checked onchange="updateVisualization()"> Contour Lines</label>
                        <label><input type="checkbox" id="showLineSegment" checked onchange="updateVisualization()"> Line Segment AB</label>
                        <label><input type="checkbox" id="showConvexTest" checked onchange="updateVisualization()"> Convexity Test</label>
                        <label><input type="checkbox" id="showHessian" onchange="updateVisualization()"> Hessian Info</label>
                    </div>
                </div>
            </div>

            <canvas id="convexCanvas" width="1000" height="600"></canvas>
            
            <div id="convexity-proof" class="example">
                <h4>🔍 Mathematical Convexity Proofs</h4>
                <div id="proof-content">
                    <p><em>Select a function to see its mathematical proof of convexity or non-convexity...</em></p>
                </div>
            </div>
            
            <div id="convexInfo" class="example">
                <h4>📊 Function Analysis:</h4>
                <div id="functionDetails"></div>
                <div id="convexityTest"></div>
                <div id="hessianInfo" style="display:none;"></div>
            </div>

            <div class="example">
                <h4>🎮 Interactive Instructions:</h4>
                <ul>
                    <li><strong>Choose Function Type:</strong> Compare convex vs non-convex functions</li>
                    <li><strong>Move Points A & B:</strong> See how line segment relates to function surface</li>
                    <li><strong>Adjust λ:</strong> Explore convex combinations along the line segment</li>
                    <li><strong>Convexity Test:</strong> Red line = function values, Blue line = linear interpolation</li>
                    <li><strong>For Convex Functions:</strong> Red line always ≤ Blue line</li>
                    <li><strong>For Non-Convex Functions:</strong> Red line can go above Blue line</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 3D Scene setup
        let scene, camera, renderer, controls;
        let surfaceMesh, wireframeMesh;
        let axesHelper;
        let currentFunction = 'quadratic_convex';
        let rotationEnabled = true;
        
        // Function definitions
        const functions = {
            quadratic_convex: {
                fn: (x, y) => x*x + y*y,
                name: 'Convex Quadratic',
                formula: 'f(x,y) = x² + y²',
                isConvex: true,
                description: 'Classic bowl shape - guaranteed global minimum at origin'
            },
            quadratic_scaled: {
                fn: (x, y) => 2*x*x + 0.5*y*y,
                name: 'Scaled Quadratic',
                formula: 'f(x,y) = 2x² + 0.5y²',
                isConvex: true,
                description: 'Elliptical bowl - different curvatures in x and y directions'
            },
            exponential: {
                fn: (x, y) => Math.exp(x + y),
                name: 'Exponential',
                formula: 'f(x,y) = e^(x+y)',
                isConvex: true,
                description: 'Always convex - exponential growth in all directions'
            },
            log_sum_exp: {
                fn: (x, y) => Math.log(Math.exp(x) + Math.exp(y)),
                name: 'Log-Sum-Exp',
                formula: 'f(x,y) = log(e^x + e^y)',
                isConvex: true,
                description: 'Smooth maximum function - widely used in machine learning'
            },
            norm_l1: {
                fn: (x, y) => Math.abs(x) + Math.abs(y),
                name: 'L1 Norm',
                formula: 'f(x,y) = |x| + |y|',
                isConvex: true,
                description: 'Diamond/pyramid shape - not differentiable at axes'
            },
            norm_l2: {
                fn: (x, y) => Math.sqrt(x*x + y*y),
                name: 'L2 Norm',
                formula: 'f(x,y) = √(x² + y²)',
                isConvex: true,
                description: 'Cone shape - Euclidean distance from origin'
            },
            rosenbrock: {
                fn: (x, y) => (1-x)*(1-x) + 100*(y-x*x)*(y-x*x),
                name: 'Rosenbrock Function',
                formula: 'f(x,y) = (1-x)² + 100(y-x²)²',
                isConvex: false,
                description: 'Famous "banana valley" - challenging optimization landscape'
            },
            himmelblau: {
                fn: (x, y) => (x*x + y - 11)*(x*x + y - 11) + (x + y*y - 7)*(x + y*y - 7),
                name: 'Himmelblau Function',
                formula: 'f(x,y) = (x²+y-11)² + (x+y²-7)²',
                isConvex: false,
                description: 'Four global minima - multimodal optimization challenge'
            },
            saddle: {
                fn: (x, y) => x*x - y*y,
                name: 'Saddle Function',
                formula: 'f(x,y) = x² - y²',
                isConvex: false,
                description: 'Hyperbolic paraboloid - classic saddle point at origin'
            },
            sine_product: {
                fn: (x, y) => Math.sin(x) * Math.sin(y),
                name: 'Sine Product',
                formula: 'f(x,y) = sin(x)sin(y)',
                isConvex: false,
                description: 'Oscillating surface with many local extrema'
            },
            ackley: {
                fn: (x, y) => {
                    const a = 20, b = 0.2, c = 2*Math.PI;
                    const term1 = -a * Math.exp(-b * Math.sqrt(0.5 * (x*x + y*y)));
                    const term2 = -Math.exp(0.5 * (Math.cos(c*x) + Math.cos(c*y)));
                    return term1 + term2 + a + Math.E;
                },
                name: 'Ackley Function',
                formula: 'f(x,y) = Complex exponential function',
                isConvex: false,
                description: 'Highly multimodal with global minimum surrounded by many local minima'
            },
            beale: {
                fn: (x, y) => {
                    const term1 = (1.5 - x + x*y) * (1.5 - x + x*y);
                    const term2 = (2.25 - x + x*y*y) * (2.25 - x + x*y*y);
                    const term3 = (2.625 - x + x*y*y*y) * (2.625 - x + x*y*y*y);
                    return term1 + term2 + term3;
                },
                name: 'Beale Function',
                formula: 'f(x,y) = (1.5-x+xy)² + (2.25-x+xy²)² + (2.625-x+xy³)²',
                isConvex: false,
                description: 'Unimodal function with sharp ridge - optimization benchmark'
            }
        };
        
        // Color schemes
        const colorSchemes = {
            rainbow: { colors: [0x0000ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff0000] },
            blue_red: { colors: [0x0066ff, 0x6699ff, 0xffcc99, 0xff6600, 0xff0000] },
            green_yellow: { colors: [0x006600, 0x66cc00, 0xccff66, 0xffff00, 0xffcc00] },
            purple_orange: { colors: [0x6600cc, 0x9966ff, 0xcc99ff, 0xff9966, 0xff6600] },
            grayscale: { colors: [0x000000, 0x404040, 0x808080, 0xc0c0c0, 0xffffff] }
        };
        
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.enableZoom = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Axes Helper
            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Initial visualization
            updateVisualization();
            
            // Animation loop
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function createSurface(functionName, resolution, range, colorScheme) {
            const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution - 1, resolution - 1);
            const vertices = geometry.attributes.position.array;
            const colors = [];
            
            let minZ = Infinity, maxZ = -Infinity;
            
            // First pass: calculate z values and find min/max
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = functions[functionName].fn(x, y);
                
                // Clamp extreme values
                const clampedZ = Math.max(-20, Math.min(20, z));
                vertices[i + 2] = clampedZ;
                
                if (isFinite(clampedZ)) {
                    minZ = Math.min(minZ, clampedZ);
                    maxZ = Math.max(maxZ, clampedZ);
                }
            }
            
            // Second pass: assign colors based on height
            const scheme = colorSchemes[colorScheme];
            for (let i = 0; i < vertices.length; i += 3) {
                const z = vertices[i + 2];
                const normalized = maxZ > minZ ? (z - minZ) / (maxZ - minZ) : 0.5;
                
                const colorIndex = Math.floor(normalized * (scheme.colors.length - 1));
                const nextColorIndex = Math.min(colorIndex + 1, scheme.colors.length - 1);
                const t = (normalized * (scheme.colors.length - 1)) - colorIndex;
                
                const color1 = new THREE.Color(scheme.colors[colorIndex]);
                const color2 = new THREE.Color(scheme.colors[nextColorIndex]);
                const finalColor = color1.lerp(color2, t);
                
                colors.push(finalColor.r, finalColor.g, finalColor.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        function updateVisualization() {
            // Update display values
            const resolutionSlider = document.getElementById('resolutionSlider');
            const zoomSlider = document.getElementById('zoomSlider');
            const functionType = document.getElementById('functionType').value;
            const colorScheme = document.getElementById('colorScheme').value;
            
            if (resolutionSlider) {
                document.getElementById('resolutionValue').textContent = resolutionSlider.value;
            }
            if (zoomSlider) {
                document.getElementById('zoomValue').textContent = zoomSlider.value;
            }
            
            if (!scene) return;
            
            // Remove existing surfaces
            if (surfaceMesh) {
                scene.remove(surfaceMesh);
                surfaceMesh.geometry.dispose();
                surfaceMesh.material.dispose();
            }
            if (wireframeMesh) {
                scene.remove(wireframeMesh);
                wireframeMesh.geometry.dispose();
                wireframeMesh.material.dispose();
            }
            
            // Get parameters
            const resolution = parseInt(resolutionSlider?.value || 50);
            const range = parseFloat(zoomSlider?.value || 5);
            currentFunction = functionType;
            
            // Create new surface
            const geometry = createSurface(functionType, resolution, range, colorScheme);
            
            // Surface material
            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            surfaceMesh = new THREE.Mesh(geometry, material);
            surfaceMesh.receiveShadow = true;
            scene.add(surfaceMesh);
            
            // Wireframe if enabled
            const showWireframe = document.getElementById('showWireframe')?.checked;
            if (showWireframe) {
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                wireframeMesh = new THREE.Mesh(geometry.clone(), wireframeMaterial);
                scene.add(wireframeMesh);
            }
            
            // Update axes visibility
            const showAxes = document.getElementById('showAxes')?.checked;
            axesHelper.visible = showAxes !== false;
            
            // Update function info
            updateFunctionInfo();
            updateConvexityProof();
        }
        
        function updateFunctionInfo() {
            const functionDetails = document.getElementById('functionDetails');
            if (!functionDetails) return;
            
            const func = functions[currentFunction];
            const convexStatus = func.isConvex ? '✅ CONVEX' : '❌ NON-CONVEX';
            const convexColor = func.isConvex ? '#00ff88' : '#ff4444';
            
            functionDetails.innerHTML = `
                <div style="border-left: 4px solid ${convexColor}; padding-left: 15px;">
                    <h4 style="color: ${convexColor}; margin: 0 0 10px 0;">${func.name}</h4>
                    <p><strong>Formula:</strong> ${func.formula}</p>
                    <p><strong>Status:</strong> <span style="color: ${convexColor}; font-weight: bold;">${convexStatus}</span></p>
                    <p><strong>Description:</strong> ${func.description}</p>
                    ${func.isConvex ? 
                        '<p><strong>🎯 Optimization:</strong> Guaranteed global minimum - any local minimum is global!</p>' :
                        '<p><strong>⚠️ Optimization:</strong> Multiple local minima possible - requires advanced optimization techniques!</p>'
                    }
                </div>
            `;
        }
        
        function updateConvexityProof() {
            const proofContent = document.getElementById('proof-content');
            if (!proofContent) return;
            
            const proofs = {
                'quadratic_convex': {
                    title: 'Proof: f(x,y) = x² + y² is Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>📐 Method 1: Hessian Matrix Test</h5>
                            <p><strong>Step 1:</strong> Compute the Hessian matrix:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂²f/∂x² = 2, ∂²f/∂y² = 2, ∂²f/∂x∂y = 0<br>
                                H = [2  0]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;[0  2]
                            </div>
                            <p><strong>Step 2:</strong> Check positive definiteness:</p>
                            <p>• Eigenvalues: λ₁ = 2, λ₂ = 2 (both positive ✅)</p>
                            <p>• Determinant: det(H) = 4 > 0 ✅</p>
                            <p>• Trace: tr(H) = 4 > 0 ✅</p>
                            <p><strong>Conclusion:</strong> H ≻ 0 (positive definite) ⟹ f is strictly convex</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🧮 Method 2: Definition Verification</h5>
                            <p>For any x₁, x₂ ∈ ℝ² and λ ∈ [0,1], we need to show:</p>
                            <div style="margin: 10px 0; font-family: monospace;">
                                f(λx₁ + (1-λ)x₂) ≤ λf(x₁) + (1-λ)f(x₂)
                            </div>
                            <p><strong>Proof:</strong></p>
                            <p>LHS = ||λx₁ + (1-λ)x₂||² ≤ (λ||x₁|| + (1-λ)||x₂||)² (Triangle inequality)</p>
                            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = λ²||x₁||² + 2λ(1-λ)⟨x₁,x₂⟩ + (1-λ)²||x₂||²</p>
                            <p>RHS = λ||x₁||² + (1-λ)||x₂||²</p>
                            <p>Since 2λ(1-λ)⟨x₁,x₂⟩ ≤ λ²||x₁||² + (1-λ)²||x₂||² (Cauchy-Schwarz), we have LHS ≤ RHS ✅</p>
                        </div>
                    `
                },
                
                'norm_l1': {
                    title: 'Proof: f(x,y) = |x| + |y| is Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>📐 Triangle Inequality Method</h5>
                            <p><strong>Key Property:</strong> The L1 norm satisfies the triangle inequality</p>
                            <p>For any x₁, x₂ ∈ ℝ² and λ ∈ [0,1]:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                f(λx₁ + (1-λ)x₂) = ||λx₁ + (1-λ)x₂||₁<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ≤ ||λx₁||₁ + ||(1-λ)x₂||₁<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = λ||x₁||₁ + (1-λ)||x₂||₁<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = λf(x₁) + (1-λ)f(x₂)
                            </div>
                            <p><strong>Note:</strong> L1 norm is not differentiable at origin, but it's still convex!</p>
                            <p><strong>Subgradient:</strong> At (0,0), the subgradient is ∂f = [-1,1] × [-1,1]</p>
                        </div>
                    `
                },
                
                'norm_l2': {
                    title: 'Proof: f(x,y) = √(x² + y²) is Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>📐 Norm Convexity</h5>
                            <p><strong>Theorem:</strong> Any norm is convex</p>
                            <p>For the L2 norm (Euclidean norm), the triangle inequality gives us:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ||λx₁ + (1-λ)x₂||₂ ≤ ||λx₁||₂ + ||(1-λ)x₂||₂<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = λ||x₁||₂ + (1-λ)||x₂||₂
                            </div>
                            <p><strong>Geometric Intuition:</strong> The unit ball {x : ||x||₂ ≤ 1} is convex</p>
                            <p><strong>Hessian Analysis:</strong> Near origin, undefined due to non-differentiability</p>
                            <p><strong>Away from origin:</strong> Hessian is positive semidefinite</p>
                        </div>
                    `
                },
                
                'exponential': {
                    title: 'Proof: f(x,y) = e^(x+y) is Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>📐 Hessian Matrix Test</h5>
                            <p><strong>Step 1:</strong> Compute derivatives:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂f/∂x = e^(x+y), ∂f/∂y = e^(x+y)<br>
                                ∂²f/∂x² = e^(x+y), ∂²f/∂y² = e^(x+y), ∂²f/∂x∂y = e^(x+y)
                            </div>
                            <p><strong>Step 2:</strong> Hessian matrix:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                H = e^(x+y) [1  1]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1  1]
                            </div>
                            <p><strong>Step 3:</strong> Eigenvalues of [1 1; 1 1]:</p>
                            <p>• λ₁ = 2, λ₂ = 0</p>
                            <p>• Since e^(x+y) > 0, we have H eigenvalues: 2e^(x+y) ≥ 0, 0</p>
                            <p><strong>Conclusion:</strong> H ⪰ 0 (positive semidefinite) ⟹ f is convex</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🧮 Jensen's Inequality Method</h5>
                            <p>Since e^t is convex (e'' = e^t > 0), and f(x,y) = e^(x+y) = e^(linear function):</p>
                            <p>The composition of a convex increasing function with a linear function is convex ✅</p>
                        </div>
                    `
                },
                
                'log_sum_exp': {
                    title: 'Proof: f(x,y) = log(e^x + e^y) is Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>📐 Hessian Matrix Test</h5>
                            <p><strong>Step 1:</strong> Compute first derivatives:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂f/∂x = e^x/(e^x + e^y)<br>
                                ∂f/∂y = e^y/(e^x + e^y)
                            </div>
                            <p><strong>Step 2:</strong> Compute second derivatives:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂²f/∂x² = e^x e^y/(e^x + e^y)²<br>
                                ∂²f/∂y² = e^x e^y/(e^x + e^y)²<br>
                                ∂²f/∂x∂y = -e^x e^y/(e^x + e^y)²
                            </div>
                            <p><strong>Step 3:</strong> Hessian matrix:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                H = (e^x e^y/(e^x + e^y)²) [1  -1]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1  1]
                            </div>
                            <p><strong>Step 4:</strong> Check positive semidefiniteness:</p>
                            <p>• Eigenvalues of [1 -1; -1 1]: λ₁ = 2, λ₂ = 0</p>
                            <p>• Since e^x e^y/(e^x + e^y)² > 0, H eigenvalues: 2α ≥ 0, 0 where α > 0</p>
                            <p><strong>Conclusion:</strong> H ⪰ 0 ⟹ f is convex ✅</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🎯 Log-Sum-Exp Property</h5>
                            <p><strong>Key Insight:</strong> log-sum-exp is the "smooth maximum" function</p>
                            <p>It approximates max(x,y) and inherits convexity from the maximum operation</p>
                        </div>
                    `
                },
                
                'rosenbrock': {
                    title: 'Proof: Rosenbrock Function f(x,y) = (1-x)² + 100(y-x²)² is NON-Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>❌ Hessian Counterexample</h5>
                            <p><strong>Step 1:</strong> Compute derivatives:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂f/∂x = -2(1-x) - 400x(y-x²)<br>
                                ∂f/∂y = 200(y-x²)
                            </div>
                            <p><strong>Step 2:</strong> Compute Hessian:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂²f/∂x² = 2 + 1200x² - 400y<br>
                                ∂²f/∂y² = 200<br>
                                ∂²f/∂x∂y = -400x
                            </div>
                            <p><strong>Step 3:</strong> Counterexample at point (0, 0.1):</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                H(0, 0.1) = [2-40   0  ] = [-38   0]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0    200]   [0   200]
                            </div>
                            <p><strong>Step 4:</strong> Eigenvalue analysis:</p>
                            <p>• λ₁ = -38 < 0 (negative eigenvalue!)</p>
                            <p>• λ₂ = 200 > 0</p>
                            <p><strong>Conclusion:</strong> H has negative eigenvalue ⟹ f is NON-convex ❌</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🌄 Banana Valley Structure</h5>
                            <p><strong>Geometric Intuition:</strong> The famous "banana function" has a curved valley</p>
                            <p>• Global minimum at (1,1) with value 0</p>
                            <p>• Saddle points and complex topology</p>
                            <p>• Used as optimization benchmark due to difficulty</p>
                        </div>
                    `
                },
                
                'himmelblau': {
                    title: 'Proof: Himmelblau Function f(x,y) = (x²+y-11)² + (x+y²-7)² is NON-Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>❌ Multiple Global Minima Evidence</h5>
                            <p><strong>Key Property:</strong> Convex functions have unique global minimum</p>
                            <p><strong>Himmelblau's function has 4 global minima:</strong></p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                • (3, 2) with f = 0<br>
                                • (-2.805118, 3.131312) with f = 0<br>
                                • (-3.779310, -3.283186) with f = 0<br>
                                • (3.584428, -1.848126) with f = 0
                            </div>
                            <p><strong>Conclusion:</strong> Multiple global minima ⟹ NON-convex ❌</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>📐 Hessian Analysis</h5>
                            <p><strong>Step 1:</strong> Computing the Hessian is complex due to quartic terms</p>
                            <p><strong>Step 2:</strong> At point (0,0):</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                H(0,0) = [244   44]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[44   244]
                            </div>
                            <p>• Eigenvalues: λ₁ = 288, λ₂ = 200 (both positive)</p>
                            <p>• But this is only local! The function has saddle points elsewhere</p>
                            <p><strong>Global Analysis:</strong> The complex multi-modal structure proves non-convexity</p>
                        </div>
                    `
                },
                
                'saddle': {
                    title: 'Proof: Saddle Function f(x,y) = x² - y² is NON-Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>❌ Indefinite Hessian</h5>
                            <p><strong>Step 1:</strong> Compute Hessian matrix:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂²f/∂x² = 2, ∂²f/∂y² = -2, ∂²f/∂x∂y = 0<br>
                                H = [2   0]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0  -2]
                            </div>
                            <p><strong>Step 2:</strong> Eigenvalue analysis:</p>
                            <p>• λ₁ = 2 > 0 (positive)</p>
                            <p>• λ₂ = -2 < 0 (negative)</p>
                            <p><strong>Conclusion:</strong> Mixed-sign eigenvalues ⟹ Indefinite Hessian ⟹ NON-convex ❌</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🏇 Saddle Point Geometry</h5>
                            <p><strong>Geometric Interpretation:</strong> Horse saddle shape</p>
                            <p>• Convex along x-direction (curves upward)</p>
                            <p>• Concave along y-direction (curves downward)</p>
                            <p>• Critical point (0,0) is a saddle point, not minimum</p>
                            <p><strong>Line Test:</strong> f(t,0) = t² (convex), f(0,t) = -t² (concave)</p>
                        </div>
                    `
                },
                
                'sine_product': {
                    title: 'Proof: f(x,y) = sin(x)sin(y) is NON-Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>❌ Hessian Analysis</h5>
                            <p><strong>Step 1:</strong> Compute derivatives:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                ∂f/∂x = cos(x)sin(y)<br>
                                ∂f/∂y = sin(x)cos(y)<br>
                                ∂²f/∂x² = -sin(x)sin(y)<br>
                                ∂²f/∂y² = -sin(x)sin(y)<br>
                                ∂²f/∂x∂y = cos(x)cos(y)
                            </div>
                            <p><strong>Step 2:</strong> Hessian matrix:</p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                H = [-sin(x)sin(y)    cos(x)cos(y)]<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[cos(x)cos(y)   -sin(x)sin(y)]
                            </div>
                            <p><strong>Step 3:</strong> Counterexample at (π/4, π/4):</p>
                            <p>• sin(π/4) = cos(π/4) = √2/2</p>
                            <p>• H = [-1/2  1/2; 1/2  -1/2]</p>
                            <p>• Eigenvalues: λ₁ = 0, λ₂ = -1 < 0</p>
                            <p><strong>Conclusion:</strong> Negative eigenvalue ⟹ NON-convex ❌</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🌊 Oscillatory Behavior</h5>
                            <p><strong>Global Structure:</strong> Sinusoidal functions create wave-like patterns</p>
                            <p>• Multiple local maxima and minima</p>
                            <p>• Alternating convex/concave regions</p>
                            <p>• Periodic structure with period 2π in both directions</p>
                        </div>
                    `
                },
                
                'ackley': {
                    title: 'Proof: Ackley Function is NON-Convex',
                    proof: `
                        <div class="proof-section">
                            <h5>❌ Multi-Modal Structure</h5>
                            <p><strong>Ackley Function:</strong> f(x,y) = -20exp(-0.2√(0.5(x²+y²))) - exp(0.5(cos(2πx)+cos(2πy))) + e + 20</p>
                            <p><strong>Key Properties:</strong></p>
                            <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                • Global minimum at (0,0) with f = 0<br>
                                • Thousands of local minima<br>
                                • Highly oscillatory surface<br>
                                • Exponential and cosine components
                            </div>
                            <p><strong>Non-Convexity Evidence:</strong></p>
                            <p>• Multiple local minima ⟹ NON-convex</p>
                            <p>• Cosine terms create oscillations ⟹ NON-convex</p>
                            <p>• Complex Hessian with mixed eigenvalues</p>
                        </div>
                        
                        <div class="proof-section">
                            <h5>🔬 Optimization Challenge</h5>
                            <p><strong>Benchmark Function:</strong> Used to test optimization algorithms</p>
                            <p>• Simulates real-world optimization landscapes</p>
                            <p>• Requires global optimization techniques</p>
                            <p>• Gradient-based methods often fail</p>
                            <p>• Success requires evolutionary or stochastic methods</p>
                        </div>
                    `
                }
            };
            
            const currentProof = proofs[currentFunction];
            if (currentProof) {
                proofContent.innerHTML = `
                    <h4 style="color: #00d4ff; margin-bottom: 15px;">${currentProof.title}</h4>
                    ${currentProof.proof}
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border-left: 4px solid #00d4ff;">
                        <p><strong>💡 Key Takeaway:</strong> ${functions[currentFunction].isConvex ? 
                            'Convex functions guarantee global optimization and are foundational in machine learning!' : 
                            'Non-convex functions require advanced optimization techniques and create complex landscapes in ML!'
                        }</p>
                    </div>
                `;
            } else {
                proofContent.innerHTML = '<p><em>Proof not available for this function type.</em></p>';
            }
        }
        
        function toggleRotation() {
            const enableRotation = document.getElementById('enableRotation')?.checked;
            if (controls) {
                controls.autoRotate = enableRotation !== false;
                rotationEnabled = enableRotation !== false;
            }
        }
        
        function showSection(section) {
            const theorySection = document.getElementById('theorySection');
            const illustrationSection = document.getElementById('illustrationSection');
            const theoryBtn = document.getElementById('theoryBtn');
            const illustrationBtn = document.getElementById('illustrationBtn');
            
            if (section === 'theory') {
                theorySection.style.display = 'block';
                illustrationSection.style.display = 'none';
                theoryBtn.classList.add('active');
                illustrationBtn.classList.remove('active');
            } else {
                theorySection.style.display = 'none';
                illustrationSection.style.display = 'block';
                theoryBtn.classList.remove('active');
                illustrationBtn.classList.add('active');
                
                // Initialize 3D scene when first shown
                if (!scene) {
                    setTimeout(initThreeJS, 100);
                }
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                const container = document.getElementById('threejs-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Set up event listeners for all controls
            document.getElementById('functionType')?.addEventListener('change', updateVisualization);
            document.getElementById('resolutionSlider')?.addEventListener('input', updateVisualization);
            document.getElementById('zoomSlider')?.addEventListener('input', updateVisualization);
            document.getElementById('colorScheme')?.addEventListener('change', updateVisualization);
            document.getElementById('showWireframe')?.addEventListener('change', updateVisualization);
            document.getElementById('showAxes')?.addEventListener('change', updateVisualization);
            document.getElementById('enableRotation')?.addEventListener('change', toggleRotation);
        });
    </script>
</body>
</html>
