<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient - GPS c·ªßa Neural Networks Training</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="../math-simple.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #ffffff;
            font-size: 20px;
            line-height: 1.6;
            color: #000000;
        }
        .section { 
            margin-bottom: 40px; 
            background: #f8f9fa;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 2px solid #e9ecef;
        }
        .toggle-buttons {
            margin-bottom: 30px;
            text-align: center;
        }
        .toggle-btn {
            padding: 20px 40px;
            margin: 0 10px;
            background: #0056b3;
            color: white;
            border: 3px solid #0056b3;
            border-radius: 8px;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        .toggle-btn:hover {
            background: #004085;
            border-color: #004085;
            transform: scale(1.05);
        }
        .toggle-btn.active {
            background: #dc3545;
            border-color: #dc3545;
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }
        .example { 
            background: #fff3cd; 
            padding: 25px; 
            border-radius: 10px; 
            margin: 30px 0; 
            border-left: 6px solid #856404;
            font-size: 18px;
            border: 2px solid #ffeaa7;
        }
        canvas { 
            border: 3px solid #000000; 
            margin-top: 30px; 
            display: block;
            margin-left: auto;
            margin-right: auto;
            background: #ffffff;
        }
        .theory { 
            background: #e3f2fd; 
            padding: 30px; 
            border-radius: 12px; 
            border: 2px solid #1976d2;
        }
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
            padding: 25px;
            background: #f1f3f4;
            border-radius: 12px;
            border: 2px solid #9aa0a6;
        }
        .control-group {
            background: rgba(26, 115, 232, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #1a73e8;
        }
        .control-group label {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
            color: #1a73e8;
            display: block;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            margin: 10px 0;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 5px;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #1a73e8;
            cursor: pointer;
            border-radius: 50%;
        }
        .value-display {
            font-weight: bold;
            color: #dc3545;
            font-size: 20px;
            background: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #dc3545;
            display: inline-block;
            margin-top: 10px;
        }
        h1 {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            color: #333;
        }
        h2 {
            font-size: 36px;
            color: #1976d2;
            margin-bottom: 25px;
            border-bottom: 3px solid #1976d2;
            padding-bottom: 10px;
        }
        h3 {
            font-size: 28px;
            color: #2e7d32;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        p {
            font-size: 20px;
            margin-bottom: 20px;
        }
        li {
            font-size: 18px;
            margin-bottom: 10px;
        }
        b {
            font-size: 22px;
            color: #1565c0;
        }
        i {
            font-size: 16px;
            color: #555;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.95);
        }
        .info {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .gradient-info {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
        .function-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
      
    .formula-box {
      background: linear-gradient(145deg, rgba(15, 15, 40, 0.9), rgba(25, 25, 60, 0.7));
      padding: 25px 35px;
      border-radius: 15px;
      font-family: 'KaTeX_Main', 'Times New Roman', serif;
      font-size: 20px;
      line-height: 1.8;
      text-align: center;
      margin: 25px 0;
      border: 2px solid rgba(100, 200, 255, 0.4);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.5px;
    }

    .formula-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d4ff, #7c4dff, #ff6b6b, #4ecdc4);
      opacity: 0.8;
    }

    .formula-box .main-formula {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255,255,255,0.3);
    }

    .formula-box .sub-formula {
      font-size: 16px;
      color: #b8e6ff;
      font-style: italic;
      margin-top: 8px;
    }

    .formula-box .formula-label {
      font-size: 14px;
      color: #ffeb3b;
      font-weight: 600;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .inline-formula {
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-family: 'Times New Roman', serif;
      font-size: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
      margin: 0 2px;
      color: #e8f4fd;
    }
  </style>
</head>
<body>
    <h1>Gradient - GPS c·ªßa Neural Networks Training</h1>
    
    <div class="toggle-buttons">
        <button class="toggle-btn active" id="theoryBtn" onclick="showSection('theory')">Theory</button>
        <button class="toggle-btn" id="illustrationBtn" onclick="showSection('illustration')">Illustration</button>
    </div>

    <div id="theorySection" class="section theory">
        <h2>Theory</h2>
        
        <div class="example">
            <h3>üöÄ T·∫°i sao Gradient l√† linh h·ªìn c·ªßa AI?</h3>
            <p><strong>Gradient = h∆∞·ªõng tƒÉng nhanh nh·∫•t c·ªßa function!</strong> M·ªçi neural network ƒë·ªÅu h·ªçc th√¥ng qua gradient descent - ƒëi ng∆∞·ª£c h∆∞·ªõng gradient ƒë·ªÉ minimize loss function. Backpropagation ch√≠nh l√† vi·ªác t√≠nh gradient qua chain rule!</p>
        </div>

        <h3>ƒê·ªãnh nghƒ©a Gradient</h3>
        <p>
            Gradient c·ªßa m·ªôt h√†m s·ªë \( f(x, y) \) t·∫°i ƒëi·ªÉm \( (x_0, y_0) \) l√† vector ch·ªâ h∆∞·ªõng tƒÉng nhanh nh·∫•t c·ªßa h√†m s·ªë:
        </p>
        <p style="font-size: 1.2em; text-align: center;">
            \[
                \nabla f(x, y) = \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \right)
            \]
        </p>

        <h3>√ù nghƒ©a h√¨nh h·ªçc</h3>
        <ul>
            <li><strong>H∆∞·ªõng:</strong> Vector gradient ch·ªâ h∆∞·ªõng tƒÉng nhanh nh·∫•t c·ªßa h√†m s·ªë</li>
            <li><strong>ƒê·ªô d√†i:</strong> ƒê·ªô l·ªõn c·ªßa gradient cho bi·∫øt t·ªëc ƒë·ªô tƒÉng</li>
            <li><strong>Vu√¥ng g√≥c:</strong> Gradient lu√¥n vu√¥ng g√≥c v·ªõi ƒë∆∞·ªùng contour (level curves)</li>
        </ul>

        <div class="example">
            <h4>üß† Deep Learning Applications:</h4>
            <ul>
                <li><strong>üéØ Training GPT-3:</strong> 175 billion parameters ƒë∆∞·ª£c update qua gradients!</li>
                <li><strong>üñºÔ∏è Image Recognition:</strong> CNN h·ªçc edge detectors qua gradient-based optimization</li>
                <li><strong>üó£Ô∏è Speech Recognition:</strong> RNNs h·ªçc sequence patterns t·ª´ gradient signals</li>
                <li><strong>üéÆ Game AI:</strong> AlphaGo s·ª≠ d·ª•ng policy gradients ƒë·ªÉ master Go</li>
            </ul>
        </div>

        <h3>Gradient Descent Algorithm</h3>
        <p>
            Thu·∫≠t to√°n gradient descent s·ª≠ d·ª•ng gradient ƒë·ªÉ t√¨m minimum c·ªßa h√†m s·ªë:
        </p>
        <p style="font-size: 1.2em; text-align: center;">
            \[
                x_{n+1} = x_n - \alpha \nabla f(x_n)
            \]
        </p>
        <p>
            Trong ƒë√≥ \( \alpha \) l√† learning rate - t·ªëc ƒë·ªô h·ªçc.
        </p>

        <div class="example">
            <b>V√≠ d·ª• c·ª• th·ªÉ:</b><br>
            Cho h√†m s·ªë \( f(x, y) = x^2 + y^2 \):<br>
            \[
                \nabla f(x, y) = (2x, 2y)
            \]
            <i>Gradient t·∫°i m·ªçi ƒëi·ªÉm ƒë·ªÅu ch·ªâ ra kh·ªèi g·ªëc t·ªça ƒë·ªô, v√¨ ƒë√¢y l√† h√†m parabol v·ªõi minimum t·∫°i (0,0).</i>
        </div>

        <h3>C√°c lo·∫°i Functions ph·ªï bi·∫øn</h3>
        <div class="example">
            <b>1. Quadratic Function:</b> \( f(x, y) = x^2 + y^2 \)<br>
            <b>2. Rosenbrock Function:</b> \( f(x, y) = (1-x)^2 + 100(y-x^2)^2 \)<br>
            <b>3. Himmelblau Function:</b> \( f(x, y) = (x^2+y-11)^2 + (x+y^2-7)^2 \)<br>
            <b>4. Ackley Function:</b> Ph·ª©c t·∫°p v·ªõi nhi·ªÅu local minima
        </div>
    </div>

    <div id="illustrationSection" class="section" style="display:none;">
        <h2>Interactive Gradient Visualization</h2>
        
        <div class="control-panel">
            <div class="control-group">
                <label>Function Type:</label>
                <select id="functionType" onchange="updateVisualization()">
                    <option value="quadratic">Quadratic (x¬≤ + y¬≤)</option>
                    <option value="rosenbrock">Rosenbrock</option>
                    <option value="himmelblau">Himmelblau</option>
                    <option value="ackley">Ackley</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Point X: <span class="value-display" id="xValue">0</span></label>
                <input type="range" id="pointX" min="-3" max="3" step="0.1" value="0" oninput="updateVisualization()">
            </div>
            
            <div class="control-group">
                <label>Point Y: <span class="value-display" id="yValue">0</span></label>
                <input type="range" id="pointY" min="-3" max="3" step="0.1" value="0" oninput="updateVisualization()">
            </div>
            
            <div class="control-group">
                <label>Grid Density: <span class="value-display" id="gridValue">20</span></label>
                <input type="range" id="gridDensity" min="10" max="50" step="5" value="20" oninput="updateVisualization()">
            </div>
            
            <div class="control-group">
                <label>Vector Scale: <span class="value-display" id="scaleValue">1</span></label>
                <input type="range" id="vectorScale" min="0.5" max="3" step="0.1" value="1" oninput="updateVisualization()">
            </div>
            
            <div class="control-group">
                <label>Show Options:</label>
                <div>
                    <input type="checkbox" id="showContours" checked onchange="updateVisualization()"> Contour Lines<br>
                    <input type="checkbox" id="showGradientField" checked onchange="updateVisualization()"> Gradient Field<br>
                    <input type="checkbox" id="showGradientAtPoint" checked onchange="updateVisualization()"> Gradient at Point
                </div>
            </div>
        </div>

        <canvas id="gradientCanvas" width="1000" height="600"></canvas>
        
        <div id="gradientInfo" class="example">
            <b>Gradient Information:</b>
            <div id="gradientDetails"></div>
        </div>

        <div class="example">
            <b>Instructions:</b>
            <ul>
                <li>Choose different function types to see various gradient behaviors</li>
                <li>Move the point using X and Y sliders to see how gradient changes</li>
                <li>Observe how gradient vectors point toward steepest ascent</li>
                <li>Notice that gradient is perpendicular to contour lines</li>
            </ul>
        </div>
    </div>

            <div style="background: rgba(0, 123, 255, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(0, 123, 255, 0.3);">
                <h3>üß† Gradient trong Deep Learning:</h3>
                
                <h4>üî¥ Gradient Descent Algorithm:</h4>
                <div class="formula-container">
                  <div class="formula-title">Parameter Update Rule</div>
                  <div class="math-environment">$$\theta = \theta - \alpha \nabla f(\theta)$$</div>
                  <div class="formula-description">$\alpha$ = learning rate (step size)</div>
                </div>
                <p>Neural networks update billions parameters using this simple rule!</p>
                
                <h4>üü¢ Backpropagation = Chain Rule:</h4>
                <div class="formula-container">
                  <div class="formula-title">Chain Rule for Backpropagation</div>
                  <div class="math-environment">$$\frac{\partial \text{Loss}}{\partial w_1} = \frac{\partial \text{Loss}}{\partial \text{output}} \times \frac{\partial \text{output}}{\partial w_1}$$</div>
                  <div class="formula-description">Gradient flows backward through network layers</div>
                </div>
                <p>Gradient flows backward through network layers via chain rule</p>
                
                <h4>üîµ Gradient Problems & Solutions:</h4>
                <ul>
                    <li><strong>Vanishing Gradients:</strong> $|\nabla f| \to 0$, training slows down (ReLU activation solves this)</li>
                    <li><strong>Exploding Gradients:</strong> $|\nabla f| \to \infty$, training unstable (Gradient clipping solves this)</li>
                    <li><strong>Saddle Points:</strong> Gradient = 0 nh∆∞ng kh√¥ng ph·∫£i minimum (Momentum helps escape)</li>
                </ul>
            </div>
            
            <div style="background: rgba(40, 167, 69, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(40, 167, 69, 0.3);">
                <h3>üéØ Real-world ML Applications:</h3>
                <h4>üìà Loss Function Optimization:</h4>
                <ul>
                    <li><strong>Linear Regression:</strong> MSE loss = $\frac{1}{2}\sum(y - \hat{y})^2$, gradient = $-X^T(y - X\theta)$</li>
                    <li><strong>Logistic Regression:</strong> Cross-entropy loss, gradient qua sigmoid activation</li>
                    <li><strong>Neural Networks:</strong> Complex loss landscapes v·ªõi millions local minima</li>
                </ul>
                
                <h4>üöÄ Advanced Optimizers:</h4>
                <ul>
                    <li><strong>SGD + Momentum:</strong> Accelerated gradients, escape local minima</li>
                    <li><strong>Adam:</strong> Adaptive learning rates, industry standard cho deep learning</li>
                    <li><strong>RMSprop:</strong> Root Mean Square Propagation, good cho RNNs</li>
                </ul>
            </div>
            
            <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(255, 193, 7, 0.3);">
                <h3>üíº Industry Success Stories:</h3>
                <ul>
                    <li><strong>üé¨ Netflix:</strong> Recommendation system trained v·ªõi gradient descent ‚Üí $15B revenue</li>
                    <li><strong>üöó Tesla:</strong> Autopilot neural networks = gradient-based computer vision</li>
                    <li><strong>üì± Siri/Alexa:</strong> Speech recognition models trained qua gradient methods</li>
                    <li><strong>üè• Medical AI:</strong> Cancer detection models achieve 94% accuracy qua optimization</li>
                </ul>
            </div>
            
            <div style="background: rgba(255, 20, 147, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(255, 20, 147, 0.3);">
                <h3>üéØ Gradient & Level Curves - The Heart of Optimization!</h3>
                <h4>üî• Critical Insight: Gradient ALWAYS perpendicular to Level Curves!</h4>
                <p><strong>T·∫°i sao?</strong> Level curve = f(x,y) = constant. Moving along level curve ‚Üí function value kh√¥ng ƒë·ªïi ‚Üí df = 0</p>
                <p><strong>Mathematically:</strong> df = (‚àÇf/‚àÇx)dx + (‚àÇf/‚àÇy)dy = ‚àáf ¬∑ [dx, dy] = 0</p>
                <p><strong>Result:</strong> Gradient ‚ä• tangent vector c·ªßa level curve!</p>
                
                <h4>üß† ML Interpretation - Why This Matters:</h4>
                <ul>
                    <li><strong>üéØ Gradient Descent:</strong> Gradient points away from level curves ‚Üí fastest escape route!</li>
                    <li><strong>‚ö° Newton's Method:</strong> Uses curvature to predict where level curves bend</li>
                    <li><strong>üîç Constrained Optimization:</strong> Lagrange multipliers = gradients must align with constraint curves</li>
                    <li><strong>üé™ Neural Networks:</strong> Loss function level curves = contours of same error</li>
                </ul>
            </div>

            <div style="background: rgba(108, 117, 125, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(108, 117, 125, 0.3);">
                <h3>üî¨ Mathematical Foundation:</h3>
                <ul>
                    <li><strong>Gradient $\nabla f$:</strong> Vector c·ªßa partial derivatives $[\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}, \ldots]$</li>
                    <li><strong>Directional Derivative:</strong> $D_u f = \nabla f \cdot \vb{u}$ (rate of change theo direction $\vb{u}$)</li>
                    <li><strong>Steepest Ascent:</strong> Direction c·ªßa maximum increase = $\frac{\nabla f}{|\nabla f|}$</li>
                    <li><strong>Level Sets:</strong> $f(x,y) = c$, gradient perpendicular to level curves</li>
                    <li><strong>Critical Points:</strong> $\nabla f = \vb{0}$, potential minima/maxima/saddle points</li>
                    <li><strong>‚ä• Perpendicularity:</strong> $\nabla f \cdot \text{tangent vector} = 0$ (fundamental optimization principle)</li>
                </ul>
            </div>
            
            <div style="background: rgba(255, 140, 0, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid rgba(255, 140, 0, 0.3);">
                <h3>üî• Gradient-Level Curve Applications in ML & Engineering:</h3>
                <h4>üéØ Gradient Descent Navigation:</h4>
                <ul>
                    <li><strong>üß≠ Why it works:</strong> Gradient ‚ä• level curves ‚Üí steepest path away from current loss level</li>
                    <li><strong>üé™ Neural Networks:</strong> Each weight update moves perpendicular to current error contour</li>
                    <li><strong>üèîÔ∏è Mountain Climbing Analogy:</strong> Always walk perpendicular to elevation lines for steepest ascent</li>
                </ul>
                
                <h4>üöó Real-world Examples:</h4>
                <ul style="font-size: 16px;">
                    <li><strong>GPS Navigation:</strong> Gradient of travel time function ‚ä• isochrone lines (constant travel time)</li>
                    <li><strong>Heat Transfer:</strong> Heat flow ‚ä• isotherms (temperature level curves)</li>
                    <li><strong>Economics:</strong> Price gradient ‚ä• indifference curves (constant utility)</li>
                    <li><strong>Computer Graphics:</strong> Normal mapping uses gradient ‚ä• surface level curves</li>
                </ul>
                
                <h4>‚ö° Mathematical Proof:</h4>
                <div class="formula-container">
                  <div class="formula-title">Proof of Perpendicularity</div>
                  <div class="math-environment">
                    $$\text{Level curve: } f(x,y) = c$$
                    $$\text{Implicit differentiation: } \frac{\partial f}{\partial x} + \frac{\partial f}{\partial y}\frac{dy}{dx} = 0$$
                    $$\text{Slope of level curve: } \frac{dy}{dx} = -\frac{\partial f/\partial x}{\partial f/\partial y}$$
                    $$\text{Gradient slope: } \frac{\partial f/\partial y}{\partial f/\partial x}$$
                  </div>
                  <div class="formula-description">Product = -1 ‚Üí Perpendicular! ‚úì</div>
                </div>
            </div>
        </div>

        <!-- ===========================================
             INTERACTIVE ILLUSTRATION SECTION  
             =========================================== -->
        <div style="background: linear-gradient(145deg, rgba(15, 40, 15, 0.9), rgba(25, 60, 25, 0.7)); padding: 30px; border-radius: 15px; margin: 30px auto; border: 2px solid rgba(76, 175, 80, 0.4);">
            <h2 style="color: #4caf50; font-size: 2.5em; margin-bottom: 20px; text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üéÆ MINH H·ªåA T∆Ø∆†NG T√ÅC</h2>
            
            <div style="text-align: center; margin-bottom: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 10px;">
                <p style="font-size: 18px; color: #81c784; margin: 0;">Kh√°m ph√° tr·ª±c quan gradient v√† level curves - quan s√°t c√°ch gradient lu√¥n lu√¥n vu√¥ng g√≥c v·ªõi level curves</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>Ch·ªçn h√†m s·ªë</h3>
                    <div class="function-selector">
                        <button onclick="setFunction('quadratic')">f(x,y) = x¬≤ + y¬≤</button>
                        <button onclick="setFunction('linear')">f(x,y) = x + y</button>
                        <button onclick="setFunction('product')">f(x,y) = xy</button>
                        <button onclick="setFunction('rosenbrock')">Rosenbrock</button>
                        <button onclick="setFunction('custom')">f(x,y) = ax¬≤ + by¬≤ + c</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Tham s·ªë h√†m s·ªë</h3>
                    <label>a: <span id="param-a">1</span></label>
                    <input type="range" id="param-a-slider" min="0.1" max="3" value="1" step="0.1">
                    <label>b: <span id="param-b">1</span></label>
                    <input type="range" id="param-b-slider" min="0.1" max="3" value="1" step="0.1">
                    <label>c: <span id="param-c">0</span></label>
                    <input type="range" id="param-c-slider" min="-5" max="5" value="0" step="0.1">
                </div>
                
                <div class="control-group">
                    <h3>ƒêi·ªÉm quan s√°t</h3>
                    <label>X: <span id="point-x">2</span></label>
                    <input type="range" id="point-x-slider" min="-5" max="5" value="2" step="0.1">
                    <label>Y: <span id="point-y">1</span></label>
                    <input type="range" id="point-y-slider" min="-5" max="5" value="1" step="0.1">
                </div>
                
                <div class="control-group">
                    <h3>Hi·ªÉn th·ªã</h3>
                    <label><input type="checkbox" id="show-level-curves" checked> Level Curves</label>
                    <label><input type="checkbox" id="show-gradient" checked> Gradient Vectors</label>
                    <label><input type="checkbox" id="show-point" checked> ƒêi·ªÉm quan s√°t</label>
                    <label><input type="checkbox" id="show-perpendicular" checked> ‚ä• Perpendicular Lines</label>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gradientCanvas" width="600" height="400"></canvas>
            </div>
            
            <div class="info">
                <h3>üìä Th√¥ng tin Gradient</h3>
                <div class="gradient-info" id="gradient-info">
                    Gradient t·∫°i ƒëi·ªÉm (2, 1): ‚àáf = [4, 2]<br>
                    ƒê·ªô l·ªõn gradient: |‚àáf| = 4.47<br>
                    H∆∞·ªõng tƒÉng nhanh nh·∫•t: [0.89, 0.45]
                </div>
                
                <div style="background: rgba(220, 53, 69, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h3>‚ö° Interactive Experiments - Test the Theory:</h3>
                    <ol>
                        <li><strong>üîµ Quadratic Bowl:</strong> Perfect convex function, gradient always points to minimum. Notice green tangent lines!</li>
                        <li><strong>‚ö™ Move observation point:</strong> Watch how gradient rotates but ALWAYS stays ‚ä• to level curves</li>
                        <li><strong>üéõÔ∏è Try different functions:</strong> Linear, product, custom - perpendicularity holds universally!</li>
                        <li><strong>üîç Zoom in close:</strong> Even at tiny scales, 90¬∞ relationship is mathematically exact</li>
                        <li><strong>üéØ Challenge:</strong> Find ANY point where gradient isn't perpendicular (spoiler: impossible!)</li>
                    </ol>
                    
                    <div style="background: rgba(255, 255, 0, 0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>üí° Pro Tip:</strong> Toggle "‚ä• Perpendicular Lines" to see the tangent direction to level curves. 
                        Green dashed line = direction you can move without changing function value!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentFunction = 'quadratic';
        let params = { a: 1, b: 1, c: 0 };
        let point = { x: 2, y: 1 };
        let showLevelCurves = true;
        let showGradient = true;
        let showPoint = true;
        let showPerpendicular = true;
        
        // Setup event listeners
        document.getElementById('param-a-slider').addEventListener('input', updateParams);
        document.getElementById('param-b-slider').addEventListener('input', updateParams);
        document.getElementById('param-c-slider').addEventListener('input', updateParams);
        document.getElementById('point-x-slider').addEventListener('input', updatePoint);
        document.getElementById('point-y-slider').addEventListener('input', updatePoint);
        document.getElementById('show-level-curves').addEventListener('change', updateDisplay);
        document.getElementById('show-gradient').addEventListener('change', updateDisplay);
        document.getElementById('show-point').addEventListener('change', updateDisplay);
        document.getElementById('show-perpendicular').addEventListener('change', updateDisplay);
        
        function updateVisualization() {
            // Check if we're in the illustration section and elements exist
            const canvas = document.getElementById('gradientCanvas');
            if (!canvas || document.getElementById('illustrationSection').style.display === 'none') {
                return;
            }
            
            const pointX = parseFloat(document.getElementById('pointX')?.value || 0);
            const pointY = parseFloat(document.getElementById('pointY')?.value || 0);
            const gridDensity = parseInt(document.getElementById('gridDensity')?.value || 20);
            const vectorScale = parseFloat(document.getElementById('vectorScale')?.value || 1);
            const functionType = document.getElementById('functionType')?.value || 'quadratic';
            
            // Update value displays if they exist
            if (document.getElementById('xValue')) {
                document.getElementById('xValue').textContent = pointX.toFixed(1);
            }
            if (document.getElementById('yValue')) {
                document.getElementById('yValue').textContent = pointY.toFixed(1);
            }
            if (document.getElementById('gridValue')) {
                document.getElementById('gridValue').textContent = gridDensity;
            }
            if (document.getElementById('scaleValue')) {
                document.getElementById('scaleValue').textContent = vectorScale.toFixed(1);
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 80; // pixels per unit
            
            // Draw coordinate axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Draw grid labels
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            for (let i = -5; i <= 5; i++) {
                if (i !== 0) {
                    ctx.fillText(i.toString(), centerX + i * scale, centerY + 20);
                    ctx.fillText(i.toString(), centerX - 15, centerY - i * scale + 5);
                }
            }
            
            // Draw contour lines
            if (document.getElementById('showContours')?.checked) {
                drawContours(ctx, functionType, centerX, centerY, scale, width, height);
            }
            
            // Draw gradient field
            if (document.getElementById('showGradientField')?.checked) {
                drawGradientField(ctx, functionType, centerX, centerY, scale, gridDensity, vectorScale);
            }
            
            // Draw gradient at specific point
            if (document.getElementById('showGradientAtPoint')?.checked) {
                drawGradientAtPoint(ctx, functionType, pointX, pointY, centerX, centerY, scale, vectorScale);
            }
            
            // Update gradient info
            const [gx, gy] = getGradientValue(functionType, pointX, pointY);
            const magnitude = Math.sqrt(gx*gx + gy*gy);
            const fValue = getFunctionValue(functionType, pointX, pointY);
            
            if (document.getElementById('gradientDetails')) {
                document.getElementById('gradientDetails').innerHTML = `
                    <strong>At point (${pointX.toFixed(2)}, ${pointY.toFixed(2)}):</strong><br>
                    Function value: f(x,y) = ${fValue.toFixed(3)}<br>
                    Gradient: ‚àáf = (${gx.toFixed(3)}, ${gy.toFixed(3)})<br>
                    Magnitude: |‚àáf| = ${magnitude.toFixed(3)}<br>
                    Direction: ${Math.atan2(gy, gx).toFixed(3)} radians
                `;
            }
        }
        
        function getFunctionValue(type, x, y) {
            switch(type) {
                case 'quadratic': return x*x + y*y;
                case 'rosenbrock': return (1-x)*(1-x) + 100*(y-x*x)*(y-x*x);
                case 'himmelblau': return (x*x + y - 11)*(x*x + y - 11) + (x + y*y - 7)*(x + y*y - 7);
                case 'ackley': 
                    const a = 20, b = 0.2, c = 2*Math.PI;
                    const term1 = -a * Math.exp(-b * Math.sqrt(0.5 * (x*x + y*y)));
                    const term2 = -Math.exp(0.5 * (Math.cos(c*x) + Math.cos(c*y)));
                    return term1 + term2 + a + Math.E;
                default: return x*x + y*y;
            }
        }
        
        function getGradientValue(type, x, y) {
            switch(type) {
                case 'quadratic': return [2*x, 2*y];
                case 'rosenbrock': 
                    const gx = -2*(1-x) + 200*(y-x*x)*(-2*x);
                    const gy = 200*(y-x*x);
                    return [gx, gy];
                case 'himmelblau': 
                    const gx2 = 2*(x*x + y - 11)*(2*x) + 2*(x + y*y - 7);
                    const gy2 = 2*(x*x + y - 11) + 2*(x + y*y - 7)*(2*y);
                    return [gx2, gy2];
                case 'ackley': 
                    const a = 20, b = 0.2, c = 2*Math.PI;
                    const r = Math.sqrt(x*x + y*y);
                    if (r === 0) return [0, 0];
                    const term1x = a * b * x / r * Math.exp(-b * r);
                    const term1y = a * b * y / r * Math.exp(-b * r);
                    const term2x = 0.5 * c * Math.sin(c*x) * Math.exp(0.5 * (Math.cos(c*x) + Math.cos(c*y)));
                    const term2y = 0.5 * c * Math.sin(c*y) * Math.exp(0.5 * (Math.cos(c*x) + Math.cos(c*y)));
                    return [term1x + term2x, term1y + term2y];
                default: return [2*x, 2*y];
            }
        }
        
        function drawContours(ctx, functionType, centerX, centerY, scale, width, height) {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            for (let px = 0; px < width; px++) {
                for (let py = 0; py < height; py++) {
                    const x = (px - centerX) / scale;
                    const y = (centerY - py) / scale;
                    const z = getFunctionValue(functionType, x, y);
                    
                    // Color based on function value
                    let intensity = Math.max(0, Math.min(255, 255 - z * 20));
                    if (z > 10) intensity = 0;
                    
                    const index = (py * width + px) * 4;
                    data[index] = intensity;     // R
                    data[index + 1] = intensity; // G
                    data[index + 2] = 255;       // B
                    data[index + 3] = 100;       // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawGradientField(ctx, functionType, centerX, centerY, scale, density, vectorScale) {
            const step = 600 / density;
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            
            for (let px = 50; px < 950; px += step) {
                for (let py = 50; py < 550; py += step) {
                    const x = (px - centerX) / scale;
                    const y = (centerY - py) / scale;
                    
                    const [gx, gy] = getGradientValue(functionType, x, y);
                    const magnitude = Math.sqrt(gx*gx + gy*gy);
                    
                    if (magnitude > 0.001) {
                        const normalizedX = gx / magnitude;
                        const normalizedY = gy / magnitude;
                        
                        const arrowLength = Math.min(30, magnitude * vectorScale * 5);
                        
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                        ctx.stroke();
                        
                        // Arrow head
                        const headLength = 8;
                        const headAngle = Math.PI / 6;
                        const angle = Math.atan2(-normalizedY, normalizedX);
                        
                        ctx.beginPath();
                        ctx.moveTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                        ctx.lineTo(
                            px + normalizedX * arrowLength - headLength * Math.cos(angle - headAngle),
                            py - normalizedY * arrowLength + headLength * Math.sin(angle - headAngle)
                        );
                        ctx.moveTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                        ctx.lineTo(
                            px + normalizedX * arrowLength - headLength * Math.cos(angle + headAngle),
                            py - normalizedY * arrowLength + headLength * Math.sin(angle + headAngle)
                        );
                        ctx.stroke();
                    }
                }
            }
        }
        
        function drawGradientAtPoint(ctx, functionType, x, y, centerX, centerY, scale, vectorScale) {
            const px = centerX + x * scale;
            const py = centerY - y * scale;
            
            // Draw point
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw gradient vector
            const [gx, gy] = getGradientValue(functionType, x, y);
            const magnitude = Math.sqrt(gx*gx + gy*gy);
            
            if (magnitude > 0.001) {
                const arrowLength = Math.min(100, magnitude * vectorScale * 20);
                const normalizedX = gx / magnitude;
                const normalizedY = gy / magnitude;
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                ctx.stroke();
                
                // Arrow head
                const headLength = 12;
                const headAngle = Math.PI / 6;
                const angle = Math.atan2(-normalizedY, normalizedX);
                
                ctx.beginPath();
                ctx.moveTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                ctx.lineTo(
                    px + normalizedX * arrowLength - headLength * Math.cos(angle - headAngle),
                    py - normalizedY * arrowLength + headLength * Math.sin(angle - headAngle)
                );
                ctx.moveTo(px + normalizedX * arrowLength, py - normalizedY * arrowLength);
                ctx.lineTo(
                    px + normalizedX * arrowLength - headLength * Math.cos(angle + headAngle),
                    py - normalizedY * arrowLength + headLength * Math.sin(angle + headAngle)
                );
                ctx.stroke();
            }
        }

        function setFunction(func) {
            currentFunction = func;
            updateParams();
        }
        
        function updateParams() {
            const aSlider = document.getElementById('param-a-slider');
            const bSlider = document.getElementById('param-b-slider');
            const cSlider = document.getElementById('param-c-slider');
            
            params.a = parseFloat(aSlider.value);
            params.b = parseFloat(bSlider.value);
            params.c = parseFloat(cSlider.value);
            
            document.getElementById('param-a').textContent = params.a.toFixed(1);
            document.getElementById('param-b').textContent = params.b.toFixed(1);
            document.getElementById('param-c').textContent = params.c.toFixed(1);
            
            drawGradient();
            updateInfo();
        }
        
        function updatePoint() {
            const xSlider = document.getElementById('point-x-slider');
            const ySlider = document.getElementById('point-y-slider');
            
            point.x = parseFloat(xSlider.value);
            point.y = parseFloat(ySlider.value);
            
            document.getElementById('point-x').textContent = point.x.toFixed(1);
            document.getElementById('point-y').textContent = point.y.toFixed(1);
            
            drawGradient();
            updateInfo();
        }
        
        function updateDisplay() {
            showLevelCurves = document.getElementById('show-level-curves').checked;
            showGradient = document.getElementById('show-gradient').checked;
            showPoint = document.getElementById('show-point').checked;
            showPerpendicular = document.getElementById('show-perpendicular').checked;
            drawGradient();
        }
        
        function evaluateFunction(x, y) {
            switch(currentFunction) {
                case 'quadratic':
                    return x * x + y * y;
                case 'linear':
                    return x + y;
                case 'product':
                    return x * y;
                case 'rosenbrock':
                    // Classic Rosenbrock function: (1-x)¬≤ + 100(y-x¬≤)¬≤
                    return Math.pow(1 - x, 2) + 100 * Math.pow(y - x * x, 2);
                case 'custom':
                    return params.a * x * x + params.b * y * y + params.c;
                default:
                    return x * x + y * y;
            }
        }
        
        function evaluateGradient(x, y) {
            switch(currentFunction) {
                case 'quadratic':
                    return { x: 2 * x, y: 2 * y };
                case 'linear':
                    return { x: 1, y: 1 };
                case 'product':
                    return { x: y, y: x };
                case 'rosenbrock':
                    // Gradient of Rosenbrock: ‚àáf = [2(x-1) + 400x(x¬≤-y), 200(y-x¬≤)]
                    const gradX = 2 * (x - 1) + 400 * x * (x * x - y);
                    const gradY = 200 * (y - x * x);
                    return { x: gradX, y: gradY };
                case 'custom':
                    return { x: 2 * params.a * x, y: 2 * params.b * y };
                default:
                    return { x: 2 * x, y: 2 * y };
            }
        }
        
        function getFunctionString() {
            switch(currentFunction) {
                case 'quadratic':
                    return 'f(x,y) = x¬≤ + y¬≤';
                case 'linear':
                    return 'f(x,y) = x + y';
                case 'product':
                    return 'f(x,y) = xy';
                case 'rosenbrock':
                    return 'f(x,y) = (1-x)¬≤ + 100(y-x¬≤)¬≤';
                case 'custom':
                    return `f(x,y) = ${params.a.toFixed(1)}x¬≤ + ${params.b.toFixed(1)}y¬≤ + ${params.c.toFixed(1)}`;
                default:
                    return 'f(x,y) = x¬≤ + y¬≤';
            }
        }
        
        function drawGradient() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set up coordinate system
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 30;
            
            // Draw grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= canvas.width; i += scale) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += scale) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw level curves
            if (showLevelCurves) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 1;
                
                const levels = currentFunction === 'rosenbrock' ? 
                    [0.1, 0.5, 1, 2, 5, 10, 20, 50, 100] :
                    [0.5, 1, 2, 3, 4, 5, 6, 8, 10];
                for (let level of levels) {
                    drawLevelCurve(level, centerX, centerY, scale);
                }
            }
            
            // Draw gradient vectors
            if (showGradient) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                
                for (let i = -4; i <= 4; i++) {
                    for (let j = -3; j <= 3; j++) {
                        const x = i;
                        const y = j;
                        const gradient = evaluateGradient(x, y);
                        const magnitude = Math.sqrt(gradient.x * gradient.x + gradient.y * gradient.y);
                        
                        if (magnitude > 0.1) {
                            const normalizedGradient = {
                                x: gradient.x / magnitude * 15,
                                y: gradient.y / magnitude * 15
                            };
                            
                            const startX = centerX + x * scale;
                            const startY = centerY - y * scale;
                            const endX = startX + normalizedGradient.x;
                            const endY = startY - normalizedGradient.y;
                            
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                            
                            // Arrow head
                            const angle = Math.atan2(-normalizedGradient.y, normalizedGradient.x);
                            const arrowLength = 5;
                            ctx.beginPath();
                            ctx.moveTo(endX, endY);
                            ctx.lineTo(endX - arrowLength * Math.cos(angle - Math.PI/6), 
                                      endY - arrowLength * Math.sin(angle - Math.PI/6));
                            ctx.moveTo(endX, endY);
                            ctx.lineTo(endX - arrowLength * Math.cos(angle + Math.PI/6), 
                                      endY - arrowLength * Math.sin(angle + Math.PI/6));
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Draw observation point
            if (showPoint) {
                const pointX = centerX + point.x * scale;
                const pointY = centerY - point.y * scale;
                
                ctx.fillStyle = '#45b7d1';
                ctx.beginPath();
                ctx.arc(pointX, pointY, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#45b7d1';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(pointX, 0);
                ctx.lineTo(pointX, canvas.height);
                ctx.moveTo(0, pointY);
                ctx.lineTo(canvas.width, pointY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw gradient at observation point
                const gradient = evaluateGradient(point.x, point.y);
                const magnitude = Math.sqrt(gradient.x * gradient.x + gradient.y * gradient.y);
                
                if (magnitude > 0.1) {
                    const normalizedGradient = {
                        x: gradient.x / magnitude * 25,
                        y: gradient.y / magnitude * 25
                    };
                    
                    const endX = pointX + normalizedGradient.x;
                    const endY = pointY - normalizedGradient.y;
                    
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(pointX, pointY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Arrow head
                    const angle = Math.atan2(-normalizedGradient.y, normalizedGradient.x);
                    const arrowLength = 8;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - arrowLength * Math.cos(angle - Math.PI/6), 
                              endY - arrowLength * Math.sin(angle - Math.PI/6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - arrowLength * Math.cos(angle + Math.PI/6), 
                              endY - arrowLength * Math.sin(angle + Math.PI/6));
                    ctx.stroke();
                    
                    // Draw perpendicular line to show relationship with level curve
                    if (showPerpendicular) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3, 3]);
                        
                        // Perpendicular vector (rotate gradient by 90 degrees)
                        const perpVector = {
                            x: -normalizedGradient.y * 0.8,
                            y: normalizedGradient.x * 0.8
                        };
                        
                        const perpEndX1 = pointX + perpVector.x;
                        const perpEndY1 = pointY - perpVector.y;
                        const perpEndX2 = pointX - perpVector.x;
                        const perpEndY2 = pointY + perpVector.y;
                        
                        ctx.beginPath();
                        ctx.moveTo(perpEndX1, perpEndY1);
                        ctx.lineTo(perpEndX2, perpEndY2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Add perpendicular symbol at intersection
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        const symbolSize = 8;
                        ctx.beginPath();
                        ctx.rect(pointX - symbolSize/2, pointY - symbolSize/2, symbolSize, symbolSize);
                        ctx.stroke();
                        
                        // Add labels
                        ctx.fillStyle = '#00ff00';
                        ctx.font = '11px Arial';
                        ctx.fillText('Tangent to level curve', perpEndX1 + 5, perpEndY1 - 5);
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillText('‚àáf (Gradient)', endX + 5, endY - 5);
                    }
                }
            }
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('O', centerX - 15, centerY + 15);
            if (showPoint) {
                ctx.fillText(`(${point.x.toFixed(1)}, ${point.y.toFixed(1)})`, pointX + 10, pointY - 10);
            }
        }
        
        function drawLevelCurve(level, centerX, centerY, scale) {
            if (currentFunction === 'rosenbrock') {
                // Use contour tracing for complex functions like Rosenbrock
                drawContour(level, centerX, centerY, scale);
                return;
            }
            
            const points = [];
            
            // Generate points for level curve
            for (let angle = 0; angle <= 2 * Math.PI; angle += 0.1) {
                let x, y;
                
                switch(currentFunction) {
                    case 'quadratic':
                        const radius = Math.sqrt(level);
                        x = radius * Math.cos(angle);
                        y = radius * Math.sin(angle);
                        break;
                    case 'linear':
                        // For linear function, level curves are lines
                        if (Math.abs(level) < 0.1) {
                            x = 0;
                            y = 0;
                        } else {
                            x = level * Math.cos(angle);
                            y = level * Math.sin(angle);
                        }
                        break;
                    case 'product':
                        // For xy = level, we have hyperbolas
                        if (Math.abs(level) < 0.1) {
                            x = 0;
                            y = 0;
                        } else {
                            x = Math.sqrt(Math.abs(level)) * Math.cos(angle);
                            y = level / x;
                        }
                        break;
                    case 'custom':
                        const a = params.a;
                        const b = params.b;
                        const c = params.c;
                        const adjustedLevel = level - c;
                        
                        if (adjustedLevel <= 0) continue;
                        
                        const radiusX = Math.sqrt(adjustedLevel / a);
                        const radiusY = Math.sqrt(adjustedLevel / b);
                        x = radiusX * Math.cos(angle);
                        y = radiusY * Math.sin(angle);
                        break;
                    default:
                        const r = Math.sqrt(level);
                        x = r * Math.cos(angle);
                        y = r * Math.sin(angle);
                }
                
                if (Math.abs(x) <= 5 && Math.abs(y) <= 4) {
                    points.push({
                        x: centerX + x * scale,
                        y: centerY - y * scale
                    });
                }
            }
            
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
        }
        
        function drawContour(level, centerX, centerY, scale) {
            // Simple contour drawing using marching squares approach
            const resolution = 50;
            const range = 5;
            
            for (let i = 0; i < resolution - 1; i++) {
                for (let j = 0; j < resolution - 1; j++) {
                    const x0 = -range + (i / resolution) * 2 * range;
                    const y0 = -range + (j / resolution) * 2 * range;
                    const x1 = -range + ((i + 1) / resolution) * 2 * range;
                    const y1 = -range + ((j + 1) / resolution) * 2 * range;
                    
                    const v00 = evaluateFunction(x0, y0);
                    const v10 = evaluateFunction(x1, y0);
                    const v01 = evaluateFunction(x0, y1);
                    const v11 = evaluateFunction(x1, y1);
                    
                    // Check if contour level crosses this cell
                    if ((v00 - level) * (v10 - level) < 0 || 
                        (v10 - level) * (v11 - level) < 0 ||
                        (v11 - level) * (v01 - level) < 0 ||
                        (v01 - level) * (v00 - level) < 0) {
                        
                        // Draw a small segment (simplified approach)
                        const midX = (x0 + x1) / 2;
                        const midY = (y0 + y1) / 2;
                        
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillRect(centerX + midX * scale - 1, centerY - midY * scale - 1, 2, 2);
                    }
                }
            }
        }
        
        function updateInfo() {
            const gradient = evaluateGradient(point.x, point.y);
            const magnitude = Math.sqrt(gradient.x * gradient.x + gradient.y * gradient.y);
            const normalizedGradient = {
                x: gradient.x / magnitude,
                y: gradient.y / magnitude
            };
            
            const functionValue = evaluateFunction(point.x, point.y);
            
            // Calculate perpendicular direction (tangent to level curve)
            const perpDirection = magnitude > 0.1 ? {
                x: -gradient.y / magnitude,
                y: gradient.x / magnitude
            } : { x: 0, y: 0 };
            
            let infoText = `H√†m s·ªë: ${getFunctionString()}<br>`;
            infoText += `ƒêi·ªÉm quan s√°t: (${point.x.toFixed(1)}, ${point.y.toFixed(1)})<br>`;
            infoText += `Gi√° tr·ªã h√†m s·ªë: f(${point.x.toFixed(1)}, ${point.y.toFixed(1)}) = ${functionValue.toFixed(2)}<br>`;
            infoText += `Gradient t·∫°i ƒëi·ªÉm: ‚àáf = [${gradient.x.toFixed(2)}, ${gradient.y.toFixed(2)}]<br>`;
            infoText += `ƒê·ªô l·ªõn gradient: |‚àáf| = ${magnitude.toFixed(2)}<br>`;
            infoText += `H∆∞·ªõng tƒÉng nhanh nh·∫•t: [${normalizedGradient.x.toFixed(2)}, ${normalizedGradient.y.toFixed(2)}]<br>`;
            infoText += `<span style="color: #00ff00;">üîÑ Tangent direction: [${perpDirection.x.toFixed(2)}, ${perpDirection.y.toFixed(2)}] (‚ä• to gradient!)</span>`;
            
            document.getElementById('gradient-info').innerHTML = infoText;
        }
        
        function showSection(section) {
            const theorySection = document.getElementById('theorySection');
            const illustrationSection = document.getElementById('illustrationSection');
            const theoryBtn = document.getElementById('theoryBtn');
            const illustrationBtn = document.getElementById('illustrationBtn');
            
            if (section === 'theory') {
                theorySection.style.display = 'block';
                illustrationSection.style.display = 'none';
                theoryBtn.classList.add('active');
                illustrationBtn.classList.remove('active');
            } else {
                theorySection.style.display = 'none';
                illustrationSection.style.display = 'block';
                theoryBtn.classList.remove('active');
                illustrationBtn.classList.add('active');
                // Initialize visualization when showing illustration
                setTimeout(updateVisualization, 100);
            }
        }
        
        // Initialize on page load
        window.onload = function() {
            showSection('theory');
            // Set up MathJax
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        };
    </script>
</body>
</html>