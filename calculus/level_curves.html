<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Curves - Loss Function Landscapes trong ML</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 2.2em;
        }
        .content-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .visualization-stack {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .view-container {
            display: flex;
            flex-direction: column;
        }
        .view-header {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
            font-weight: bold;
            font-size: 1.1em;
        }
        .canvas-container {
            text-align: center;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 0 0 10px 10px;
            background: rgba(255, 255, 255, 0.95);
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        #threejs-container {
            width: 100%;
            height: 500px;
            background: #000;
        }
        .controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: fit-content;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 1.1em;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        .value-display {
            text-align: right;
            font-size: 0.85em;
            color: #ecf0f1;
            margin-bottom: 10px;
        }
        button {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 3px;
            transition: transform 0.2s;
            font-size: 0.85em;
        }
        button:hover {
            transform: scale(1.05);
        }
        button.active {
            background: linear-gradient(45deg, #27ae60, #229954);
        }
        .function-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 5px;
            font-size: 11px;
            max-width: 280px;
            z-index: 10;
        }
        .legend {
            margin-top: 10px;
            font-size: 10px;
        }
        .legend-item {
            margin: 2px 0;
        }
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            font-size: 0.85em;
        }
        .checkbox-item input[type="checkbox"] {
            margin-right: 5px;
        }
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .highlight-box {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .ml-context {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
        }
        .industry-example {
            background: rgba(46, 204, 113, 0.2);
            border-left: 4px solid #2ecc71;
        }
        .math-foundation {
            background: rgba(155, 89, 182, 0.2);
            border-left: 4px solid #9b59b6;
        }
        .experiment-box {
            background: rgba(230, 126, 34, 0.2);
            border-left: 4px solid #e67e22;
        }
    </style>





</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è B√†i 3: Level Curves - B·∫£n ƒë·ªì c·ªßa ML Optimization</h1>
        
        <div class="info" style="margin-bottom: 20px;">
            <h2>üöÄ T·∫°i sao Level Curves quan tr·ªçng trong Machine Learning?</h2>
            <p><strong>Level curves = contour maps c·ªßa loss functions!</strong> M·ªói ƒë∆∞·ªùng cong bi·ªÉu di·ªÖn m·ªôt m·ª©c ƒë·ªô loss kh√°c nhau. Gradient descent "leo xu·ªëng" c√°c level curves ƒë·ªÉ t√¨m minimum. Hi·ªÉu level curves = hi·ªÉu c√°ch neural networks navigate loss landscapes!</p>
            
            <div class="ml-context">
                <h3>üß† ML Applications:</h3>
                <ul>
                    <li><strong>üéØ Loss Function Visualization:</strong> Contour plots cho neural network training</li>
                    <li><strong>üìà Optimization Paths:</strong> Gradient descent trajectories tr√™n level curves</li>
                    <li><strong>üîç Hyperparameter Tuning:</strong> Grid search visualization</li>
                    <li><strong>üé≠ Feature Space Analysis:</strong> Decision boundaries trong classification</li>
                </ul>
            </div>
        </div>

        <div class="content-layout">
            <div class="visualization-stack">
                <div class="view-container">
                    <div class="view-header">üó∫Ô∏è 2D Level Curves (Contour Map)</div>
                    <div class="canvas-container">
                        <canvas id="levelCanvas" width="600" height="400"></canvas>
                        <div class="info-panel">
                            <strong>üó∫Ô∏è Level Curves View</strong><br/>
                            <strong>üéØ ML Context:</strong> Contour maps c·ªßa loss functions. Each curve = constant loss value.<br><br>
                            <strong>üí° Click:</strong> Start gradient descent!
                            <div class="legend">
                                <div class="legend-item" style="color: #e74c3c;">üî¥ Level Curves</div>
                                <div class="legend-item" style="color: #3498db;">üîµ Gradients</div>
                                <div class="legend-item" style="color: #f39c12;">üü† Critical Points</div>
                                <div class="legend-item" style="color: #9b59b6;">üü£ Optimization Path</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="view-container">
                    <div class="view-header">üèîÔ∏è 3D Surface View</div>
                    <div class="canvas-container">
                        <div id="threejs-container"></div>
                        <div class="info-panel" style="top: 450px;">
                            <strong>üèîÔ∏è 3D Surface Visualization</strong><br/>
                            <strong>üéØ Understanding:</strong> See how level curves relate to actual 3D surface heights. Gradient vectors point "uphill" on the surface.<br><br>
                            <strong>üí° Interact:</strong> Mouse to rotate, scroll to zoom!
                            <div class="legend">
                                <div class="legend-item" style="color: #ff4444;">üî¥ High Values (Peaks)</div>
                                <div class="legend-item" style="color: #44ff44;">üü¢ Low Values (Valleys)</div>
                                <div class="legend-item" style="color: #4444ff;">üîµ Medium Values</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>üéØ Function Selection</h3>
                    <div class="function-grid">
                        <button id="func-quadratic" class="active" onclick="selectFunction('quadratic')">Quadratic Bowl</button>
                        <button id="func-rosenbrock" onclick="selectFunction('rosenbrock')">Rosenbrock</button>
                        <button id="func-himmelblau" onclick="selectFunction('himmelblau')">Himmelblau</button>
                        <button id="func-saddle" onclick="selectFunction('saddle')">Saddle Point</button>
                        <button id="func-rastrigin" onclick="selectFunction('rastrigin')">Rastrigin</button>
                        <button id="func-ackley" onclick="selectFunction('ackley')">Ackley</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üìä Visualization Options</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="show-contours" checked onchange="updateDisplay()">
                            <label for="show-contours">Level Curves</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="show-gradients" checked onchange="updateDisplay()">
                            <label for="show-gradients">Gradients</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="show-labels" checked onchange="updateDisplay()">
                            <label for="show-labels">Value Labels</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="show-critical" checked onchange="updateDisplay()">
                            <label for="show-critical">Critical Points</label>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>‚öôÔ∏è Contour Settings</h3>
                    <label>Number of Levels:</label>
                    <input type="range" id="num-levels" min="5" max="25" value="15" step="1" oninput="updateContourSettings()">
                    <div class="value-display" id="levels-value">15 levels</div>
                    
                    <label>Zoom Level:</label>
                    <input type="range" id="zoom-level" min="0.5" max="3" value="1" step="0.1" oninput="updateContourSettings()">
                    <div class="value-display" id="zoom-value">1.0x</div>
                </div>
                
                <div class="control-group">
                    <h3>üéÆ Interactive Features</h3>
                    <button onclick="startGradientDescent()">üéØ Start Gradient Descent</button>
                    <button onclick="clearPath()">üóëÔ∏è Clear Path</button>
                    <button onclick="findCriticalPoints()">üìç Find Critical Points</button>
                    <button onclick="resetView()">üîÑ Reset View</button>
                </div>
                
                <div class="control-group">
                    <h3>üì± Current Function Info</h3>
                    <div id="function-info" style="font-family: 'Courier New', monospace; font-size: 0.85em;">
                        Function: f(x,y) = x¬≤ + y¬≤<br>
                        Type: Convex (Perfect Bowl)<br>
                        Global Minimum: (0, 0)<br>
                        Min Value: 0.000
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info">
            <h3>üß† Level Curves trong Deep Learning:</h3>
            <div class="ml-context">
                <h4>üéØ Loss Function Landscapes:</h4>
                <p><strong>Neural Network Training:</strong> Loss function f(w‚ÇÅ, w‚ÇÇ) creates complex landscapes v·ªõi millions parameters. Level curves show constant loss values - optimization algorithms navigate these contours to find minimum loss.</p>
                
                <h4>üîç Optimization Algorithm Behavior:</h4>
                <ul>
                    <li><strong>Gradient Descent:</strong> Moves perpendicular to level curves (steepest descent direction)</li>
                    <li><strong>Newton's Method:</strong> Uses Hessian to "bend" gradient direction for faster convergence</li>
                    <li><strong>Adam/RMSprop:</strong> Adaptive methods modify step sizes based on level curve geometry</li>
                </ul>
            </div>
            
            <h3>üéØ Real-world Applications:</h3>
            <div class="industry-example">
                <h4>üìà Hyperparameter Optimization:</h4>
                <p><strong>Grid Search Visualization:</strong> Learning rate vs batch size performance maps</p>
                <p><strong>Bayesian Optimization:</strong> Gaussian process surfaces v·ªõi acquisition function contours</p>
                
                <h4>üè• Medical Imaging:</h4>
                <p><strong>CT/MRI Scans:</strong> Level curves represent tissue density iso-surfaces</p>
                <p><strong>Computer Vision:</strong> Edge detection algorithms use level curves c·ªßa intensity functions</p>
                
                <h4>üí∞ Financial Risk Management:</h4>
                <p><strong>Portfolio Optimization:</strong> Risk-return landscapes v·ªõi efficient frontier curves</p>
                <p><strong>Option Pricing:</strong> Black-Scholes surfaces v·ªõi constant price level curves</p>
            </div>
            
            <h3>üî¨ Mathematical Foundation:</h3>
            <div class="math-foundation">
                <ul>
                    <li><strong>Level Set Definition:</strong> L_c = {(x,y) : f(x,y) = c} for constant c</li>
                    <li><strong>Implicit Function Theorem:</strong> Level curves exist when ‚àáf ‚â† 0</li>
                    <li><strong>Gradient Orthogonality:</strong> ‚àáf ‚ä• level curves at every point</li>
                    <li><strong>Critical Points:</strong> Where ‚àáf = 0, level curves may intersect or have singular behavior</li>
                    <li><strong>Contour Spacing:</strong> Dense contours = steep regions, sparse contours = flat regions</li>
                </ul>
            </div>
            
            <h3>üíº Industry Success Stories:</h3>
            <div class="industry-example">
                <ul>
                    <li><strong>üé¨ Netflix:</strong> Recommendation system optimization landscapes ‚Üí Personalized content delivery</li>
                    <li><strong>üöó Tesla:</strong> Autopilot neural network loss surfaces ‚Üí 99.9% safety improvement</li>
                    <li><strong>üîç Google:</strong> Search ranking algorithm optimization ‚Üí $150B annual revenue</li>
                    <li><strong>üíä DeepMind:</strong> Protein folding energy landscapes ‚Üí Revolutionary drug discovery</li>
                </ul>
            </div>
            
            <div class="experiment-box">
                <h3>‚ö° Interactive Experiments:</h3>
                <ol>
                    <li><strong>Quadratic Bowl:</strong> Perfect convex function - all level curves are ellipses</li>
                    <li><strong>Rosenbrock Function:</strong> "Banana valley" - challenging for optimization algorithms</li>
                    <li><strong>Himmelblau Function:</strong> 4 global minima - multiple optimal solutions</li>
                    <li><strong>Saddle Point:</strong> f = x¬≤ - y¬≤ - mixed curvature creates hyperbolic contours</li>
                    <li><strong>Rastrigin:</strong> Many local minima - tests global optimization algorithms</li>
                    <li><strong>Click anywhere:</strong> Start gradient descent from that point!</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('levelCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration  
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        
        // State variables
        let currentFunction = 'quadratic';
        let numLevels = 15;
        let zoomLevel = 1.0;
        let showContours = true;
        let showGradients = true;
        let showLabels = true;
        let showCritical = true;
        let optimizationPath = [];
        let isOptimizing = false;
        let mousePos = { x: 0, y: 0 };
        
        // 3D visualization variables
        let scene3D, camera3D, renderer3D, controls3D;
        let surfaceMesh, pathMesh;
        let animationId;
        
        // Function definitions
        const functions = {
            quadratic: {
                name: 'Quadratic Bowl',
                formula: 'f(x,y) = x¬≤ + y¬≤',
                description: 'Convex (Perfect Bowl)',
                globalMin: '(0, 0)',
                minValue: 0,
                func: (x, y) => x*x + y*y,
                gradX: (x, y) => 2*x,
                gradY: (x, y) => 2*y,
                range: [-3, 3, -3, 3],
                levels: [0.5, 1, 2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 49]
            },
            rosenbrock: {
                name: 'Rosenbrock Function',
                formula: 'f(x,y) = 100(y-x¬≤)¬≤ + (1-x)¬≤',
                description: 'Non-convex (Banana Valley)',
                globalMin: '(1, 1)',
                minValue: 0,
                func: (x, y) => 100*(y - x*x)*(y - x*x) + (1 - x)*(1 - x),
                gradX: (x, y) => -400*x*(y - x*x) - 2*(1 - x),
                gradY: (x, y) => 200*(y - x*x),
                range: [-2, 2, -1, 3],
                levels: [1, 4, 10, 20, 40, 80, 150, 300, 600, 1000, 1500, 2000, 3000]
            },
            himmelblau: {
                name: 'Himmelblau Function',
                formula: 'f(x,y) = (x¬≤+y-11)¬≤ + (x+y¬≤-7)¬≤',
                description: 'Multiple Global Minima',
                globalMin: '4 points',
                minValue: 0,
                func: (x, y) => Math.pow(x*x + y - 11, 2) + Math.pow(x + y*y - 7, 2),
                gradX: (x, y) => 4*x*(x*x + y - 11) + 2*(x + y*y - 7),
                gradY: (x, y) => 2*(x*x + y - 11) + 4*y*(x + y*y - 7),
                range: [-5, 5, -5, 5],
                levels: [5, 20, 50, 100, 200, 400, 800, 1500, 2500, 4000, 6000, 8000]
            },
            saddle: {
                name: 'Saddle Point',
                formula: 'f(x,y) = x¬≤ - y¬≤',
                description: 'Hyperbolic (Mixed Curvature)',
                globalMin: 'None (Saddle)',
                minValue: '-‚àû',
                func: (x, y) => x*x - y*y,
                gradX: (x, y) => 2*x,
                gradY: (x, y) => -2*y,
                range: [-3, 3, -3, 3],
                levels: [-16, -12, -8, -4, -2, -1, 0, 1, 2, 4, 8, 12, 16]
            },
            rastrigin: {
                name: 'Rastrigin Function',
                formula: 'f(x,y) = 20 + x¬≤ + y¬≤ - 10cos(2œÄx) - 10cos(2œÄy)',
                description: 'Many Local Minima',
                globalMin: '(0, 0)',
                minValue: 0,
                func: (x, y) => 20 + x*x + y*y - 10*Math.cos(2*Math.PI*x) - 10*Math.cos(2*Math.PI*y),
                gradX: (x, y) => 2*x + 20*Math.PI*Math.sin(2*Math.PI*x),
                gradY: (x, y) => 2*y + 20*Math.PI*Math.sin(2*Math.PI*y),
                range: [-3, 3, -3, 3],
                levels: [2, 5, 10, 20, 35, 50, 70, 90, 120, 150, 180, 220]
            },
            ackley: {
                name: 'Ackley Function',
                formula: 'f(x,y) = -20exp(-0.2‚àö(x¬≤+y¬≤)) - exp(cos(2œÄx)+cos(2œÄy)) + 20 + e',
                description: 'Single Global, Many Local',
                globalMin: '(0, 0)',
                minValue: 0,
                func: (x, y) => {
                    const r = Math.sqrt(x*x + y*y);
                    return -20*Math.exp(-0.2*r) - Math.exp(0.5*(Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y))) + 20 + Math.E;
                },
                gradX: (x, y) => {
                    const r = Math.sqrt(x*x + y*y);
                    const term1 = -20 * (-0.2) * Math.exp(-0.2*r) * x/r;
                    const term2 = -Math.exp(0.5*(Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y))) * 0.5 * (-2*Math.PI*Math.sin(2*Math.PI*x));
                    return term1 + term2;
                },
                gradY: (x, y) => {
                    const r = Math.sqrt(x*x + y*y);
                    const term1 = -20 * (-0.2) * Math.exp(-0.2*r) * y/r;
                    const term2 = -Math.exp(0.5*(Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y))) * 0.5 * (-2*Math.PI*Math.sin(2*Math.PI*y));
                    return term1 + term2;
                },
                range: [-3, 3, -3, 3],
                levels: [0.5, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
            }
        };
        
        // Transform coordinates
        function worldToScreen(x, y) {
            const func = functions[currentFunction];
            const [xMin, xMax, yMin, yMax] = func.range;
            const scaleX = width / ((xMax - xMin) * zoomLevel);
            const scaleY = height / ((yMax - yMin) * zoomLevel);
            
            return {
                x: centerX + (x - (xMin + xMax)/2) * scaleX,
                y: centerY - (y - (yMin + yMax)/2) * scaleY
            };
        }
        
        function screenToWorld(screenX, screenY) {
            const func = functions[currentFunction];
            const [xMin, xMax, yMin, yMax] = func.range;
            const scaleX = width / ((xMax - xMin) * zoomLevel);
            const scaleY = height / ((yMax - yMin) * zoomLevel);
            
            return {
                x: (screenX - centerX) / scaleX + (xMin + xMax)/2,
                y: -((screenY - centerY) / scaleY) + (yMin + yMax)/2
            };
        }
        
        // Function selection
        function selectFunction(funcName) {
            currentFunction = funcName;
            
            // Update button states
            document.querySelectorAll('button[id^="func-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`func-${funcName}`).classList.add('active');
            
            // Update function info
            updateFunctionInfo();
            
            // Clear optimization path
            optimizationPath = [];
            isOptimizing = false;
            
            // Redraw
            draw();
        }
        
        function updateFunctionInfo() {
            const func = functions[currentFunction];
            document.getElementById('function-info').innerHTML = `
                Function: ${func.formula}<br>
                Type: ${func.description}<br>
                Global Minimum: ${func.globalMin}<br>
                Min Value: ${func.minValue}
            `;
        }
        
        function updateContourSettings() {
            numLevels = parseInt(document.getElementById('num-levels').value);
            zoomLevel = parseFloat(document.getElementById('zoom-level').value);
            
            document.getElementById('levels-value').textContent = `${numLevels} levels`;
            document.getElementById('zoom-value').textContent = `${zoomLevel.toFixed(1)}x`;
            
            draw();
        }
        
        function updateDisplay() {
            showContours = document.getElementById('show-contours').checked;
            showGradients = document.getElementById('show-gradients').checked;
            showLabels = document.getElementById('show-labels').checked;
            showCritical = document.getElementById('show-critical').checked;
            
            draw();
        }
        
        // Drawing functions
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            if (showContours) {
                drawContours();
            }
            
            if (showGradients) {
                drawGradientField();
            }
            
            if (showCritical) {
                drawCriticalPoints();
            }
            
            drawOptimizationPath();
            drawMousePosition();
        }
        
        function drawContours() {
            const func = functions[currentFunction];
            const [xMin, xMax, yMin, yMax] = func.range;
            const resolution = 200;
            
            // Create grid of function values
            const grid = [];
            const dx = (xMax - xMin) / resolution;
            const dy = (yMax - yMin) / resolution;
            
            for (let i = 0; i <= resolution; i++) {
                grid[i] = [];
                for (let j = 0; j <= resolution; j++) {
                    const x = xMin + i * dx;
                    const y = yMin + j * dy;
                    grid[i][j] = func.func(x, y);
                }
            }
            
            // Draw contour lines
            const levels = func.levels.slice(0, numLevels);
            
            levels.forEach((level, index) => {
                ctx.strokeStyle = `hsl(${(index / levels.length) * 240}, 70%, 50%)`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                // Simple marching squares algorithm
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        drawContourSegment(grid, i, j, level, xMin, yMin, dx, dy);
                    }
                }
                
                ctx.stroke();
                
                // Draw level labels
                if (showLabels && index % 3 === 0) {
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.font = '10px Arial';
                    const pos = worldToScreen(xMin + dx * 20, yMin + dy * (20 + index * 8));
                    ctx.fillText(level.toFixed(1), pos.x, pos.y);
                }
            });
        }
        
        function drawContourSegment(grid, i, j, level, xMin, yMin, dx, dy) {
            const x1 = xMin + i * dx;
            const y1 = yMin + j * dy;
            const x2 = xMin + (i + 1) * dx;
            const y2 = yMin + (j + 1) * dy;
            
            const v1 = grid[i][j];
            const v2 = grid[i + 1][j];
            const v3 = grid[i + 1][j + 1];
            const v4 = grid[i][j + 1];
            
            // Check for level crossing and draw segments
            const crossings = [];
            
            if ((v1 <= level && v2 >= level) || (v1 >= level && v2 <= level)) {
                const t = (level - v1) / (v2 - v1);
                crossings.push({ x: x1 + t * (x2 - x1), y: y1 });
            }
            
            if ((v2 <= level && v3 >= level) || (v2 >= level && v3 <= level)) {
                const t = (level - v2) / (v3 - v2);
                crossings.push({ x: x2, y: y1 + t * (y2 - y1) });
            }
            
            if ((v3 <= level && v4 >= level) || (v3 >= level && v4 <= level)) {
                const t = (level - v3) / (v4 - v3);
                crossings.push({ x: x2 - t * (x2 - x1), y: y2 });
            }
            
            if ((v4 <= level && v1 >= level) || (v4 >= level && v1 <= level)) {
                const t = (level - v4) / (v1 - v4);
                crossings.push({ x: x1, y: y2 - t * (y2 - y1) });
            }
            
            if (crossings.length === 2) {
                const p1 = worldToScreen(crossings[0].x, crossings[0].y);
                const p2 = worldToScreen(crossings[1].x, crossings[1].y);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
        }
        
        function drawGradientField() {
            const func = functions[currentFunction];
            const [xMin, xMax, yMin, yMax] = func.range;
            const step = (xMax - xMin) / 20;
            
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 1;
            
            for (let x = xMin; x <= xMax; x += step) {
                for (let y = yMin; y <= yMax; y += step) {
                    const gx = func.gradX(x, y);
                    const gy = func.gradY(x, y);
                    const magnitude = Math.sqrt(gx*gx + gy*gy);
                    
                    if (magnitude > 0.1) {
                        const scale = 0.3;
                        const endX = x + gx * scale / magnitude;
                        const endY = y + gy * scale / magnitude;
                        
                        const start = worldToScreen(x, y);
                        const end = worldToScreen(endX, endY);
                        
                        ctx.beginPath();
                        ctx.moveTo(start.x, start.y);
                        ctx.lineTo(end.x, end.y);
                        ctx.stroke();
                        
                        // Arrow head
                        const angle = Math.atan2(end.y - start.y, end.x - start.x);
                        ctx.beginPath();
                        ctx.moveTo(end.x, end.y);
                        ctx.lineTo(end.x - 5*Math.cos(angle - Math.PI/6), end.y - 5*Math.sin(angle - Math.PI/6));
                        ctx.moveTo(end.x, end.y);
                        ctx.lineTo(end.x - 5*Math.cos(angle + Math.PI/6), end.y + 5*Math.sin(angle + Math.PI/6));
                        ctx.stroke();
                    }
                }
            }
        }
        
        function drawCriticalPoints() {
            // Define known critical points for each function
            const criticalPoints = {
                quadratic: [{x: 0, y: 0, type: 'minimum'}],
                rosenbrock: [{x: 1, y: 1, type: 'minimum'}],
                himmelblau: [
                    {x: 3, y: 2, type: 'minimum'},
                    {x: -2.805, y: 3.131, type: 'minimum'},
                    {x: -3.779, y: -3.283, type: 'minimum'},
                    {x: 3.584, y: -1.848, type: 'minimum'}
                ],
                saddle: [{x: 0, y: 0, type: 'saddle'}],
                rastrigin: [{x: 0, y: 0, type: 'minimum'}],
                ackley: [{x: 0, y: 0, type: 'minimum'}]
            };
            
            const points = criticalPoints[currentFunction] || [];
            
            points.forEach(point => {
                const pos = worldToScreen(point.x, point.y);
                ctx.fillStyle = point.type === 'minimum' ? '#f39c12' : '#e74c3c';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.fillText(`(${point.x.toFixed(1)}, ${point.y.toFixed(1)})`, pos.x + 8, pos.y - 8);
            });
        }
        
        function drawOptimizationPath() {
            if (optimizationPath.length < 2) return;
            
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < optimizationPath.length; i++) {
                const pos = worldToScreen(optimizationPath[i].x, optimizationPath[i].y);
                if (i === 0) {
                    ctx.moveTo(pos.x, pos.y);
                } else {
                    ctx.lineTo(pos.x, pos.y);
                }
            }
            
            ctx.stroke();
            
            // Draw start and end points
            if (optimizationPath.length > 0) {
                const start = worldToScreen(optimizationPath[0].x, optimizationPath[0].y);
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(start.x, start.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                const end = worldToScreen(optimizationPath[optimizationPath.length - 1].x, optimizationPath[optimizationPath.length - 1].y);
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(end.x, end.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawMousePosition() {
            if (mousePos.x === 0 && mousePos.y === 0) return;
            
            const pos = worldToScreen(mousePos.x, mousePos.y);
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            // Show function value
            const func = functions[currentFunction];
            const value = func.func(mousePos.x, mousePos.y);
            ctx.fillStyle = '#000';
            ctx.font = '11px Arial';
            ctx.fillText(`f(${mousePos.x.toFixed(2)}, ${mousePos.y.toFixed(2)}) = ${value.toFixed(3)}`, pos.x + 10, pos.y - 10);
        }
        
        // Optimization functions
        function startGradientDescent() {
            if (isOptimizing) return;
            
            const startPoint = screenToWorld(width/2 + 50, height/2 + 50);
            optimizationPath = [startPoint];
            isOptimizing = true;
            
            gradientDescentStep();
        }
        
        function gradientDescentStep() {
            if (!isOptimizing || optimizationPath.length > 100) {
                isOptimizing = false;
                return;
            }
            
            const func = functions[currentFunction];
            const current = optimizationPath[optimizationPath.length - 1];
            const learningRate = 0.01;
            
            const gx = func.gradX(current.x, current.y);
            const gy = func.gradY(current.x, current.y);
            
            // Check convergence
            if (Math.sqrt(gx*gx + gy*gy) < 0.001) {
                isOptimizing = false;
                return;
            }
            
            const next = {
                x: current.x - learningRate * gx,
                y: current.y - learningRate * gy
            };
            
            optimizationPath.push(next);
            draw();
            update3DPath(); // Update 3D visualization
            
            setTimeout(gradientDescentStep, 100);
        }
        
        function clearPath() {
            optimizationPath = [];
            isOptimizing = false;
            draw();
            update3DPath(); // Clear 3D path
        }
        
        function findCriticalPoints() {
            // This would implement numerical methods to find critical points
            alert('Critical points are marked in orange (minima) and red (saddle points)');
        }
        
        function resetView() {
            zoomLevel = 1.0;
            document.getElementById('zoom-level').value = 1.0;
            document.getElementById('zoom-value').textContent = '1.0x';
            clearPath();
            draw();
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            mousePos = screenToWorld(screenX, screenY);
            draw();
        });
        
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = screenToWorld(screenX, screenY);
            
            // Start gradient descent from clicked point
            optimizationPath = [worldPos];
            isOptimizing = true;
            update3DPath(); // Update 3D visualization
            gradientDescentStep();
        });
        
        // 3D Visualization Setup
        function init3D() {
            const container = document.getElementById('threejs-container');
            
            // Scene setup
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x111111);
            
            // Camera setup
            camera3D = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3D.position.set(5, 5, 5);
            
            // Renderer setup
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(container.clientWidth, container.clientHeight);
            renderer3D.shadowMap.enabled = true;
            renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer3D.domElement);
            
            // Controls
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene3D.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene3D.add(directionalLight);
            
            // Create surface
            create3DSurface();
            
            // Start animation loop
            animate3D();
        }
        
        function create3DSurface() {
            // Remove existing surface
            if (surfaceMesh) {
                scene3D.remove(surfaceMesh);
            }
            
            const func = functions[currentFunction];
            const [xMin, xMax, yMin, yMax] = func.range;
            const resolution = 50;
            
            // Create geometry
            const geometry = new THREE.PlaneGeometry(6, 6, resolution - 1, resolution - 1);
            const vertices = geometry.attributes.position.array;
            const colors = [];
            
            // Calculate surface heights and colors
            let minZ = Infinity, maxZ = -Infinity;
            const zValues = [];
            
            for (let i = 0; i < vertices.length; i += 3) {
                const x = (vertices[i] / 6) * (xMax - xMin) + (xMin + xMax) / 2;
                const y = (vertices[i + 1] / 6) * (yMax - yMin) + (yMin + yMax) / 2;
                const z = func.func(x, y);
                
                // Clamp extreme values
                const clampedZ = Math.max(-20, Math.min(20, z));
                vertices[i + 2] = clampedZ * 0.1; // Scale down for better visualization
                zValues.push(clampedZ);
                
                minZ = Math.min(minZ, clampedZ);
                maxZ = Math.max(maxZ, clampedZ);
            }
            
            // Create colors based on height
            for (let i = 0; i < zValues.length; i++) {
                const t = (zValues[i] - minZ) / (maxZ - minZ);
                const color = new THREE.Color();
                
                if (t < 0.5) {
                    // Blue to green (low to medium values)
                    color.setRGB(0, t * 2, 1 - t * 2);
                } else {
                    // Green to red (medium to high values)
                    color.setRGB((t - 0.5) * 2, 1, 0);
                }
                
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            // Create material
            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            // Create mesh
            surfaceMesh = new THREE.Mesh(geometry, material);
            surfaceMesh.castShadow = true;
            surfaceMesh.receiveShadow = true;
            scene3D.add(surfaceMesh);
            
            // Add wireframe overlay
            const wireframe = new THREE.WireframeGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            const wireframeMesh = new THREE.LineSegments(wireframe, lineMaterial);
            scene3D.add(wireframeMesh);
        }
        
        function update3DPath() {
            // Remove existing path
            if (pathMesh) {
                scene3D.remove(pathMesh);
            }
            
            if (optimizationPath.length < 2) return;
            
            const func = functions[currentFunction];
            const pathGeometry = new THREE.BufferGeometry();
            const pathVertices = [];
            
            // Convert optimization path to 3D coordinates
            for (const point of optimizationPath) {
                const z = func.func(point.x, point.y);
                const clampedZ = Math.max(-20, Math.min(20, z));
                pathVertices.push(point.x * 0.8, point.y * 0.8, clampedZ * 0.1 + 0.1); // Slightly above surface
            }
            
            pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pathVertices, 3));
            
            const pathMaterial = new THREE.LineBasicMaterial({ 
                color: 0x9b59b6, 
                linewidth: 3 
            });
            
            pathMesh = new THREE.Line(pathGeometry, pathMaterial);
            scene3D.add(pathMesh);
        }
        
        function animate3D() {
            animationId = requestAnimationFrame(animate3D);
            
            if (controls3D) {
                controls3D.update();
            }
            
            if (renderer3D && scene3D && camera3D) {
                renderer3D.render(scene3D, camera3D);
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            const container = document.getElementById('threejs-container');
            if (camera3D && renderer3D) {
                camera3D.aspect = container.clientWidth / container.clientHeight;
                camera3D.updateProjectionMatrix();
                renderer3D.setSize(container.clientWidth, container.clientHeight);
            }
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // UI Control Functions
        function selectFunction(funcName) {
            currentFunction = funcName;
            
            // Update button states
            document.querySelectorAll('.function-grid button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('func-' + funcName).classList.add('active');
            
            // Update displays
            updateFunctionInfo();
            clearPath();
            draw();
            create3DSurface();
            update3DPath();
        }
        
        function updateDisplay() {
            showContours = document.getElementById('show-contours').checked;
            showGradients = document.getElementById('show-gradients').checked;
            showLabels = document.getElementById('show-labels').checked;
            showCritical = document.getElementById('show-critical').checked;
            
            draw();
        }
        
        function updateContourSettings() {
            numLevels = parseInt(document.getElementById('num-levels').value);
            zoomLevel = parseFloat(document.getElementById('zoom-level').value);
            
            document.getElementById('levels-value').textContent = numLevels + ' levels';
            document.getElementById('zoom-value').textContent = zoomLevel.toFixed(1) + 'x';
            
            draw();
        }
        
        function updateFunctionInfo() {
            const func = functions[currentFunction];
            document.getElementById('function-info').innerHTML = `
                Function: ${func.formula}<br>
                Type: ${func.description}<br>
                Global Minimum: ${func.globalMin}<br>
                Min Value: ${func.minValue}
            `;
        }
        
        // Initialize
        updateFunctionInfo();
        draw();
        
        // Initialize 3D visualization after a short delay
        setTimeout(() => {
            init3D();
        }, 100);
    </script>
</body>
</html>