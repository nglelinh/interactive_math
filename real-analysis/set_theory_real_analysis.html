<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gi·∫£i T√≠ch Th·ª±c & L√Ω Thuy·∫øt T·∫≠p H·ª£p - N·ªÅn T·∫£ng To√°n H·ªçc</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 30px;
            background: linear-gradient(135deg, #0c2461 0%, #1e3799 50%, #3c6382 100%);
            color: #ffffff;
            line-height: 1.8;
            font-size: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            text-align: center;
            color: #ffffff;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
            font-size: 3.2em;
            margin-bottom: 40px;
            font-weight: 900;
            letter-spacing: 1px;
        }
        
        .theory-section {
            background: rgba(255, 215, 0, 0.15);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            font-size: 1.4em;
            font-weight: 700;
        }
        
        select, input[type="number"], button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            margin: 5px;
            font-size: 14px;
        }
        
        button {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: white;
            cursor: pointer;
            font-weight: 800;
            transition: all 0.3s ease;
            font-size: 1.2em;
            padding: 12px 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: white;
            display: block;
        }
        
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .concept-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .concept-card h4 {
            margin-top: 0;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            font-size: 1.6em;
            font-weight: 800;
        }
        
        .formula-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            text-align: center;
            margin: 15px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .definition-box {
            background: rgba(33, 150, 243, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #2196F3;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .theorem-box {
            background: rgba(156, 39, 176, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #9C27B0;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .example-box {
            background: rgba(76, 175, 80, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #4CAF50;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .set-operation {
            display: inline-block;
            margin: 5px;
            padding: 8px 15px;
            background: rgba(255, 193, 7, 0.8);
            color: #333;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .real-line {
            margin: 20px 0;
            text-align: center;
        }
        
        .interval-notation {
            display: inline-block;
            margin: 5px 10px;
            padding: 8px 15px;
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
        }
        
        .sequence-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
        }
    </style>





</head>
<body>
    <div class="container">
        <h1>üìê Gi·∫£i T√≠ch Th·ª±c & L√Ω Thuy·∫øt T·∫≠p H·ª£p - N·ªÅn T·∫£ng To√°n H·ªçc</h1>
        
        <div class="theory-section">
            <h2>üîç N·ªÅn T·∫£ng To√°n H·ªçc</h2>
            <p><strong>Gi·∫£i T√≠ch Th·ª±c:</strong> Nghi√™n c·ª©u nghi√™m ng·∫∑t v·ªÅ h√†m s·ªë, d√£y s·ªë, chu·ªói v√† t√≠nh li√™n t·ª•c tr√™n ƒë∆∞·ªùng th·∫≥ng s·ªë th·ª±c ‚Ñù.</p>
            <p><strong>L√Ω Thuy·∫øt T·∫≠p H·ª£p:</strong> L√Ω thuy·∫øt to√°n h·ªçc v·ªÅ t·∫≠p h·ª£p c√°c ƒë·ªëi t∆∞·ª£ng, cung c·∫•p n·ªÅn t·∫£ng cho to√†n b·ªô to√°n h·ªçc.</p>
            <p><strong>M·ªëi Li√™n H·ªá:</strong> L√Ω thuy·∫øt t·∫≠p h·ª£p cung c·∫•p ng√¥n ng·ªØ v√† khung l√Ω thuy·∫øt cho c√°c kh√°i ni·ªám gi·∫£i t√≠ch th·ª±c nh∆∞ t·∫≠p m·ªü, t·∫≠p ƒë√≥ng, compact v√† h·ªôi t·ª•.</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Minh H·ªça Ph√©p To√°n T·∫≠p H·ª£p</h3>
                <label>Ph·∫ßn t·ª≠ T·∫≠p A: </label>
                <input type="text" id="setA" value="1,2,3,4,5" placeholder="ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y">
                <br>
                <label>Ph·∫ßn t·ª≠ T·∫≠p B: </label>
                <input type="text" id="setB" value="3,4,5,6,7" placeholder="ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y">
                <br>
                <button onclick="updateSetOperations()">C·∫≠p Nh·∫≠t T·∫≠p H·ª£p</button>
                <div id="setOperationsResult"></div>
            </div>
            
            <div class="control-group">
                <h3>H·ªôi T·ª• D√£y S·ªë</h3>
                <label>Lo·∫°i D√£y S·ªë:</label>
                <select id="sequenceType">
                    <option value="harmonic">1/n (ƒêi·ªÅu h√≤a)</option>
                    <option value="geometric">1/2^n (H√¨nh h·ªçc)</option>
                    <option value="polynomial">1/n¬≤ (ƒêa th·ª©c)</option>
                    <option value="exponential">1/e^n (M≈©)</option>
                    <option value="alternating">(-1)^n/n (Xen k·∫Ω)</option>
                    <option value="fibonacci">Fn/F(n+1) (T·ª∑ s·ªë Fibonacci)</option>
                </select>
                <br>
                <label>S·ªë l∆∞·ª£ng s·ªë h·∫°ng: </label>
                <input type="number" id="numTerms" value="20" min="5" max="50">
                <br>
                <button onclick="updateSequence()">T·∫°o D√£y S·ªë</button>
                <div class="sequence-display" id="sequenceDisplay"></div>
            </div>
            
            <div class="control-group">
                <h3>Tr·ª•c S·ªë Th·ª±c & Kho·∫£ng</h3>
                <label>ƒêi·ªÉm ƒê·∫ßu Kho·∫£ng: </label>
                <input type="number" id="intervalStart" value="-2" step="0.1">
                <label>ƒêi·ªÉm Cu·ªëi Kho·∫£ng: </label>
                <input type="number" id="intervalEnd" value="3" step="0.1">
                <br>
                <label>Lo·∫°i Kho·∫£ng:</label>
                <select id="intervalType">
                    <option value="open">Kho·∫£ng m·ªü (a,b)</option>
                    <option value="closed">Kho·∫£ng ƒë√≥ng [a,b]</option>
                    <option value="half-open-left">N·ª≠a m·ªü tr√°i (a,b]</option>
                    <option value="half-open-right">N·ª≠a m·ªü ph·∫£i [a,b)</option>
                </select>
                <br>
                <button onclick="updateInterval()">C·∫≠p Nh·∫≠t Kho·∫£ng</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <div>
                <h3 style="text-align: center;">Minh H·ªça Ph√©p To√°n T·∫≠p H·ª£p</h3>
                <canvas id="setCanvas" width="400" height="300"></canvas>
            </div>
            <div>
                <h3 style="text-align: center;">H·ªôi T·ª• D√£y S·ªë</h3>
                <canvas id="sequenceCanvas" width="400" height="300"></canvas>
            </div>
            <div>
                <h3 style="text-align: center;">Tr·ª•c S·ªë Th·ª±c & Kho·∫£ng</h3>
                <canvas id="intervalCanvas" width="400" height="200"></canvas>
            </div>
            <div>
                <h3 style="text-align: center;">Kh√°i Ni·ªám T√¥p√¥</h3>
                <canvas id="topologyCanvas" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="concept-grid">
            <div class="concept-card">
                <h4>üî¢ N·ªÅn T·∫£ng L√Ω Thuy·∫øt T·∫≠p H·ª£p</h4>
                <div class="definition-box">
                    <strong>ƒê·ªãnh nghƒ©a:</strong> T·∫≠p h·ª£p l√† m·ªôt b·ªô s∆∞u t·∫≠p c√°c ƒë·ªëi t∆∞·ª£ng kh√°c nhau, g·ªçi l√† ph·∫ßn t·ª≠ hay th√†nh vi√™n.
                </div>
                <div class="formula-box">
                    Ph√©p To√°n C∆° B·∫£n:<br>
                    A ‚à™ B (H·ª£p)<br>
                    A ‚à© B (Giao)<br>
                    A \ B (Hi·ªáu)<br>
                    A·∂ú (Ph·∫ßn b√π)
                </div>
                <div class="example-box">
                    <strong>V√≠ d·ª•:</strong> N·∫øu A = {1,2,3} v√† B = {2,3,4}, th√¨:<br>
                    A ‚à™ B = {1,2,3,4}<br>
                    A ‚à© B = {2,3}<br>
                    A \ B = {1}
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìä D√£y S·ªë v√† Gi·ªõi H·∫°n</h4>
                <div class="definition-box">
                    <strong>ƒê·ªãnh nghƒ©a:</strong> D√£y s·ªë (a‚Çô) h·ªôi t·ª• t·ªõi L n·∫øu v·ªõi m·ªçi Œµ > 0, t·ªìn t·∫°i N sao cho |a‚Çô - L| < Œµ v·ªõi m·ªçi n ‚â• N.
                </div>
                <div class="formula-box">
                    lim(n‚Üí‚àû) a‚Çô = L<br><br>
                    ‚àÄŒµ > 0, ‚àÉN ‚àà ‚Ñï : n ‚â• N ‚üπ |a‚Çô - L| < Œµ
                </div>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω H·ªôi t·ª• ƒê∆°n ƒëi·ªáu:</strong> M·ªçi d√£y ƒë∆°n ƒëi·ªáu b·ªã ch·∫∑n ƒë·ªÅu h·ªôi t·ª•.
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìà T√≠nh Li√™n T·ª•c v√† Gi·ªõi H·∫°n</h4>
                <div class="definition-box">
                    <strong>ƒê·ªãnh nghƒ©a:</strong> f li√™n t·ª•c t·∫°i x = c n·∫øu lim(x‚Üíc) f(x) = f(c).
                </div>
                <div class="formula-box">
                    ƒê·ªãnh nghƒ©a Œµ-Œ¥:<br>
                    ‚àÄŒµ > 0, ‚àÉŒ¥ > 0 : |x - c| < Œ¥ ‚üπ |f(x) - f(c)| < Œµ
                </div>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω Gi√° tr·ªã Trung gian:</strong> N·∫øu f li√™n t·ª•c tr√™n [a,b] v√† k n·∫±m gi·ªØa f(a) v√† f(b), th√¨ ‚àÉc ‚àà (a,b) : f(c) = k.
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üéØ T·∫≠p M·ªü v√† T·∫≠p ƒê√≥ng</h4>
                <div class="definition-box">
                    <strong>T·∫≠p M·ªü:</strong> T·∫≠p U l√† t·∫≠p m·ªü n·∫øu m·ªçi ƒëi·ªÉm trong U ƒë·ªÅu c√≥ l√¢n c·∫≠n ch·ª©a trong U.<br>
                    <strong>T·∫≠p ƒê√≥ng:</strong> T·∫≠p F l√† t·∫≠p ƒë√≥ng n·∫øu ph·∫ßn b√π c·ªßa n√≥ l√† t·∫≠p m·ªü.
                </div>
                <div class="formula-box">
                    H√¨nh c·∫ßu m·ªü: B(x,r) = {y ‚àà ‚Ñù‚Åø : |y - x| < r}<br>
                    H√¨nh c·∫ßu ƒë√≥ng: BÃÑ(x,r) = {y ‚àà ‚Ñù‚Åø : |y - x| ‚â§ r}
                </div>
                <div class="example-box">
                    <strong>V√≠ d·ª•:</strong><br>
                    M·ªü: (0,1), (-‚àû,5), ‚Ñù<br>
                    ƒê√≥ng: [0,1], {0}, ‚àÖ<br>
                    Kh√¥ng ph·∫£i c·∫£ hai: [0,1), (0,1]
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üîí T√≠nh Compact</h4>
                <div class="definition-box">
                    <strong>ƒê·ªãnh nghƒ©a:</strong> T·∫≠p K l√† compact n·∫øu m·ªçi ph·ªß m·ªü c·ªßa K ƒë·ªÅu c√≥ ph·ªß con h·ªØu h·∫°n.
                </div>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω Heine-Borel:</strong> Trong ‚Ñù‚Åø, t·∫≠p l√† compact khi v√† ch·ªâ khi n√≥ v·ª´a ƒë√≥ng v·ª´a b·ªã ch·∫∑n.
                </div>
                <div class="example-box">
                    <strong>V√≠ d·ª•:</strong><br>
                    Compact: [0,1], h√¨nh c·∫ßu ƒë∆°n v·ªã ƒë√≥ng<br>
                    Kh√¥ng compact: (0,1), ‚Ñù, [0,‚àû)
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìê Kh√¥ng Gian M√™-tric</h4>
                <div class="definition-box">
                    <strong>ƒê·ªãnh nghƒ©a:</strong> Kh√¥ng gian m√™-tric (X,d) l√† t·∫≠p X v·ªõi h√†m kho·∫£ng c√°ch d: X √ó X ‚Üí ‚Ñù th·ªèa m√£n:
                </div>
                <div class="formula-box">
                    1. d(x,y) ‚â• 0 (kh√¥ng √¢m)<br>
                    2. d(x,y) = 0 ‚ü∫ x = y (ƒë·ªìng nh·∫•t)<br>
                    3. d(x,y) = d(y,x) (ƒë·ªëi x·ª©ng)<br>
                    4. d(x,z) ‚â§ d(x,y) + d(y,z) (b·∫•t ƒë·∫≥ng th·ª©c tam gi√°c)
                </div>
                <div class="example-box">
                    <strong>M√™-tric Ph·ªï Bi·∫øn:</strong><br>
                    Euclidean: d(x,y) = ‚àöŒ£(x·µ¢-y·µ¢)¬≤<br>
                    Manhattan: d(x,y) = Œ£|x·µ¢-y·µ¢|<br>
                    Max: d(x,y) = max|x·µ¢-y·µ¢|
                </div>
            </div>
        </div>
        
        <div class="concept-grid">
            <div class="concept-card">
                <h4>üåü C√°c ƒê·ªãnh L√Ω N√¢ng Cao</h4>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω Bolzano-Weierstrass:</strong> M·ªçi d√£y b·ªã ch·∫∑n trong ‚Ñù‚Åø ƒë·ªÅu c√≥ d√£y con h·ªôi t·ª•.
                </div>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω Cantor:</strong> V·ªõi m·ªçi t·∫≠p A, kh√¥ng t·ªìn t·∫°i song √°nh t·ª´ A l√™n t·∫≠p l≈©y th·ª´a P(A).
                </div>
                <div class="theorem-box">
                    <strong>ƒê·ªãnh l√Ω Ph·∫°m tr√π Baire:</strong> Kh√¥ng gian m√™-tric ƒë·∫ßy ƒë·ªß kh√¥ng th·ªÉ l√† h·ª£p c·ªßa ƒë·∫øm ƒë∆∞·ª£c nhi·ªÅu t·∫≠p kh√¥ng ƒë·ªÅu ƒë·∫∑c.
                </div>
            </div>
            
            <div class="concept-card">
                <h4>‚ôæÔ∏è L·ª±c L∆∞·ª£ng v√† V√¥ H·∫°n</h4>
                <div class="definition-box">
                    <strong>L·ª±c L∆∞·ª£ng:</strong> Hai t·∫≠p c√≥ c√πng l·ª±c l∆∞·ª£ng n·∫øu t·ªìn t·∫°i song √°nh gi·ªØa ch√∫ng.
                </div>
                <div class="formula-box">
                    |‚Ñï| = ‚Ñµ‚ÇÄ (v√¥ h·∫°n ƒë·∫øm ƒë∆∞·ª£c)<br>
                    |‚Ñù| = 2^‚Ñµ‚ÇÄ (li√™n t·ª•c)<br>
                    |P(A)| > |A| (ƒë·ªãnh l√Ω Cantor)
                </div>
                <div class="example-box">
                    <strong>S·ª± Th·∫≠t B·∫•t Ng·ªù:</strong><br>
                    |‚Ñï| = |‚Ñö| (s·ªë h·ªØu t·ªâ ƒë·∫øm ƒë∆∞·ª£c)<br>
                    |‚Ñù| > |‚Ñï| (s·ªë th·ª±c kh√¥ng ƒë·∫øm ƒë∆∞·ª£c)<br>
                    |‚Ñù| = |‚Ñù‚Åø| (m·ªçi kh√¥ng gian Euclidean c√≥ c√πng l·ª±c l∆∞·ª£ng)
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üé≤ ·ª®ng D·ª•ng</h4>
                <div class="example-box">
                    <strong>Gi·∫£i T√≠ch:</strong><br>
                    ‚Ä¢ N·ªÅn t·∫£ng cho gi·∫£i t√≠ch nghi√™m ng·∫∑t<br>
                    ‚Ä¢ L√Ω thuy·∫øt ƒëo v√† t√≠ch ph√¢n<br>
                    ‚Ä¢ Gi·∫£i t√≠ch h√†m
                </div>
                <div class="example-box">
                    <strong>T√¥p√¥ H·ªçc:</strong><br>
                    ‚Ä¢ √Ånh x·∫° li√™n t·ª•c<br>
                    ‚Ä¢ ƒê·ªìng ph√¥i<br>
                    ‚Ä¢ B·∫•t bi·∫øn t√¥p√¥
                </div>
                <div class="example-box">
                    <strong>To√°n H·ªçc Hi·ªán ƒê·∫°i:</strong><br>
                    ‚Ä¢ N·ªÅn t·∫£ng khoa h·ªçc m√°y t√≠nh<br>
                    ‚Ä¢ L√Ω thuy·∫øt logic v√† m√¥ h√¨nh<br>
                    ‚Ä¢ L√Ω thuy·∫øt ph·∫°m tr√π
                </div>
            </div>
        </div>
    </div>

    <script>
        // Set operations functionality
        let setA = new Set([1, 2, 3, 4, 5]);
        let setB = new Set([3, 4, 5, 6, 7]);
        
        // Sequence data
        let sequenceData = [];
        let currentSequenceType = 'harmonic';
        
        // Interval data
        let intervalStart = -2;
        let intervalEnd = 3;
        let intervalType = 'open';
        
        function parseSet(input) {
            return new Set(input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x)));
        }
        
        function updateSetOperations() {
            const inputA = document.getElementById('setA').value;
            const inputB = document.getElementById('setB').value;
            
            setA = parseSet(inputA);
            setB = parseSet(inputB);
            
            // Calculate set operations
            const union = new Set([...setA, ...setB]);
            const intersection = new Set([...setA].filter(x => setB.has(x)));
            const differenceAB = new Set([...setA].filter(x => !setB.has(x)));
            const differenceBA = new Set([...setB].filter(x => !setA.has(x)));
            const symmetricDiff = new Set([...differenceAB, ...differenceBA]);
            
            // Display results
            const resultDiv = document.getElementById('setOperationsResult');
            resultDiv.innerHTML = `
                <div style="margin-top: 15px;">
                    <div class="set-operation">A ‚à™ B = {${Array.from(union).sort((a,b) => a-b).join(', ')}}</div>
                    <div class="set-operation">A ‚à© B = {${Array.from(intersection).sort((a,b) => a-b).join(', ')}}</div>
                    <div class="set-operation">A \\ B = {${Array.from(differenceAB).sort((a,b) => a-b).join(', ')}}</div>
                    <div class="set-operation">A ‚äï B = {${Array.from(symmetricDiff).sort((a,b) => a-b).join(', ')}}</div>
                </div>
            `;
            
            drawSetOperations();
        }
        
        function generateSequence(type, n) {
            const sequence = [];
            for (let i = 1; i <= n; i++) {
                let term;
                switch (type) {
                    case 'harmonic':
                        term = 1 / i;
                        break;
                    case 'geometric':
                        term = 1 / Math.pow(2, i);
                        break;
                    case 'polynomial':
                        term = 1 / (i * i);
                        break;
                    case 'exponential':
                        term = 1 / Math.exp(i);
                        break;
                    case 'alternating':
                        term = Math.pow(-1, i) / i;
                        break;
                    case 'fibonacci':
                        // Generate Fibonacci numbers
                        if (i === 1) term = 1;
                        else if (i === 2) term = 1;
                        else {
                            let fib1 = 1, fib2 = 1;
                            for (let j = 3; j <= i; j++) {
                                let temp = fib1 + fib2;
                                fib1 = fib2;
                                fib2 = temp;
                            }
                            let fibNext = fib1 + fib2;
                            term = fib2 / fibNext; // Fn/F(n+1)
                        }
                        break;
                    default:
                        term = 1 / i;
                }
                sequence.push({n: i, value: term});
            }
            return sequence;
        }
        
        function updateSequence() {
            currentSequenceType = document.getElementById('sequenceType').value;
            const numTerms = parseInt(document.getElementById('numTerms').value);
            
            sequenceData = generateSequence(currentSequenceType, numTerms);
            
            // Display first few terms and limit
            const display = document.getElementById('sequenceDisplay');
            const firstTerms = sequenceData.slice(0, 8).map(term => term.value.toFixed(4)).join(', ');
            const lastTerm = sequenceData[sequenceData.length - 1].value.toFixed(6);
            
            let limitText = '';
            switch (currentSequenceType) {
                case 'harmonic':
                case 'geometric':
                case 'polynomial':
                case 'exponential':
                    limitText = 'lim ‚Üí 0';
                    break;
                case 'alternating':
                    limitText = 'lim ‚Üí 0 (oscillating)';
                    break;
                case 'fibonacci':
                    limitText = 'lim ‚Üí œÜ-1 ‚âà 0.618 (golden ratio reciprocal)';
                    break;
            }
            
            display.innerHTML = `
                Terms: ${firstTerms}...<br>
                a‚Çç${numTerms}‚Çé = ${lastTerm}<br>
                <strong>${limitText}</strong>
            `;
            
            drawSequenceGraph();
        }
        
        function updateInterval() {
            intervalStart = parseFloat(document.getElementById('intervalStart').value);
            intervalEnd = parseFloat(document.getElementById('intervalEnd').value);
            intervalType = document.getElementById('intervalType').value;
            
            drawInterval();
            drawTopologyConcepts();
        }
        
        function drawSetOperations() {
            const canvas = document.getElementById('setCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw Venn diagram
            const centerA = { x: width * 0.35, y: height * 0.5 };
            const centerB = { x: width * 0.65, y: height * 0.5 };
            const radius = 80;
            
            // Draw set A
            ctx.fillStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.beginPath();
            ctx.arc(centerA.x, centerA.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw set B
            ctx.fillStyle = 'rgba(107, 142, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(centerB.x, centerB.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#6b8eff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.fillText('A', centerA.x - 40, centerA.y - 50);
            ctx.fillText('B', centerB.x + 30, centerB.y - 50);
            
            // Draw elements
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333';
            
            // A only elements
            const aOnly = Array.from(setA).filter(x => !setB.has(x));
            aOnly.forEach((elem, i) => {
                ctx.fillText(elem.toString(), centerA.x - 30, centerA.y - 10 + i * 15);
            });
            
            // B only elements
            const bOnly = Array.from(setB).filter(x => !setA.has(x));
            bOnly.forEach((elem, i) => {
                ctx.fillText(elem.toString(), centerB.x + 15, centerB.y - 10 + i * 15);
            });
            
            // Intersection elements
            const intersection = Array.from(setA).filter(x => setB.has(x));
            intersection.forEach((elem, i) => {
                ctx.fillText(elem.toString(), (centerA.x + centerB.x) / 2 - 5, centerA.y - 10 + i * 15);
            });
        }
        
        function drawSequenceGraph() {
            const canvas = document.getElementById('sequenceCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (sequenceData.length === 0) return;
            
            // Draw axes
            const margin = 40;
            const graphWidth = width - 2 * margin;
            const graphHeight = height - 2 * margin;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.stroke();
            
            // Find min/max values for scaling
            const maxN = Math.max(...sequenceData.map(d => d.n));
            const maxVal = Math.max(...sequenceData.map(d => Math.abs(d.value)));
            const minVal = Math.min(...sequenceData.map(d => d.value));
            
            const yRange = Math.max(maxVal - minVal, 0.1);
            const yCenter = (maxVal + minVal) / 2;
            
            // Draw sequence points
            ctx.fillStyle = '#2196F3';
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            
            sequenceData.forEach((point, i) => {
                const x = margin + (point.n / maxN) * graphWidth;
                const y = height - margin - ((point.value - yCenter + yRange/2) / yRange) * graphHeight;
                
                // Draw point
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw line to x-axis
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, height - margin);
                ctx.stroke();
            });
            
            // Draw limit line (y = 0 for most sequences)
            let limitY;
            if (currentSequenceType === 'fibonacci') {
                const goldenRatio = (1 + Math.sqrt(5)) / 2;
                const limit = 1 / goldenRatio;
                limitY = height - margin - ((limit - yCenter + yRange/2) / yRange) * graphHeight;
            } else {
                limitY = height - margin - ((0 - yCenter + yRange/2) / yRange) * graphHeight;
            }
            
            ctx.strokeStyle = 'red';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, limitY);
            ctx.lineTo(width - margin, limitY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('n', width - 20, height - margin + 15);
            ctx.fillText('a‚Çô', margin - 30, 20);
        }
        
        function drawInterval() {
            const canvas = document.getElementById('intervalCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw number line
            const lineY = height / 2;
            const margin = 50;
            const lineLength = width - 2 * margin;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, lineY);
            ctx.lineTo(width - margin, lineY);
            ctx.stroke();
            
            // Draw tick marks
            const range = 10;
            const step = lineLength / range;
            
            for (let i = 0; i <= range; i++) {
                const x = margin + i * step;
                const value = -5 + i;
                
                ctx.beginPath();
                ctx.moveTo(x, lineY - 5);
                ctx.lineTo(x, lineY + 5);
                ctx.stroke();
                
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value.toString(), x, lineY + 20);
            }
            
            // Draw interval
            const startX = margin + (intervalStart + 5) * step;
            const endX = margin + (intervalEnd + 5) * step;
            
            // Interval line
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startX, lineY);
            ctx.lineTo(endX, lineY);
            ctx.stroke();
            
            // Endpoint markers
            ctx.fillStyle = '#2196F3';
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            
            // Start point
            if (intervalType === 'open' || intervalType === 'half-open-right') {
                // Open circle
                ctx.beginPath();
                ctx.arc(startX, lineY, 5, 0, 2 * Math.PI);
                ctx.stroke();
            } else {
                // Filled circle
                ctx.beginPath();
                ctx.arc(startX, lineY, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // End point
            if (intervalType === 'open' || intervalType === 'half-open-left') {
                // Open circle
                ctx.beginPath();
                ctx.arc(endX, lineY, 5, 0, 2 * Math.PI);
                ctx.stroke();
            } else {
                // Filled circle
                ctx.beginPath();
                ctx.arc(endX, lineY, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Interval notation
            let notation = '';
            switch (intervalType) {
                case 'open':
                    notation = `(${intervalStart}, ${intervalEnd})`;
                    break;
                case 'closed':
                    notation = `[${intervalStart}, ${intervalEnd}]`;
                    break;
                case 'half-open-left':
                    notation = `(${intervalStart}, ${intervalEnd}]`;
                    break;
                case 'half-open-right':
                    notation = `[${intervalStart}, ${intervalEnd})`;
                    break;
            }
            
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(notation, width / 2, lineY - 30);
        }
        
        function drawTopologyConcepts() {
            const canvas = document.getElementById('topologyCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw open and closed sets visualization
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Open set (with fuzzy boundary)
            ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            
            ctx.beginPath();
            ctx.arc(centerX - 80, centerY, 60, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Open Set', centerX - 80, centerY + 80);
            ctx.fillText('(fuzzy boundary)', centerX - 80, centerY + 95);
            
            // Closed set (with solid boundary)
            ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(centerX + 80, centerY, 60, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.fillText('Closed Set', centerX + 80, centerY + 80);
            ctx.fillText('(includes boundary)', centerX + 80, centerY + 95);
            
            // Show interior points
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(centerX - 80, centerY, 2, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(centerX + 80, centerY, 2, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        // Initialize visualizations
        updateSetOperations();
        updateSequence();
        updateInterval();
    </script>
</body>
</html>