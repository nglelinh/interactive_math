<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßÆ Set Theory & Real Analysis - Mathematical Foundations</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 50%, #4a5568 100%);
            color: #ffffff;
            line-height: 1.6;
            font-size: 16px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #63b3ed;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .intro {
            background: rgba(99, 179, 237, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #63b3ed;
        }
        
        .theory-section {
            background: rgba(255, 215, 0, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #63b3ed;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        select, input[type="number"], input[type="text"], button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            margin: 5px;
            font-size: 14px;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }
        
        button {
            background: linear-gradient(45deg, #4299e1, #63b3ed);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(99, 179, 237, 0.3);
        }
        
        .interactive-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }
        
        .demo-box {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(99, 179, 237, 0.3);
        }
        
        .demo-box h3 {
            color: #63b3ed;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        canvas {
            border: 2px solid #63b3ed;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.95);
            display: block;
            width: 100%;
            height: 300px;
        }
        
        .status-display {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #63b3ed;
            font-family: 'Courier New', monospace;
        }
        
        .exercise-section {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .proof-section {
            background: rgba(156, 39, 176, 0.1);
            border-left: 4px solid #9c27b0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .concept-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .concept-card h4 {
            margin-top: 0;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            font-size: 1.6em;
            font-weight: 800;
        }
        
        .formula-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            text-align: center;
            margin: 15px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .definition-box {
            background: rgba(33, 150, 243, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #2196F3;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .theorem-box {
            background: rgba(156, 39, 176, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #9C27B0;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .example-box {
            background: rgba(76, 175, 80, 0.25);
            padding: 25px;
            border-radius: 12px;
            border-left: 6px solid #4CAF50;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            line-height: 1.7;
        }
        
        .set-operation {
            display: inline-block;
            margin: 5px;
            padding: 8px 15px;
            background: rgba(255, 193, 7, 0.8);
            color: #333;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .real-line {
            margin: 20px 0;
            text-align: center;
        }
        
        .interval-notation {
            display: inline-block;
            margin: 5px 10px;
            padding: 8px 15px;
            background: rgba(33, 150, 243, 0.8);
            color: white;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
        }
        
        .sequence-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
        }
    </style>





</head>
<body>
    <div class="container">
        <h1>üßÆ Set Theory & Real Analysis</h1>
        
        <div class="intro">
            <h2>Mathematical Foundations</h2>
            <p><strong>Set Theory</strong> provides the fundamental language for all of mathematics, defining collections of objects and operations between them.</p>
            <p><strong>Real Analysis</strong> rigorously studies functions, sequences, series, and continuity on the real number line ‚Ñù, forming the foundation for calculus and advanced mathematics.</p>
            <p><strong>Connection:</strong> Set theory provides the language and framework for real analysis concepts like open sets, closed sets, compactness, and convergence.</p>
            
            <div class="equation-box">
                <strong>Key Foundations:</strong><br>
                Set Operations: A ‚à™ B, A ‚à© B, A \ B, A^c<br>
                Real Numbers: ‚Ñù = (-‚àû, +‚àû)<br>
                Convergence: lim(n‚Üí‚àû) a‚Çô = L<br>
                Continuity: ‚àÄŒµ > 0, ‚àÉŒ¥ > 0: |x-c| < Œ¥ ‚üπ |f(x)-f(c)| < Œµ
            </div>
        </div>

        <div class="interactive-section">
            <div class="demo-box">
                <h3>üî¢ Set Operations Visualizer</h3>
                <div class="controls">
                    <label>Set A elements:</label>
                    <input type="text" id="setA" value="1,2,3,4,5" placeholder="comma separated">
                    <label>Set B elements:</label>
                    <input type="text" id="setB" value="3,4,5,6,7" placeholder="comma separated">
                    <button onclick="updateSetOperations()">Update Sets</button>
                </div>
                <canvas id="setCanvas" width="400" height="300"></canvas>
                <div class="status-display" id="setOperationsResult">
                    Click "Update Sets" to see operations
                </div>
            </div>

            <div class="demo-box">
                <h3>üìà Sequence Convergence</h3>
                <div class="controls">
                    <label>Sequence Type:</label>
                    <select id="sequenceType">
                        <option value="harmonic">1/n (Harmonic)</option>
                        <option value="geometric">1/2^n (Geometric)</option>
                        <option value="polynomial">1/n¬≤ (Polynomial)</option>
                        <option value="exponential">1/e^n (Exponential)</option>
                        <option value="alternating">(-1)^n/n (Alternating)</option>
                        <option value="fibonacci">Fn/F(n+1) (Fibonacci Ratio)</option>
                        <option value="sqrt">1/‚àön (Square Root)</option>
                        <option value="factorial">n!/n^n (Factorial)</option>
                    </select>
                    <label>Number of terms:</label>
                    <input type="number" id="numTerms" value="25" min="5" max="100">
                    <button onclick="updateSequence()">Generate Sequence</button>
                </div>
                <canvas id="sequenceCanvas" width="400" height="300"></canvas>
                <div class="status-display" id="sequenceDisplay">
                    Select a sequence type and click "Generate"
                </div>
            </div>

            <div class="demo-box">
                <h3>üìè Real Number Line & Intervals</h3>
                <div class="controls">
                    <label>Start:</label>
                    <input type="number" id="intervalStart" value="-2" step="0.1">
                    <label>End:</label>
                    <input type="number" id="intervalEnd" value="3" step="0.1">
                    <label>Type:</label>
                    <select id="intervalType">
                        <option value="open">Open (a,b)</option>
                        <option value="closed">Closed [a,b]</option>
                        <option value="half-open-left">Half-open (a,b]</option>
                        <option value="half-open-right">Half-open [a,b)</option>
                    </select>
                    <button onclick="updateInterval()">Update Interval</button>
                </div>
                <canvas id="intervalCanvas" width="400" height="200"></canvas>
                <div class="status-display" id="intervalInfo">
                    Adjust interval parameters and click "Update"
                </div>
            </div>

            <div class="demo-box">
                <h3>üéØ Topology Concepts</h3>
                <div class="controls">
                    <label>Concept:</label>
                    <select id="topologyType">
                        <option value="open-closed">Open vs Closed Sets</option>
                        <option value="neighborhood">Neighborhoods</option>
                        <option value="boundary">Boundary Points</option>
                        <option value="compact">Compactness</option>
                        <option value="connected">Connectedness</option>
                    </select>
                    <button onclick="updateTopology()">Visualize</button>
                </div>
                <canvas id="topologyCanvas" width="400" height="300"></canvas>
                <div class="status-display" id="topologyInfo">
                    Select a topology concept to visualize
                </div>
            </div>
        </div>

        <!-- Advanced Interactive Sections -->
        <div class="demo-box" style="grid-column: 1 / -1; margin: 20px 0;">
            <h3>üî¨ Function Continuity Explorer</h3>
            <div class="controls">
                <label>Function:</label>
                <select id="functionType">
                    <option value="continuous">f(x) = sin(x) (Continuous)</option>
                    <option value="jump">Jump Discontinuity</option>
                    <option value="removable">Removable Discontinuity</option>
                    <option value="essential">Essential Discontinuity</option>
                    <option value="uniform">Uniformly Continuous</option>
                </select>
                <label>Point of Interest:</label>
                <input type="number" id="pointOfInterest" value="0" step="0.1">
                <label>Œµ (epsilon):</label>
                <input type="range" id="epsilon" min="0.1" max="2" value="0.5" step="0.1">
                <span id="epsilonValue">0.5</span>
                <button onclick="updateContinuity()">Analyze Continuity</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <canvas id="continuityCanvas" width="400" height="300"></canvas>
                <canvas id="deltaEpsilonCanvas" width="400" height="300"></canvas>
            </div>
            <div class="status-display" id="continuityInfo">
                Select a function type and analyze its continuity properties
            </div>
        </div>

        <!-- Cardinality and Infinity Section -->
        <div class="demo-box" style="grid-column: 1 / -1; margin: 20px 0;">
            <h3>‚ôæÔ∏è Cardinality & Infinite Sets</h3>
            <div class="controls">
                <label>Set Comparison:</label>
                <select id="cardinalityType">
                    <option value="natural-even">‚Ñï vs Even Numbers</option>
                    <option value="natural-rational">‚Ñï vs ‚Ñö (Rationals)</option>
                    <option value="natural-real">‚Ñï vs ‚Ñù (Reals)</option>
                    <option value="cantor-pairing">Cantor Pairing Function</option>
                    <option value="power-set">Set vs Power Set</option>
                </select>
                <button onclick="updateCardinality()">Show Bijection/Proof</button>
            </div>
            <canvas id="cardinalityCanvas" width="800" height="400"></canvas>
            <div class="status-display" id="cardinalityInfo">
                Explore different types of infinity and cardinality comparisons
            </div>
        </div>
        
        <div class="concept-grid">
            <div class="concept-card">
                <h4>üî¢ Set Theory Fundamentals</h4>
                <div class="definition-box">
                    <strong>Definition:</strong> A set is a collection of distinct objects, called elements or members.
                    Sets are denoted with capital letters, and ‚àà means "belongs to".
                </div>
                <div class="formula-box">
                    Basic Operations:<br>
                    A ‚à™ B (Union)<br>
                    A ‚à© B (Intersection)<br>
                    A \ B (Difference)<br>
                    A^c (Complement)<br>
                    A √ó B (Cartesian Product)
                </div>
                <div class="example-box">
                    <strong>Example:</strong> If A = {1,2,3} and B = {2,3,4}, then:<br>
                    A ‚à™ B = {1,2,3,4}<br>
                    A ‚à© B = {2,3}<br>
                    A \ B = {1}<br>
                    A √ó B = {(1,2), (1,3), (1,4), (2,2), (2,3), (2,4), (3,2), (3,3), (3,4)}
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìä Sequences and Limits</h4>
                <div class="definition-box">
                    <strong>Definition:</strong> A sequence (a‚Çô) converges to L if for every Œµ > 0, there exists N ‚àà ‚Ñï such that for all n ‚â• N, |a‚Çô - L| < Œµ.
                </div>
                <div class="formula-box">
                    lim(n‚Üí‚àû) a‚Çô = L<br><br>
                    ‚àÄŒµ > 0, ‚àÉN ‚àà ‚Ñï : n ‚â• N ‚üπ |a‚Çô - L| < Œµ
                </div>
                <div class="theorem-box">
                    <strong>Monotone Convergence Theorem:</strong> Every bounded monotonic sequence converges.
                    <br><strong>Squeeze Theorem:</strong> If a‚Çô ‚â§ b‚Çô ‚â§ c‚Çô and lim a‚Çô = lim c‚Çô = L, then lim b‚Çô = L.
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìà Continuity and Limits</h4>
                <div class="definition-box">
                    <strong>Definition:</strong> f is continuous at x = c if lim(x‚Üíc) f(x) = f(c).
                    This means the limit exists, f(c) is defined, and they are equal.
                </div>
                <div class="formula-box">
                    Œµ-Œ¥ Definition:<br>
                    ‚àÄŒµ > 0, ‚àÉŒ¥ > 0 : |x - c| < Œ¥ ‚üπ |f(x) - f(c)| < Œµ
                </div>
                <div class="theorem-box">
                    <strong>Intermediate Value Theorem:</strong> If f is continuous on [a,b] and k lies between f(a) and f(b), then ‚àÉc ‚àà (a,b) such that f(c) = k.
                    <br><strong>Extreme Value Theorem:</strong> A continuous function on a closed bounded interval attains its maximum and minimum.
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üéØ Open and Closed Sets</h4>
                <div class="definition-box">
                    <strong>Open Set:</strong> U is open if every point in U has a neighborhood contained in U.<br>
                    <strong>Closed Set:</strong> F is closed if its complement is open, or equivalently, if it contains all its limit points.
                </div>
                <div class="formula-box">
                    Open Ball: B(x,r) = {y ‚àà ‚Ñù‚Åø : |y - x| < r}<br>
                    Closed Ball: BÃÑ(x,r) = {y ‚àà ‚Ñù‚Åø : |y - x| ‚â§ r}<br>
                    Boundary: ‚àÇA = ƒÄ \ A¬∞
                </div>
                <div class="example-box">
                    <strong>Examples:</strong><br>
                    Open: (0,1), (-‚àû,5), ‚Ñù, ‚àÖ<br>
                    Closed: [0,1], {0}, ‚Ñù, ‚àÖ<br>
                    Neither: [0,1), (0,1], ‚Ñö (rationals)
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üîí Compactness</h4>
                <div class="definition-box">
                    <strong>Definition:</strong> K is compact if every open cover of K has a finite subcover.
                    Equivalently (in metric spaces), every sequence in K has a convergent subsequence with limit in K.
                </div>
                <div class="theorem-box">
                    <strong>Heine-Borel Theorem:</strong> In ‚Ñù‚Åø, a set is compact if and only if it is closed and bounded.
                    <br><strong>Properties:</strong> Compact sets are closed, bounded, and complete.
                </div>
                <div class="example-box">
                    <strong>Examples:</strong><br>
                    Compact: [0,1], closed unit ball in ‚Ñù‚Åø<br>
                    Not Compact: (0,1), ‚Ñù, [0,‚àû), ‚Ñï
                </div>
            </div>
            
            <div class="concept-card">
                <h4>üìê Metric Spaces</h4>
                <div class="definition-box">
                    <strong>Definition:</strong> A metric space (X,d) is a set X with a distance function d: X √ó X ‚Üí ‚Ñù satisfying:
                </div>
                <div class="formula-box">
                    1. d(x,y) ‚â• 0 (non-negative)<br>
                    2. d(x,y) = 0 ‚ü∫ x = y (identity)<br>
                    3. d(x,y) = d(y,x) (symmetry)<br>
                    4. d(x,z) ‚â§ d(x,y) + d(y,z) (triangle inequality)
                </div>
                <div class="example-box">
                    <strong>Common Metrics:</strong><br>
                    Euclidean: d(x,y) = ‚àöŒ£(x·µ¢-y·µ¢)¬≤<br>
                    Manhattan: d(x,y) = Œ£|x·µ¢-y·µ¢|<br>
                    Supremum: d(x,y) = max|x·µ¢-y·µ¢|<br>
                    Discrete: d(x,y) = 0 if x=y, 1 otherwise
                </div>
            </div>
        </div>

        <!-- Advanced Theorems Section -->
        <div class="theory-section">
            <h2>üåü Advanced Theorems & Results</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h4>ÔøΩ Fundamental Theorems</h4>
                    <div class="theorem-box">
                        <strong>Bolzano-Weierstrass Theorem:</strong> Every bounded sequence in ‚Ñù‚Åø has a convergent subsequence.
                    </div>
                    <div class="theorem-box">
                        <strong>Cantor's Theorem:</strong> For any set A, there is no surjection from A onto its power set P(A).
                        This proves |P(A)| > |A|.
                    </div>
                    <div class="theorem-box">
                        <strong>Baire Category Theorem:</strong> A complete metric space cannot be expressed as a countable union of nowhere dense sets.
                    </div>
                </div>
                
                <div class="concept-card">
                    <h4>‚ôæÔ∏è Cardinality and Infinity</h4>
                    <div class="definition-box">
                        <strong>Cardinality:</strong> Two sets have the same cardinality if there exists a bijection between them.
                        |A| ‚â§ |B| if there exists an injection from A to B.
                    </div>
                    <div class="formula-box">
                        |‚Ñï| = ‚Ñµ‚ÇÄ (countably infinite)<br>
                        |‚Ñù| = 2^‚Ñµ‚ÇÄ = ùî† (continuum)<br>
                        |P(A)| > |A| (Cantor's theorem)<br>
                        |‚Ñù‚Åø| = |‚Ñù| for all n ‚àà ‚Ñï
                    </div>
                    <div class="example-box">
                        <strong>Surprising Facts:</strong><br>
                        |‚Ñï| = |‚Ñö| (rationals are countable)<br>
                        |‚Ñù| > |‚Ñï| (reals are uncountable)<br>
                        |‚Ñù| = |‚Ñù‚Åø| (all Euclidean spaces have same cardinality)<br>
                        |(0,1)| = |‚Ñù| (bijection via tan function)
                    </div>
                </div>
                
                <div class="concept-card">
                    <h4>üî¨ Applications & Connections</h4>
                    <div class="example-box">
                        <strong>Real Analysis Applications:</strong><br>
                        ‚Ä¢ Foundation for rigorous calculus<br>
                        ‚Ä¢ Measure theory and integration<br>
                        ‚Ä¢ Functional analysis<br>
                        ‚Ä¢ Fourier analysis<br>
                        ‚Ä¢ Optimization theory
                    </div>
                    <div class="example-box">
                        <strong>Set Theory Applications:</strong><br>
                        ‚Ä¢ Computer science foundations<br>
                        ‚Ä¢ Logic and model theory<br>
                        ‚Ä¢ Category theory<br>
                        ‚Ä¢ Topology and geometry<br>
                        ‚Ä¢ Probability theory
                    </div>
                    <div class="example-box">
                        <strong>Modern Mathematics:</strong><br>
                        ‚Ä¢ Axiomatic foundations (ZFC)<br>
                        ‚Ä¢ Independence results<br>
                        ‚Ä¢ Large cardinal axioms<br>
                        ‚Ä¢ Descriptive set theory<br>
                        ‚Ä¢ Computability theory
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Exercises Section -->
        <div class="exercise-section">
            <h3>üéì Interactive Exercises</h3>
            <div class="concept-grid">
                <div class="concept-card">
                    <h4>Exercise 1: Œµ-Œ¥ Continuity</h4>
                    <p>For f(x) = x¬≤, find Œ¥ such that |x - 2| < Œ¥ ‚üπ |f(x) - f(2)| < Œµ = 0.1</p>
                    <div class="controls">
                        <label>Your Œ¥ value:</label>
                        <input type="number" id="delta-guess" step="0.001" placeholder="Enter delta">
                        <button onclick="checkDeltaEpsilon()">Check Answer</button>
                    </div>
                    <div id="delta-result"></div>
                </div>
                
                <div class="concept-card">
                    <h4>Exercise 2: Set Cardinality</h4>
                    <p>Which of these sets has the same cardinality as ‚Ñï?</p>
                    <div class="controls">
                        <select id="cardinality-choice">
                            <option value="">Choose...</option>
                            <option value="integers">‚Ñ§ (Integers)</option>
                            <option value="rationals">‚Ñö (Rationals)</option>
                            <option value="reals">‚Ñù (Reals)</option>
                            <option value="powerset">P(‚Ñï) (Power set of ‚Ñï)</option>
                        </select>
                        <button onclick="checkCardinality()">Check Answer</button>
                    </div>
                    <div id="cardinality-result"></div>
                </div>
                
                <div class="concept-card">
                    <h4>Exercise 3: Sequence Convergence</h4>
                    <p>Does the sequence a‚Çô = (n¬≤ + 1)/(2n¬≤ - 3) converge? If so, to what limit?</p>
                    <div class="controls">
                        <label>Converges?</label>
                        <select id="convergence-choice">
                            <option value="">Choose...</option>
                            <option value="yes">Yes</option>
                            <option value="no">No</option>
                        </select>
                        <label>Limit (if converges):</label>
                        <input type="number" id="limit-guess" step="0.1" placeholder="Enter limit">
                        <button onclick="checkConvergence()">Check Answer</button>
                    </div>
                    <div id="convergence-result"></div>
                </div>
            </div>
        </div>

        <!-- Proof Exploration Section -->
        <div class="proof-section">
            <h3>üìù Interactive Proof Explorer</h3>
            <div class="controls">
                <label>Select Theorem to Explore:</label>
                <select id="proof-theorem">
                    <option value="cantor-diagonal">Cantor's Diagonal Argument</option>
                    <option value="bolzano-weierstrass">Bolzano-Weierstrass Theorem</option>
                    <option value="intermediate-value">Intermediate Value Theorem</option>
                    <option value="heine-borel">Heine-Borel Theorem</option>
                </select>
                <button onclick="exploreProof()">Explore Proof</button>
            </div>
            <div id="proof-content">
                Select a theorem above to see an interactive proof exploration
            </div>
        </div>
    </div>

    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            }
        };

        // Global variables
        let setA = new Set([1, 2, 3, 4, 5]);
        let setB = new Set([3, 4, 5, 6, 7]);
        let sequenceData = [];
        let currentSequenceType = 'harmonic';
        let intervalStart = -2;
        let intervalEnd = 3;
        let intervalType = 'open';
        let currentTopologyType = 'open-closed';
        let currentFunctionType = 'continuous';
        let currentCardinalityType = 'natural-even';

        // Utility functions
        function parseSet(input) {
            return new Set(input.split(',').map(x => {
                const num = parseFloat(x.trim());
                return isNaN(num) ? x.trim() : num;
            }).filter(x => x !== ''));
        }

        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }

        function fibonacci(n) {
            if (n <= 2) return 1;
            let a = 1, b = 1;
            for (let i = 3; i <= n; i++) {
                [a, b] = [b, a + b];
            }
            return b;
        }

        // Set Operations
        function updateSetOperations() {
            const inputA = document.getElementById('setA').value;
            const inputB = document.getElementById('setB').value;
            
            setA = parseSet(inputA);
            setB = parseSet(inputB);
            
            // Calculate set operations
            const union = new Set([...setA, ...setB]);
            const intersection = new Set([...setA].filter(x => setB.has(x)));
            const differenceAB = new Set([...setA].filter(x => !setB.has(x)));
            const differenceBA = new Set([...setB].filter(x => !setA.has(x)));
            const symmetricDiff = new Set([...differenceAB, ...differenceBA]);
            
            // Display results
            const resultDiv = document.getElementById('setOperationsResult');
            resultDiv.innerHTML = `
                <div style="margin-top: 15px; font-family: 'Courier New', monospace;">
                    <div style="margin: 5px 0; padding: 5px; background: rgba(99, 179, 237, 0.2); border-radius: 3px;">
                        A ‚à™ B = {${Array.from(union).sort((a,b) => 
                            typeof a === 'number' && typeof b === 'number' ? a-b : 
                            a.toString().localeCompare(b.toString())
                        ).join(', ')}}
                    </div>
                    <div style="margin: 5px 0; padding: 5px; background: rgba(76, 175, 80, 0.2); border-radius: 3px;">
                        A ‚à© B = {${Array.from(intersection).sort((a,b) => 
                            typeof a === 'number' && typeof b === 'number' ? a-b : 
                            a.toString().localeCompare(b.toString())
                        ).join(', ')}}
                    </div>
                    <div style="margin: 5px 0; padding: 5px; background: rgba(255, 193, 7, 0.2); border-radius: 3px;">
                        A \\ B = {${Array.from(differenceAB).sort((a,b) => 
                            typeof a === 'number' && typeof b === 'number' ? a-b : 
                            a.toString().localeCompare(b.toString())
                        ).join(', ')}}
                    </div>
                    <div style="margin: 5px 0; padding: 5px; background: rgba(156, 39, 176, 0.2); border-radius: 3px;">
                        A ‚äï B = {${Array.from(symmetricDiff).sort((a,b) => 
                            typeof a === 'number' && typeof b === 'number' ? a-b : 
                            a.toString().localeCompare(b.toString())
                        ).join(', ')}}
                    </div>
                    <div style="margin: 10px 0; font-size: 12px;">
                        |A| = ${setA.size}, |B| = ${setB.size}, |A ‚à™ B| = ${union.size}
                    </div>
                </div>
            `;
            
            drawSetOperations();
        }

        // Sequence Generation
        function generateSequence(type, n) {
            const sequence = [];
            for (let i = 1; i <= n; i++) {
                let term;
                switch (type) {
                    case 'harmonic':
                        term = 1 / i;
                        break;
                    case 'geometric':
                        term = 1 / Math.pow(2, i);
                        break;
                    case 'polynomial':
                        term = 1 / (i * i);
                        break;
                    case 'exponential':
                        term = 1 / Math.exp(i);
                        break;
                    case 'alternating':
                        term = Math.pow(-1, i) / i;
                        break;
                    case 'fibonacci':
                        const fib_i = fibonacci(i);
                        const fib_i1 = fibonacci(i + 1);
                        term = fib_i / fib_i1;
                        break;
                    case 'sqrt':
                        term = 1 / Math.sqrt(i);
                        break;
                    case 'factorial':
                        term = factorial(i) / Math.pow(i, i);
                        break;
                    default:
                        term = 1 / i;
                }
                sequence.push({n: i, value: term});
            }
            return sequence;
        }

        function updateSequence() {
            currentSequenceType = document.getElementById('sequenceType').value;
            const numTerms = parseInt(document.getElementById('numTerms').value);
            
            sequenceData = generateSequence(currentSequenceType, numTerms);
            
            // Display sequence information
            const display = document.getElementById('sequenceDisplay');
            const firstTerms = sequenceData.slice(0, 6).map(term => 
                isNaN(term.value) ? 'undefined' : term.value.toFixed(4)
            ).join(', ');
            const lastTerm = sequenceData[sequenceData.length - 1];
            const lastTermStr = isNaN(lastTerm.value) ? 'undefined' : lastTerm.value.toFixed(6);
            
            let limitText = '';
            let convergenceRate = '';
            switch (currentSequenceType) {
                case 'harmonic':
                    limitText = 'lim ‚Üí 0 (slow convergence, O(1/n))';
                    break;
                case 'geometric':
                    limitText = 'lim ‚Üí 0 (exponential convergence)';
                    break;
                case 'polynomial':
                    limitText = 'lim ‚Üí 0 (fast convergence, O(1/n¬≤))';
                    break;
                case 'exponential':
                    limitText = 'lim ‚Üí 0 (very fast convergence)';
                    break;
                case 'alternating':
                    limitText = 'lim ‚Üí 0 (oscillating convergence)';
                    break;
                case 'fibonacci':
                    limitText = 'lim ‚Üí œÜ‚Åª¬π ‚âà 0.618 (golden ratio reciprocal)';
                    break;
                case 'sqrt':
                    limitText = 'lim ‚Üí 0 (slow convergence, O(1/‚àön))';
                    break;
                case 'factorial':
                    limitText = 'lim ‚Üí 0 (very fast convergence, Stirling approximation)';
                    break;
            }
            
            display.innerHTML = `
                <div style="font-family: 'Courier New', monospace;">
                    <strong>First terms:</strong> ${firstTerms}...<br>
                    <strong>Term ${numTerms}:</strong> ${lastTermStr}<br>
                    <strong>Behavior:</strong> ${limitText}
                </div>
            `;
            
            drawSequenceGraph();
        }

        // Interval Management
        function updateInterval() {
            intervalStart = parseFloat(document.getElementById('intervalStart').value);
            intervalEnd = parseFloat(document.getElementById('intervalEnd').value);
            intervalType = document.getElementById('intervalType').value;
            
            // Update info display
            let notation = '';
            let description = '';
            switch (intervalType) {
                case 'open':
                    notation = `(${intervalStart}, ${intervalEnd})`;
                    description = 'Open interval - endpoints not included';
                    break;
                case 'closed':
                    notation = `[${intervalStart}, ${intervalEnd}]`;
                    description = 'Closed interval - endpoints included';
                    break;
                case 'half-open-left':
                    notation = `(${intervalStart}, ${intervalEnd}]`;
                    description = 'Half-open interval - left endpoint excluded';
                    break;
                case 'half-open-right':
                    notation = `[${intervalStart}, ${intervalEnd})`;
                    description = 'Half-open interval - right endpoint excluded';
                    break;
            }
            
            document.getElementById('intervalInfo').innerHTML = `
                <strong>Notation:</strong> ${notation}<br>
                <strong>Type:</strong> ${description}<br>
                <strong>Length:</strong> ${Math.abs(intervalEnd - intervalStart).toFixed(2)}
            `;
            
            drawInterval();
        }

        // Topology Visualization
        function updateTopology() {
            currentTopologyType = document.getElementById('topologyType').value;
            
            let description = '';
            switch (currentTopologyType) {
                case 'open-closed':
                    description = 'Open sets contain neighborhoods of all points; closed sets contain all limit points';
                    break;
                case 'neighborhood':
                    description = 'Neighborhoods are open sets containing a given point';
                    break;
                case 'boundary':
                    description = 'Boundary points are limits of both interior and exterior points';
                    break;
                case 'compact':
                    description = 'Compact sets are closed and bounded (in ‚Ñù‚Åø)';
                    break;
                case 'connected':
                    description = 'Connected sets cannot be partitioned into disjoint open sets';
                    break;
            }
            
            document.getElementById('topologyInfo').innerHTML = description;
            drawTopologyConcepts();
        }

        // Continuity Analysis
        function updateContinuity() {
            currentFunctionType = document.getElementById('functionType').value;
            const epsilon = parseFloat(document.getElementById('epsilon').value);
            const point = parseFloat(document.getElementById('pointOfInterest').value);
            
            document.getElementById('epsilonValue').textContent = epsilon;
            
            let analysis = '';
            switch (currentFunctionType) {
                case 'continuous':
                    analysis = `f(x) = sin(x) is continuous everywhere. At x = ${point}, for Œµ = ${epsilon}, we can find Œ¥ = Œµ.`;
                    break;
                case 'jump':
                    analysis = `Jump discontinuity at x = ${point}. Left and right limits exist but are different.`;
                    break;
                case 'removable':
                    analysis = `Removable discontinuity at x = ${point}. Limit exists but f(${point}) is undefined or different.`;
                    break;
                case 'essential':
                    analysis = `Essential discontinuity at x = ${point}. Limit does not exist.`;
                    break;
                case 'uniform':
                    analysis = `Uniformly continuous function. Œ¥ depends only on Œµ, not on the point.`;
                    break;
            }
            
            document.getElementById('continuityInfo').innerHTML = analysis;
            drawContinuityAnalysis();
        }

        // Cardinality Exploration
        function updateCardinality() {
            currentCardinalityType = document.getElementById('cardinalityType').value;
            
            let explanation = '';
            switch (currentCardinalityType) {
                case 'natural-even':
                    explanation = 'Bijection f: ‚Ñï ‚Üí Even, f(n) = 2n shows |‚Ñï| = |Even|';
                    break;
                case 'natural-rational':
                    explanation = 'Cantor pairing function shows ‚Ñö is countable: |‚Ñï| = |‚Ñö|';
                    break;
                case 'natural-real':
                    explanation = 'Cantor\'s diagonal argument proves |‚Ñï| < |‚Ñù|';
                    break;
                case 'cantor-pairing':
                    explanation = 'Cantor pairing: f(m,n) = ¬Ω(m+n)(m+n+1)+n shows |‚Ñï√ó‚Ñï| = |‚Ñï|';
                    break;
                case 'power-set':
                    explanation = 'Cantor\'s theorem: no surjection from A to P(A), so |A| < |P(A)|';
                    break;
            }
            
            document.getElementById('cardinalityInfo').innerHTML = explanation;
            drawCardinalityVisualization();
        }
        
        // Drawing Functions
        function drawSetOperations() {
            const canvas = document.getElementById('setCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw Venn diagram
            const centerA = { x: width * 0.35, y: height * 0.5 };
            const centerB = { x: width * 0.65, y: height * 0.5 };
            const radius = 70;
            
            // Draw set A
            ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
            ctx.beginPath();
            ctx.arc(centerA.x, centerA.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw set B
            ctx.fillStyle = 'rgba(107, 142, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(centerB.x, centerB.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#6b8eff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('A', centerA.x - 45, centerA.y - 45);
            ctx.fillText('B', centerB.x + 35, centerB.y - 45);
            
            // Draw elements
            ctx.font = '14px Arial';
            ctx.fillStyle = '#333';
            
            // A only elements
            const aOnly = Array.from(setA).filter(x => !setB.has(x));
            aOnly.forEach((elem, i) => {
                ctx.fillText(elem.toString(), centerA.x - 40, centerA.y - 15 + i * 18);
            });
            
            // B only elements
            const bOnly = Array.from(setB).filter(x => !setA.has(x));
            bOnly.forEach((elem, i) => {
                ctx.fillText(elem.toString(), centerB.x + 25, centerB.y - 15 + i * 18);
            });
            
            // Intersection elements
            const intersection = Array.from(setA).filter(x => setB.has(x));
            intersection.forEach((elem, i) => {
                ctx.fillText(elem.toString(), (centerA.x + centerB.x) / 2 - 8, centerA.y - 15 + i * 18);
            });
            
            // Add cardinality information
            ctx.font = '12px Arial';
            ctx.fillStyle = '#666';
            ctx.fillText(`|A| = ${setA.size}`, centerA.x - 50, height - 20);
            ctx.fillText(`|B| = ${setB.size}`, centerB.x + 20, height - 20);
            ctx.fillText(`|A ‚à© B| = ${intersection.length}`, width/2 - 30, height - 40);
        }
        
        function drawSequenceGraph() {
            const canvas = document.getElementById('sequenceCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (sequenceData.length === 0) return;
            
            // Draw axes
            const margin = 40;
            const graphWidth = width - 2 * margin;
            const graphHeight = height - 2 * margin;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('n', width - 25, height - margin + 20);
            ctx.save();
            ctx.translate(15, margin + 20);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('a‚Çô', 0, 0);
            ctx.restore();
            
            // Find min/max values for scaling
            const maxN = Math.max(...sequenceData.map(d => d.n));
            const values = sequenceData.map(d => d.value).filter(v => !isNaN(v));
            const maxVal = Math.max(...values);
            const minVal = Math.min(...values);
            
            const yRange = Math.max(maxVal - minVal, 0.1);
            const yCenter = (maxVal + minVal) / 2;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 10; i++) {
                const x = margin + (i / 10) * graphWidth;
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, height - margin);
                ctx.stroke();
                
                const y = margin + (i / 10) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(width - margin, y);
                ctx.stroke();
            }
            
            // Draw sequence points and connecting lines
            ctx.strokeStyle = '#2196F3';
            ctx.fillStyle = '#2196F3';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            sequenceData.forEach((point, i) => {
                if (isNaN(point.value)) return;
                
                const x = margin + (point.n / maxN) * graphWidth;
                const y = height - margin - ((point.value - yCenter + yRange/2) / yRange) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // Draw point
                ctx.fillRect(x - 2, y - 2, 4, 4);
            });
            ctx.stroke();
            
            // Draw limit line
            let limitValue = 0;
            if (currentSequenceType === 'fibonacci') {
                limitValue = (Math.sqrt(5) - 1) / 2; // œÜ‚Åª¬π
            }
            
            const limitY = height - margin - ((limitValue - yCenter + yRange/2) / yRange) * graphHeight;
            
            if (limitY >= margin && limitY <= height - margin) {
                ctx.strokeStyle = 'red';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(margin, limitY);
                ctx.lineTo(width - margin, limitY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Limit label
                ctx.fillStyle = 'red';
                ctx.font = '12px Arial';
                ctx.fillText(`L = ${limitValue.toFixed(3)}`, width - margin - 60, limitY - 5);
            }
        }
        
        function drawInterval() {
            const canvas = document.getElementById('intervalCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw number line
            const lineY = height / 2;
            const margin = 50;
            const lineLength = width - 2 * margin;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(margin, lineY);
            ctx.lineTo(width - margin, lineY);
            ctx.stroke();
            
            // Draw tick marks and labels
            const range = 10;
            const step = lineLength / range;
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            for (let i = 0; i <= range; i++) {
                const x = margin + i * step;
                const value = -5 + i;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, lineY - 8);
                ctx.lineTo(x, lineY + 8);
                ctx.stroke();
                
                ctx.fillText(value.toString(), x, lineY + 25);
            }
            
            // Draw interval
            const startX = margin + (intervalStart + 5) * step;
            const endX = margin + (intervalEnd + 5) * step;
            
            // Interval line
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(startX, lineY);
            ctx.lineTo(endX, lineY);
            ctx.stroke();
            
            // Endpoint markers
            ctx.fillStyle = '#2196F3';
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            
            // Start point
            if (intervalType === 'open' || intervalType === 'half-open-right') {
                // Open circle
                ctx.beginPath();
                ctx.arc(startX, lineY, 6, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            } else {
                // Filled circle
                ctx.beginPath();
                ctx.arc(startX, lineY, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // End point
            ctx.fillStyle = '#2196F3';
            if (intervalType === 'open' || intervalType === 'half-open-left') {
                // Open circle
                ctx.beginPath();
                ctx.arc(endX, lineY, 6, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            } else {
                // Filled circle
                ctx.beginPath();
                ctx.arc(endX, lineY, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Interval notation
            let notation = '';
            switch (intervalType) {
                case 'open': notation = `(${intervalStart}, ${intervalEnd})`; break;
                case 'closed': notation = `[${intervalStart}, ${intervalEnd}]`; break;
                case 'half-open-left': notation = `(${intervalStart}, ${intervalEnd}]`; break;
                case 'half-open-right': notation = `[${intervalStart}, ${intervalEnd})`; break;
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(notation, width / 2, lineY - 35);
        }
        
        function drawTopologyConcepts() {
            const canvas = document.getElementById('topologyCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            switch (currentTopologyType) {
                case 'open-closed':
                    // Open set (dashed boundary)
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    
                    ctx.beginPath();
                    ctx.arc(centerX - 80, centerY, 60, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Open Set', centerX - 80, centerY + 85);
                    ctx.fillText('(no boundary)', centerX - 80, centerY + 100);
                    
                    // Closed set (solid boundary)
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY, 60, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.fillText('Closed Set', centerX + 80, centerY + 85);
                    ctx.fillText('(includes boundary)', centerX + 80, centerY + 100);
                    break;
                    
                case 'neighborhood':
                    // Point and its neighborhood
                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Neighborhood circles
                    for (let r = 20; r <= 60; r += 20) {
                        ctx.strokeStyle = `rgba(255, 107, 107, ${(80-r)/60})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Point with Neighborhoods', centerX, centerY + 85);
                    break;
                    
                case 'boundary':
                    // Set with boundary points
                    ctx.fillStyle = 'rgba(156, 39, 176, 0.3)';
                    ctx.fillRect(centerX - 80, centerY - 60, 160, 120);
                    
                    // Boundary
                    ctx.strokeStyle = '#9c27b0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(centerX - 80, centerY - 60, 160, 120);
                    
                    // Boundary points
                    ctx.fillStyle = '#9c27b0';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * 2 * Math.PI;
                        const x = centerX + 80 * Math.cos(angle);
                        const y = centerY + 60 * Math.sin(angle);
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Set with Boundary Points', centerX, centerY + 100);
                    break;
                    
                case 'compact':
                    // Compact set (closed and bounded)
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.4)';
                    ctx.strokeStyle = '#FFC107';
                    ctx.lineWidth = 4;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 70, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Bounding box
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.strokeRect(centerX - 85, centerY - 85, 170, 170);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Compact Set', centerX, centerY + 100);
                    ctx.fillText('(closed & bounded)', centerX, centerY + 115);
                    break;
                    
                case 'connected':
                    // Connected set
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
                    ctx.beginPath();
                    ctx.arc(centerX - 50, centerY, 40, 0, 2 * Math.PI);
                    ctx.arc(centerX + 50, centerY, 40, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Connection
                    ctx.fillRect(centerX - 50, centerY - 20, 100, 40);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Connected Set', centerX, centerY + 80);
                    break;
            }
        }
        
        function drawContinuityAnalysis() {
            const continuityCanvas = document.getElementById('continuityCanvas');
            const deltaEpsilonCanvas = document.getElementById('deltaEpsilonCanvas');
            
            if (!continuityCanvas || !deltaEpsilonCanvas) return;
            
            const ctx1 = continuityCanvas.getContext('2d');
            const ctx2 = deltaEpsilonCanvas.getContext('2d');
            
            // Clear both canvases
            ctx1.clearRect(0, 0, continuityCanvas.width, continuityCanvas.height);
            ctx2.clearRect(0, 0, deltaEpsilonCanvas.width, deltaEpsilonCanvas.height);
            
            // Draw function graph
            drawFunctionGraph(ctx1, currentFunctionType);
            
            // Draw delta-epsilon visualization
            drawDeltaEpsilon(ctx2, currentFunctionType);
        }
        
        function drawFunctionGraph(ctx, functionType) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const margin = 40;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.stroke();
            
            // Draw function
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const steps = 200;
            for (let i = 0; i <= steps; i++) {
                const x = -2 * Math.PI + (4 * Math.PI * i) / steps;
                const canvasX = margin + ((x + 2 * Math.PI) / (4 * Math.PI)) * (width - 2 * margin);
                
                let y;
                switch (functionType) {
                    case 'continuous':
                        y = Math.sin(x);
                        break;
                    case 'jump':
                        y = x < 0 ? -1 : 1;
                        break;
                    case 'removable':
                        y = x === 0 ? 0 : Math.sin(x) / x;
                        break;
                    case 'essential':
                        y = x === 0 ? 0 : Math.sin(1/x);
                        break;
                    case 'uniform':
                        y = Math.sqrt(Math.abs(x));
                        break;
                    default:
                        y = Math.sin(x);
                }
                
                const canvasY = height - margin - ((y + 2) / 4) * (height - 2 * margin);
                
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
        }
        
        function drawDeltaEpsilon(ctx, functionType) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const epsilon = parseFloat(document.getElementById('epsilon').value);
            
            // Draw epsilon-delta visualization
            ctx.fillStyle = 'rgba(255, 193, 7, 0.3)';
            ctx.fillRect(width/4, height/4, width/2, height/2);
            
            ctx.strokeStyle = '#FFC107';
            ctx.lineWidth = 2;
            ctx.strokeRect(width/4, height/4, width/2, height/2);
            
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Œµ-Œ¥ Definition Visualization', width/2, height - 20);
            ctx.fillText(`Œµ = ${epsilon}`, width/2, 30);
        }
        
        function drawCardinalityVisualization() {
            const canvas = document.getElementById('cardinalityCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            switch (currentCardinalityType) {
                case 'natural-even':
                    drawNaturalEvenBijection(ctx, width, height);
                    break;
                case 'natural-rational':
                    drawCantorPairing(ctx, width, height);
                    break;
                case 'natural-real':
                    drawDiagonalArgument(ctx, width, height);
                    break;
                case 'cantor-pairing':
                    drawCantorPairingFunction(ctx, width, height);
                    break;
                case 'power-set':
                    drawPowerSetVisualization(ctx, width, height);
                    break;
            }
        }
        
        function drawNaturalEvenBijection(ctx, width, height) {
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Bijection f: ‚Ñï ‚Üí Even Numbers, f(n) = 2n', width/2, 30);
            
            // Draw mappings
            for (let i = 1; i <= 8; i++) {
                const x1 = width/4;
                const x2 = 3*width/4;
                const y = 60 + i * 35;
                
                // Natural number
                ctx.fillText(i.toString(), x1, y);
                
                // Arrow
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x1 + 20, y - 5);
                ctx.lineTo(x2 - 20, y - 5);
                ctx.stroke();
                
                // Even number
                ctx.fillText((2*i).toString(), x2, y);
            }
            
            ctx.fillText('‚Ñï', width/4, height - 20);
            ctx.fillText('Even Numbers', 3*width/4, height - 20);
        }
        
        function drawCantorPairing(ctx, width, height) {
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Cantor Pairing Shows ‚Ñö is Countable', width/2, 30);
            
            // Draw grid showing rational enumeration
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            
            const gridSize = 40;
            const startX = 50;
            const startY = 60;
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const x = startX + i * gridSize;
                    const y = startY + j * gridSize;
                    
                    ctx.strokeRect(x, y, gridSize, gridSize);
                    
                    // Show fraction
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${j+1}/${i+1}`, x + gridSize/2, y + gridSize/2);
                }
            }
        }
        
        function drawDiagonalArgument(ctx, width, height) {
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Cantor\'s Diagonal Argument: |‚Ñù| > |‚Ñï|', width/2, 30);
            
            // Draw binary sequences
            const sequences = [
                '0.101010...',
                '0.110011...',
                '0.001100...',
                '0.111000...',
                '0.010101...'
            ];
            
            sequences.forEach((seq, i) => {
                const y = 70 + i * 30;
                ctx.fillText(`s${i+1}: ${seq}`, width/4, y);
                
                // Highlight diagonal
                if (i < 3) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillText(seq[2+i], width/2 + i*15, y);
                    ctx.fillStyle = '#333';
                }
            });
            
            ctx.fillStyle = '#ff6b6b';
            ctx.fillText('Diagonal: 0.101...', width/2, height - 80);
            ctx.fillText('New number: 0.010... (flipped)', width/2, height - 50);
        }
        
        function drawCantorPairingFunction(ctx, width, height) {
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Cantor Pairing Function: f(m,n) = ¬Ω(m+n)(m+n+1)+n', width/2, 30);
            
            // Draw pairing visualization
            const pairs = [
                [0,0], [0,1], [1,0], [0,2], [1,1], [2,0], [0,3], [1,2]
            ];
            
            pairs.forEach((pair, i) => {
                const x = 100 + (i % 4) * 150;
                const y = 80 + Math.floor(i / 4) * 60;
                
                const pairingValue = 0.5 * (pair[0] + pair[1]) * (pair[0] + pair[1] + 1) + pair[1];
                
                ctx.fillText(`(${pair[0]},${pair[1]}) ‚Üí ${pairingValue}`, x, y);
            });
        }
        
        function drawPowerSetVisualization(ctx, width, height) {
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Power Set |P(A)| > |A|', width/2, 30);
            
            // Show example with small set
            ctx.font = '14px Arial';
            ctx.fillText('A = {1, 2}', width/4, 80);
            ctx.fillText('P(A) = {‚àÖ, {1}, {2}, {1,2}}', 3*width/4, 80);
            
            ctx.fillText('|A| = 2', width/4, 120);
            ctx.fillText('|P(A)| = 4 = 2¬≤', 3*width/4, 120);
            
            // Cantor's theorem explanation
            ctx.font = '12px Arial';
            ctx.fillText('No function f: A ‚Üí P(A) can be surjective', width/2, 160);
            ctx.fillText('(Cantor\'s diagonal argument applies)', width/2, 180);
        }
        
        // Exercise Functions
        function checkDeltaEpsilon() {
            const guess = parseFloat(document.getElementById('delta-guess').value);
            const result = document.getElementById('delta-result');
            
            // For f(x) = x¬≤, f'(2) = 4, so Œ¥ = Œµ/4 for small Œµ
            const epsilon = 0.1;
            const correct = epsilon / 4; // Œ¥ = Œµ/4 = 0.025
            
            if (Math.abs(guess - correct) < 0.005) {
                result.innerHTML = '<span style="color: #4caf50;">‚úì Correct! For f(x) = x¬≤ at x = 2, Œ¥ = Œµ/4 works because |f\'(2)| = 4</span>';
            } else {
                result.innerHTML = `<span style="color: #f44336;">‚úó Try again. Hint: Use f'(2) = 4. Correct Œ¥ ‚âà ${correct.toFixed(3)}</span>`;
            }
        }
        
        function checkCardinality() {
            const choice = document.getElementById('cardinality-choice').value;
            const result = document.getElementById('cardinality-result');
            
            if (choice === 'integers' || choice === 'rationals') {
                result.innerHTML = '<span style="color: #4caf50;">‚úì Correct! Both ‚Ñ§ and ‚Ñö have the same cardinality as ‚Ñï (countably infinite)</span>';
            } else if (choice === 'reals') {
                result.innerHTML = '<span style="color: #f44336;">‚úó Incorrect. ‚Ñù has greater cardinality than ‚Ñï (uncountable vs countable)</span>';
            } else if (choice === 'powerset') {
                result.innerHTML = '<span style="color: #f44336;">‚úó Incorrect. P(‚Ñï) has greater cardinality than ‚Ñï by Cantor\'s theorem</span>';
            } else {
                result.innerHTML = '<span style="color: #ff9800;">Please select an option</span>';
            }
        }
        
        function checkConvergence() {
            const converges = document.getElementById('convergence-choice').value;
            const limit = parseFloat(document.getElementById('limit-guess').value);
            const result = document.getElementById('convergence-result');
            
            // For (n¬≤ + 1)/(2n¬≤ - 3), divide by n¬≤: (1 + 1/n¬≤)/(2 - 3/n¬≤) ‚Üí 1/2
            const correctLimit = 0.5;
            
            if (converges === 'yes' && Math.abs(limit - correctLimit) < 0.1) {
                result.innerHTML = '<span style="color: #4caf50;">‚úì Correct! The sequence converges to 1/2. Divide numerator and denominator by n¬≤ to see this.</span>';
            } else if (converges === 'yes' && Math.abs(limit - correctLimit) >= 0.1) {
                result.innerHTML = '<span style="color: #ff9800;">Convergence is correct, but check the limit. Hint: divide by highest power of n</span>';
            } else if (converges === 'no') {
                result.innerHTML = '<span style="color: #f44336;">‚úó The sequence does converge. Try dividing numerator and denominator by n¬≤</span>';
            } else {
                result.innerHTML = '<span style="color: #ff9800;">Please select whether it converges and provide a limit if it does</span>';
            }
        }
        
        function exploreProof() {
            const theorem = document.getElementById('proof-theorem').value;
            const content = document.getElementById('proof-content');
            
            let proofHTML = '';
            
            switch (theorem) {
                case 'cantor-diagonal':
                    proofHTML = `
                        <h4>Cantor's Diagonal Argument</h4>
                        <p><strong>Theorem:</strong> The set of real numbers is uncountable.</p>
                        <p><strong>Proof Idea:</strong></p>
                        <ol>
                            <li>Assume ‚Ñù is countable, so we can list all reals: r‚ÇÅ, r‚ÇÇ, r‚ÇÉ, ...</li>
                            <li>Write each real in binary: r‚ÇÅ = 0.a‚ÇÅ‚ÇÅa‚ÇÅ‚ÇÇa‚ÇÅ‚ÇÉ..., r‚ÇÇ = 0.a‚ÇÇ‚ÇÅa‚ÇÇ‚ÇÇa‚ÇÇ‚ÇÉ...</li>
                            <li>Construct a new real d = 0.d‚ÇÅd‚ÇÇd‚ÇÉ... where d·µ¢ ‚â† a·µ¢·µ¢ (flip diagonal bits)</li>
                            <li>Then d differs from r·µ¢ in the i-th decimal place for all i</li>
                            <li>So d is not in our list, contradicting the assumption that we listed all reals</li>
                            <li>Therefore, ‚Ñù is uncountable</li>
                        </ol>
                        <p><strong>Key Insight:</strong> The diagonal construction always produces a new element not in any countable list.</p>
                    `;
                    break;
                    
                case 'bolzano-weierstrass':
                    proofHTML = `
                        <h4>Bolzano-Weierstrass Theorem</h4>
                        <p><strong>Theorem:</strong> Every bounded sequence in ‚Ñù has a convergent subsequence.</p>
                        <p><strong>Proof Outline:</strong></p>
                        <ol>
                            <li>Let (a‚Çô) be a bounded sequence in ‚Ñù</li>
                            <li>Since (a‚Çô) is bounded, all terms lie in some interval [a,b]</li>
                            <li>Divide [a,b] in half. At least one half contains infinitely many terms of the sequence</li>
                            <li>Choose such a half and repeat the process indefinitely</li>
                            <li>This gives nested intervals [a‚ÇÄ,b‚ÇÄ] ‚äÉ [a‚ÇÅ,b‚ÇÅ] ‚äÉ [a‚ÇÇ,b‚ÇÇ] ‚äÉ ...</li>
                            <li>The intersection point L is the limit of a subsequence</li>
                        </ol>
                        <p><strong>Application:</strong> This theorem is fundamental in proving compactness and the extreme value theorem.</p>
                    `;
                    break;
                    
                case 'intermediate-value':
                    proofHTML = `
                        <h4>Intermediate Value Theorem</h4>
                        <p><strong>Theorem:</strong> If f is continuous on [a,b] and k is between f(a) and f(b), then ‚àÉc ‚àà (a,b) such that f(c) = k.</p>
                        <p><strong>Proof Strategy:</strong></p>
                        <ol>
                            <li>WLOG assume f(a) < k < f(b)</li>
                            <li>Define S = {x ‚àà [a,b] : f(x) < k}</li>
                            <li>S is non-empty (contains a) and bounded above by b</li>
                            <li>Let c = sup(S) by completeness of ‚Ñù</li>
                            <li>Show f(c) = k using continuity:</li>
                            <li>- If f(c) < k, then f(x) < k in a neighborhood of c (contradiction)</li>
                            <li>- If f(c) > k, then f(x) > k in a neighborhood of c (contradiction)</li>
                            <li>Therefore f(c) = k</li>
                        </ol>
                        <p><strong>Geometric Intuition:</strong> A continuous function cannot "jump over" intermediate values.</p>
                    `;
                    break;
                    
                case 'heine-borel':
                    proofHTML = `
                        <h4>Heine-Borel Theorem</h4>
                        <p><strong>Theorem:</strong> In ‚Ñù‚Åø, a set K is compact ‚ü∫ K is closed and bounded.</p>
                        <p><strong>Proof Outline:</strong></p>
                        <p><strong>(‚üπ) Compact ‚üπ Closed and Bounded:</strong></p>
                        <ol>
                            <li><strong>Bounded:</strong> Cover K with balls B(0,n), n ‚àà ‚Ñï. Extract finite subcover.</li>
                            <li><strong>Closed:</strong> If x ‚àâ K, cover each k ‚àà K with disjoint neighborhoods of k and x.</li>
                        </ol>
                        <p><strong>(‚ü∏) Closed and Bounded ‚üπ Compact:</strong></p>
                        <ol>
                            <li>If K ‚äÜ ‚Ñù‚Åø is bounded, then K ‚äÜ [‚àíM,M]‚Åø for some M</li>
                            <li>Use nested interval theorem and diagonal argument</li>
                            <li>Any open cover has a finite subcover by construction</li>
                        </ol>
                        <p><strong>Note:</strong> This characterization is specific to ‚Ñù‚Åø and fails in general metric spaces.</p>
                    `;
                    break;
                    
                default:
                    proofHTML = '<p>Select a theorem to explore its proof</p>';
            }
            
            content.innerHTML = proofHTML;
        }
        
        // Event Listeners Setup
        function setupEventListeners() {
            // Epsilon slider
            const epsilonSlider = document.getElementById('epsilon');
            if (epsilonSlider) {
                epsilonSlider.addEventListener('input', function() {
                    document.getElementById('epsilonValue').textContent = this.value;
                });
            }
            
            // Auto-update topology when type changes
            const topologySelect = document.getElementById('topologyType');
            if (topologySelect) {
                topologySelect.addEventListener('change', updateTopology);
            }
            
            // Auto-update cardinality when type changes
            const cardinalitySelect = document.getElementById('cardinalityType');
            if (cardinalitySelect) {
                cardinalitySelect.addEventListener('change', updateCardinality);
            }
            
            // Auto-update function when type changes
            const functionSelect = document.getElementById('functionType');
            if (functionSelect) {
                functionSelect.addEventListener('change', updateContinuity);
            }
        }
        
        // Initialize all visualizations
        function initializeAll() {
            setupEventListeners();
            updateSetOperations();
            updateSequence();
            updateInterval();
            updateTopology();
            updateContinuity();
            updateCardinality();
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeAll);
    </script>
</body>
</html>
