<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lagrangian & ƒêi·ªÅu Ki·ªán KKT - T·ªëi ∆Øu H√≥a C√≥ R√†ng Bu·ªôc</title>
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mtml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            chtml: {
                displayAlign: 'left'
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Main App Container */
        .app-container {
            max-width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header with Title */
        .app-header {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 30px;
            border-bottom: 3px solid rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 100;
        }
        
        .app-title {
            font-size: 1.5em;
            color: #00FFFF;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
            font-weight: 600;
        }
        
        .app-subtitle {
            color: #cccccc;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            background: rgba(0, 0, 0, 0.8);
            padding: 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .tab-button {
            background: transparent;
            border: none;
            color: #cccccc;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
        }
        
        .tab-button.active {
            color: #00FFFF;
            background: rgba(0, 255, 255, 0.1);
            border-bottom-color: #00FFFF;
        }
        
        /* Tab Content Container */
        .tab-content-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .tab-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            overflow-y: auto;
        }
        
        .tab-content.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* Interactive Tab Styles */
        .interactive-content {
            display: flex;
            height: 100%;
            min-height: calc(100vh - 120px);
            flex-direction: column;
        }
        
        .visualization-row {
            display: flex;
            flex: 1;
            margin-bottom: 20px;
        }
        
        .canvas-3d-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 400px;
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        .info-panel-3d {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 165, 0, 0.3);
            max-width: 280px;
        }
        
        .section-divider {
            margin: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
            text-align: center;
        }
        
        .section-divider h3 {
            color: #ff6b6b;
            margin: 0;
            font-size: 1.1em;
        }
        
        .header-section {
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .header-section h1 {
            margin: 0 0 12px 0;
            font-size: 1.8em;
            color: #00FFFF;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
            font-weight: 600;
        }
        
        .header-section p {
            margin: 6px 0;
            font-size: 1.05em;
            color: #e0e0e0;
            line-height: 1.5;
        }
        
        .mathematical-foundation {
            background: rgba(255, 215, 0, 0.1);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #FFD700;
            backdrop-filter: blur(10px);
        }
        
        .foundation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }
        
        .foundation-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00FFFF;
        }
        
        .foundation-item h4 {
            color: #00FFFF;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        canvas {
            background: #000;
            border: none;
            width: 100%;
            height: auto;
            max-height: calc(100vh - 200px);
        }
        
        .info-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            max-width: 300px;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            margin: 4px 0;
            color: #cccccc;
        }
        
        .controls {
            width: 420px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            backdrop-filter: blur(15px);
            max-height: calc(100vh - 120px);
        }
        
        /* Theory Tab Styles */
        .theory-content {
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
            overflow-y: auto;
        }
        
        .theory-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .theory-header h1 {
            font-size: 2.2em;
            color: #00FFFF;
            margin-bottom: 15px;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
        }
        
        .theory-header p {
            font-size: 1.1em;
            color: #e0e0e0;
            margin: 8px 0;
        }
        
        .mathematical-foundation {
            background: rgba(255, 215, 0, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #FFD700;
            backdrop-filter: blur(10px);
        }
        
        .foundation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        
        .foundation-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #00FFFF;
            transition: transform 0.3s ease;
        }
        
        .foundation-item:hover {
            transform: translateY(-5px);
        }
        
        .foundation-item h4 {
            color: #00FFFF;
            margin: 0 0 12px 0;
            font-size: 1.2em;
        }
        
        .theory-box {
            background: rgba(52, 152, 219, 0.12);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #3498db;
            backdrop-filter: blur(10px);
        }
        
        .theory-box h4 {
            color: #3498db;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .example-box {
            background: rgba(155, 89, 182, 0.12);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #9b59b6;
            backdrop-filter: blur(10px);
        }
        
        .example-box h4 {
            color: #9b59b6;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .controls {
            width: 480px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-left: 1px solid #444;
            overflow-y: auto;
            backdrop-filter: blur(15px);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        .control-section {
            margin-bottom: 25px;
            padding: 18px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .control-section:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .control-section h3 {
            margin: 0 0 18px 0;
            color: #00FFFF;
            font-size: 1.1em;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.3);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 8px;
        }
        
        .problem-setup {
            background: rgba(0, 255, 255, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 18px;
            border-left: 4px solid #00FFFF;
            backdrop-filter: blur(5px);
        }
        
        .kkt-conditions {
            background: rgba(255, 255, 0, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 18px;
            border-left: 4px solid #FFD700;
            max-height: 280px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        
        .lagrangian-display {
            background: rgba(255, 0, 255, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 18px;
            border-left: 4px solid #FF69B4;
            backdrop-filter: blur(5px);
        }
        
        .toggle-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 18px;
        }
        
        .toggle-button {
            padding: 10px 8px;
            background: linear-gradient(145deg, #333, #2a2a2a);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .toggle-button:hover {
            background: linear-gradient(145deg, #444, #333);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .toggle-button.active {
            background: linear-gradient(145deg, #00FFFF, #0099CC);
            color: #000;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        
        .info-panel {
            position: relative;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.92);
            padding: 18px;
            border-radius: 12px;
            font-size: 13px;
            max-width: 420px;
            z-index: 10;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        .info-panel strong {
            color: #00FFFF;
            font-size: 1.1em;
            text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.3);
        }
        
        .legend {
            font-size: 12px;
            margin-top: 12px;
            line-height: 1.6;
        }
        
        .legend-item {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-item::before {
            content: "";
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-item:nth-child(1)::before { background: #00FFFF; }
        .legend-item:nth-child(2)::before { background: #e74c3c; }
        .legend-item:nth-child(3)::before { background: #f39c12; }
        .legend-item:nth-child(4)::before { background: #2ecc71; }
        .legend-item:nth-child(5)::before { background: #9b59b6; }
        .legend-item:nth-child(6)::before { background: #e67e22; }
        
        .slider-group {
            margin: 12px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #ccc;
            font-weight: 500;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, #00FFFF, #0099CC);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .slider-value {
            font-size: 12px;
            color: #00FFFF;
            text-align: right;
            margin-top: 5px;
            font-weight: 600;
        }
        
        .problem-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 18px;
        }
        
        .problem-button {
            padding: 12px 8px;
            background: linear-gradient(145deg, #333, #2a2a2a);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .problem-button:hover {
            background: linear-gradient(145deg, #444, #333);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .problem-button.active {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #000;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
        }
        
        .multiplier-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-bottom: 18px;
        }
        
        .multiplier-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .multiplier-input label {
            font-size: 13px;
            margin-bottom: 8px;
            color: #00FFFF;
            font-weight: 600;
        }
        
        .multiplier-input input {
            width: 80px;
            padding: 6px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .multiplier-input input:focus {
            outline: none;
            border-color: #00FFFF;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .point-analysis {
            background: rgba(0, 255, 0, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: 18px;
            border-left: 4px solid #2ecc71;
            backdrop-filter: blur(5px);
        }
        
        .condition-status {
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            border-left: 3px solid;
            transition: all 0.3s ease;
        }
        
        .condition-satisfied {
            background: rgba(46, 204, 113, 0.25);
            color: #2ecc71;
            border-left-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.2);
        }
        
        .condition-violated {
            background: rgba(231, 76, 60, 0.25);
            color: #e74c3c;
            border-left-color: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.2);
        }
        
        .theory-box {
            background: rgba(52, 152, 219, 0.12);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
            backdrop-filter: blur(10px);
        }
        
        .theory-box h4 {
            color: #3498db;
            margin: 0 0 12px 0;
            font-size: 1.1em;
        }
        
        .example-box {
            background: rgba(155, 89, 182, 0.12);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #9b59b6;
            backdrop-filter: blur(10px);
        }
        
        .example-box h4 {
            color: #9b59b6;
            margin: 0 0 12px 0;
            font-size: 1.1em;
        }
    </style>

</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <h1 class="app-title">‚öñÔ∏è Lagrangian & ƒêi·ªÅu Ki·ªán KKT</h1>
            <p class="app-subtitle">T·ªëi ∆∞u h√≥a c√≥ r√†ng bu·ªôc - Interactive Learning</p>
        </header>
        
        <!-- Tab Navigation -->
        <nav class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('interactive', event)">
                üéØ Tr·ª±c Quan T∆∞∆°ng T√°c
            </button>
            <button class="tab-button" onclick="switchTab('theory', event)">
                üìê N·ªÅn T·∫£ng To√°n H·ªçc
            </button>
        </nav>
        
        <!-- Tab Content Container -->
        <main class="tab-content-container">
            <!-- Interactive Tab -->
            <div id="interactive-tab" class="tab-content active">
                <div class="interactive-content">
                    <!-- 2D Visualization Row -->
                    <div class="visualization-row">
                        <div class="canvas-container">
                            <canvas id="canvas" width="800" height="600"></canvas>
                            <div class="info-panel">
                                <strong>‚öñÔ∏è 2D Lagrangian Visualization</strong><br/>
                                Kh√°m ph√° t∆∞∆°ng t√°c gi·ªØa h√†m m·ª•c ti√™u, r√†ng bu·ªôc v√† nh√¢n t·ª≠ Lagrange.
                                <div class="legend">
                                    <div class="legend-item">üîµ ƒê∆∞·ªùng m·ª©c h√†m m·ª•c ti√™u f(x,y)</div>
                                    <div class="legend-item">üî¥ R√†ng bu·ªôc ƒë·∫≥ng th·ª©c g(x,y) = 0</div>
                                    <div class="legend-item">üü° R√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c h(x,y) ‚â§ 0</div>
                                    <div class="legend-item">üü¢ V√πng kh·∫£ thi</div>
                                    <div class="legend-item">üü£ ƒêi·ªÉm t·ªëi ∆∞u x*</div>
                                    <div class="legend-item">‚û°Ô∏è Vector gradient</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="controls">
                            <div class="control-section">
                                <h3>üéØ Ch·ªçn B√†i To√°n</h3>
                                <div class="problem-selector">
                                    <button class="problem-button active" onclick="selectProblem('equality', event)">R√†ng Bu·ªôc ƒê·∫≥ng Th·ª©c</button>
                                    <button class="problem-button" onclick="selectProblem('inequality', event)">R√†ng Bu·ªôc B·∫•t ƒê·∫≥ng Th·ª©c</button>
                                    <button class="problem-button" onclick="selectProblem('mixed', event)">R√†ng Bu·ªôc H·ªón H·ª£p</button>
                                    <button class="problem-button" onclick="selectProblem('quadratic', event)">Quy Ho·∫°ch B·∫≠c 2</button>
                                    <button class="problem-button" onclick="selectProblem('nonconvex', event)">Kh√¥ng L·ªìi</button>
                                    <button class="problem-button" onclick="selectProblem('infeasible', event)">Kh√¥ng Kh·∫£ Thi</button>
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>üìã B√†i To√°n Hi·ªán T·∫°i</h3>
                                <div id="problem-setup" class="problem-setup">
                                    <!-- Problem formulation will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>üìö H√†m Lagrangian</h3>
                                <div id="lagrangian-display" class="lagrangian-display">
                                    <!-- Lagrangian will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>‚öñÔ∏è ƒêi·ªÅu Ki·ªán KKT</h3>
                                <div id="kkt-conditions" class="kkt-conditions">
                                    <!-- KKT conditions will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>üé® T√πy Ch·ªçn Hi·ªÉn Th·ªã</h3>
                                <div class="toggle-section">
                                    <div class="toggle-button active" id="toggle-objective" onclick="toggleVisualization('objective')">
                                        ƒê∆∞·ªùng M·ª©c f(x,y)
                                    </div>
                                    <div class="toggle-button active" id="toggle-constraints" onclick="toggleVisualization('constraints')">
                                        ƒê∆∞·ªùng R√†ng Bu·ªôc
                                    </div>
                                    <div class="toggle-button active" id="toggle-feasible" onclick="toggleVisualization('feasible')">
                                        V√πng Kh·∫£ Thi
                                    </div>
                                    <div class="toggle-button active" id="toggle-gradients" onclick="toggleVisualization('gradients')">
                                        Vector Gradient
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Section Divider -->
                    <div class="section-divider">
                        <h3>üîÑ 3D Surface Visualization - Kh√°m ph√° b·ªÅ m·∫∑t t·ªëi ∆∞u h√≥a trong kh√¥ng gian 3D</h3>
                    </div>
                    
                    <!-- 3D Visualization Row -->
                    <div class="visualization-row">
                        <div class="canvas-3d-container">
                            <div id="canvas3d"></div>
                            <div class="info-panel-3d">
                                <strong>üåê 3D Lagrangian Surface</strong><br/>
                                B·ªÅ m·∫∑t h√†m m·ª•c ti√™u v√† r√†ng bu·ªôc trong kh√¥ng gian 3D
                                <div class="legend">
                                    <div class="legend-item">üåä B·ªÅ m·∫∑t h√†m m·ª•c ti√™u f(x,y)</div>
                                    <div class="legend-item">üî¥ M·∫∑t ph·∫≥ng r√†ng bu·ªôc</div>
                                    <div class="legend-item">üü£ ƒêi·ªÉm t·ªëi ∆∞u</div>
                                    <div class="legend-item">üéÆ K√©o ƒë·ªÉ xoay, cu·ªôn ƒë·ªÉ zoom</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 3D Controls -->
                        <div class="controls">
                            <div class="control-section">
                                <h3>üåê ƒêi·ªÅu Khi·ªÉn 3D</h3>
                                <div class="toggle-section">
                                    <label>
                                        <input type="checkbox" id="show3DSurface" checked onchange="update3DVisualization()">
                                        Hi·ªÉn th·ªã b·ªÅ m·∫∑t h√†m m·ª•c ti√™u
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DConstraints" checked onchange="update3DVisualization()">
                                        Hi·ªÉn th·ªã r√†ng bu·ªôc
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DOptimal" checked onchange="update3DVisualization()">
                                        Hi·ªÉn th·ªã ƒëi·ªÉm t·ªëi ∆∞u
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DWireframe" onchange="update3DVisualization()">
                                        Wireframe mode
                                    </label>
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>ƒê·ªô ph√¢n gi·∫£i:</label>
                                    <input type="range" id="resolution3D" min="20" max="80" value="40" onchange="update3DVisualization()">
                                    <span id="resolutionValue">40</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üìã B√†i To√°n Hi·ªán T·∫°i</h3>
                <div id="problem-setup" class="problem-setup">
                    <!-- Problem formulation will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>üìö H√†m Lagrangian</h3>
                <div id="lagrangian-display" class="lagrangian-display">
                    <!-- Lagrangian will be displayed here -->
                </div>
                <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; font-size: 11px; margin-top: 10px;">
                    <strong>üí° Ghi Ch√∫:</strong> H√†m Lagrangian k·∫øt h·ª£p h√†m m·ª•c ti√™u v·ªõi c√°c r√†ng bu·ªôc th√¥ng qua nh√¢n t·ª≠ Lagrange.
                    Vi·ªác t·ªëi ∆∞u h√≥a Lagrangian cho ph√©p x·ª≠ l√Ω r√†ng bu·ªôc m·ªôt c√°ch t·ª± nhi√™n.
                </div>
            </div>
                    </div>
                </div>
            </div>
            
            <!-- Theory Tab -->
            <div id="theory-tab" class="tab-content">
                <div class="theory-content">
                    <div class="theory-header">
                        <h1>‚öñÔ∏è Lagrangian & ƒêi·ªÅu Ki·ªán KKT - T·ªëi ∆Øu H√≥a C√≥ R√†ng Bu·ªôc</h1>
                        <p><strong>üéØ M·ª•c Ti√™u:</strong> Kh√°m ph√° ph∆∞∆°ng ph√°p Lagrange v√† ƒëi·ªÅu ki·ªán Karush-Kuhn-Tucker (KKT) trong t·ªëi ∆∞u h√≥a c√≥ r√†ng bu·ªôc</p>
                        <p><strong>üí° √ù Nghƒ©a:</strong> T√¨m ƒëi·ªÉm t·ªëi ∆∞u khi c√≥ c√°c r√†ng bu·ªôc ƒë·∫≥ng th·ª©c v√† b·∫•t ƒë·∫≥ng th·ª©c</p>
                    </div>
                    
                    <div class="mathematical-foundation">
                        <h3 style="color: #FFD700; margin: 0 0 15px 0; font-size: 1.2em;">üìê N·ªÅn T·∫£ng To√°n H·ªçc</h3>
                        
                        <div class="foundation-grid">
                            <div class="foundation-item">
                                <h4>üîç B√†i To√°n T·ªïng Qu√°t</h4>
                                <p style="font-size: 0.9em; margin: 5px 0;">
                                    $$\min_{x} f(x)$$
                                    $$\text{s.t. } g_i(x) = 0, \quad i = 1,\ldots,m$$
                                    $$h_j(x) \leq 0, \quad j = 1,\ldots,p$$
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>üìö H√†m Lagrangian</h4>
                                <p style="font-size: 0.9em; margin: 5px 0;">
                                    $$L(x,\lambda,\mu) = f(x) + \sum_{i=1}^m \lambda_i g_i(x) + \sum_{j=1}^p \mu_j h_j(x)$$
                                    <br><strong>Œª:</strong> nh√¢n t·ª≠ Lagrange cho r√†ng bu·ªôc ƒë·∫≥ng th·ª©c
                                    <br><strong>Œº:</strong> nh√¢n t·ª≠ KKT cho r√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>‚ö° ƒêi·ªÅu Ki·ªán KKT</h4>
                                <p style="font-size: 0.85em; margin: 5px 0;">
                                    1. <strong>Stationarity:</strong> $\nabla_x L = 0$<br>
                                    2. <strong>Primal feasibility:</strong> $g_i(x) = 0$, $h_j(x) \leq 0$<br>
                                    3. <strong>Dual feasibility:</strong> $\mu_j \geq 0$<br>
                                    4. <strong>Complementary slackness:</strong> $\mu_j h_j(x) = 0$
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>üéØ √ù Nghƒ©a H√¨nh H·ªçc</h4>
                                <p style="font-size: 0.85em; margin: 5px 0;">
                                    T·∫°i ƒëi·ªÉm t·ªëi ∆∞u, gradient c·ªßa h√†m m·ª•c ti√™u l√† t·ªï h·ª£p tuy·∫øn t√≠nh c·ªßa gradient c√°c r√†ng bu·ªôc active:
                                    $$\nabla f(x^*) = -\sum_i \lambda_i^* \nabla g_i(x^*) - \sum_j \mu_j^* \nabla h_j(x^*)$$
                                </p>
                            </div>
                        </div>
                        
                        <div class="theory-box">
                            <h4>üßÆ ƒê·ªãnh L√Ω C∆° B·∫£n</h4>
                            <p style="font-size: 0.9em; line-height: 1.6;">
                                <strong>ƒêi·ªÅu ki·ªán c·∫ßn:</strong> N·∫øu $x^*$ l√† ƒëi·ªÉm t·ªëi ∆∞u ƒë·ªãa ph∆∞∆°ng v√† LICQ (Linear Independence Constraint Qualification) th·ªèa m√£n, 
                                th√¨ t·ªìn t·∫°i $(\lambda^*, \mu^*)$ sao cho ƒëi·ªÅu ki·ªán KKT ƒë∆∞·ª£c th·ªèa m√£n.<br><br>
                                
                                <strong>ƒêi·ªÅu ki·ªán ƒë·ªß:</strong> N·∫øu h√†m m·ª•c ti√™u v√† r√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c l√† convex, r√†ng bu·ªôc ƒë·∫≥ng th·ª©c l√† affine, 
                                v√† ƒëi·ªÅu ki·ªán KKT th·ªèa m√£n t·∫°i $(x^*, \lambda^*, \mu^*)$, th√¨ $x^*$ l√† ƒëi·ªÉm t·ªëi ∆∞u to√†n c·ª•c.
                            </p>
                        </div>
                        
                        <div class="example-box">
                            <h4>üìã ·ª®ng D·ª•ng Th·ª±c T·∫ø</h4>
                            <p style="font-size: 0.9em; line-height: 1.6;">
                                ‚Ä¢ <strong>Portfolio Optimization:</strong> T·ªëi ∆∞u h√≥a danh m·ª•c ƒë·∫ßu t∆∞ v·ªõi r√†ng bu·ªôc ng√¢n s√°ch v√† r·ªßi ro<br>
                                ‚Ä¢ <strong>Machine Learning:</strong> Support Vector Machines (SVM) v·ªõi r√†ng bu·ªôc margin<br>
                                ‚Ä¢ <strong>Engineering Design:</strong> Thi·∫øt k·∫ø t·ªëi ∆∞u v·ªõi r√†ng bu·ªôc v·ªÅ v·∫≠t li·ªáu v√† an to√†n<br>
                                ‚Ä¢ <strong>Resource Allocation:</strong> Ph√¢n b·ªï t√†i nguy√™n v·ªõi r√†ng bu·ªôc v·ªÅ dung l∆∞·ª£ng
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
            
            <div class="theory-box">
                <h4>üßÆ ƒê·ªãnh L√Ω C∆° B·∫£n</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    <strong>ƒêi·ªÅu ki·ªán c·∫ßn:</strong> N·∫øu $x^*$ l√† ƒëi·ªÉm t·ªëi ∆∞u ƒë·ªãa ph∆∞∆°ng v√† LICQ (Linear Independence Constraint Qualification) th·ªèa m√£n, 
                    th√¨ t·ªìn t·∫°i $(\lambda^*, \mu^*)$ sao cho ƒëi·ªÅu ki·ªán KKT ƒë∆∞·ª£c th·ªèa m√£n.<br><br>
                    
                    <strong>ƒêi·ªÅu ki·ªán ƒë·ªß:</strong> N·∫øu h√†m m·ª•c ti√™u v√† r√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c l√† convex, r√†ng bu·ªôc ƒë·∫≥ng th·ª©c l√† affine, 
                    v√† ƒëi·ªÅu ki·ªán KKT th·ªèa m√£n t·∫°i $(x^*, \lambda^*, \mu^*)$, th√¨ $x^*$ l√† ƒëi·ªÉm t·ªëi ∆∞u to√†n c·ª•c.
                </p>
            </div>
            
            <div class="example-box">
                <h4>üìã ·ª®ng D·ª•ng Th·ª±c T·∫ø</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    ‚Ä¢ <strong>Portfolio Optimization:</strong> T·ªëi ∆∞u h√≥a danh m·ª•c ƒë·∫ßu t∆∞ v·ªõi r√†ng bu·ªôc ng√¢n s√°ch v√† r·ªßi ro<br>
                    ‚Ä¢ <strong>Machine Learning:</strong> Support Vector Machines (SVM) v·ªõi r√†ng bu·ªôc margin<br>
                    ‚Ä¢ <strong>Engineering Design:</strong> Thi·∫øt k·∫ø t·ªëi ∆∞u v·ªõi r√†ng bu·ªôc v·ªÅ v·∫≠t li·ªáu v√† an to√†n<br>
                    ‚Ä¢ <strong>Resource Allocation:</strong> Ph√¢n b·ªï t√†i nguy√™n v·ªõi r√†ng bu·ªôc v·ªÅ dung l∆∞·ª£ng
                </p>
            </div>
        </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Tab Management
        let currentTab = 'interactive';
        
        function switchTab(tabName, event) {
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected tab and button
            document.getElementById(tabName + '-tab').classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find the button by tab name
                document.querySelector(`[onclick*="${tabName}"]`).classList.add('active');
            }
            
            currentTab = tabName;
            
            // Redraw canvas when switching to interactive tab
            if (tabName === 'interactive' && typeof draw === 'function') {
                setTimeout(() => draw(), 100);
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === '1') {
                event.preventDefault();
                switchTab('interactive');
                document.querySelector('[onclick="switchTab(\'interactive\')"]').click();
            } else if (event.ctrlKey && event.key === '2') {
                event.preventDefault();
                switchTab('theory');
                document.querySelector('[onclick="switchTab(\'theory\')"]').click();
            }
        });
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 80;
        
        // Current problem
        let currentProblem = 'equality';
        let analysisPoint = { x: 0, y: 0 };
        let multipliers = {};
        
        // Visualization options
        let showOptions = {
            objective: true,
            constraints: true,
            feasible: true,
            gradients: true,
            optimal: true,
            lagrangian: false
        };
        
        // Problem definitions with Vietnamese descriptions
        const problems = {
            equality: {
                name: 'T·ªëi ∆Øu H√≥a V·ªõi R√†ng Bu·ªôc ƒê·∫≥ng Th·ª©c',
                description: 'B√†i to√°n c∆° b·∫£n v·ªõi r√†ng bu·ªôc ƒë·∫≥ng th·ª©c tuy·∫øn t√≠nh. Ph∆∞∆°ng ph√°p nh√¢n t·ª≠ Lagrange c·ªï ƒëi·ªÉn.',
                objective: {
                    func: (x, y) => x*x + y*y,
                    grad: (x, y) => [2*x, 2*y],
                    formula: 'f(x,y) = x¬≤ + y¬≤',
                    vietnamese: 'T·ªëi thi·ªÉu h√≥a kho·∫£ng c√°ch t·ª´ g·ªëc t·ªça ƒë·ªô'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x + y - 2,
                        grad: (x, y) => [1, 1],
                        formula: 'g‚ÇÅ(x,y) = x + y - 2 = 0',
                        vietnamese: 'ƒêi·ªÉm ph·∫£i n·∫±m tr√™n ƒë∆∞·ªùng th·∫≥ng x + y = 2'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: { x: 1, y: 1 },
                optimalValue: 2,
                optimalMultipliers: { lambda1: -2 },
                explanation: 'T·∫°i ƒëi·ªÉm t·ªëi ∆∞u, gradient h√†m m·ª•c ti√™u song song v·ªõi gradient r√†ng bu·ªôc: ‚àáf = -Œª‚àág'
            },
            inequality: {
                name: 'T·ªëi ∆Øu H√≥a V·ªõi R√†ng Bu·ªôc B·∫•t ƒê·∫≥ng Th·ª©c',
                description: 'B√†i to√°n v·ªõi r√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c. Minh h·ªça ƒëi·ªÅu ki·ªán complementary slackness.',
                objective: {
                    func: (x, y) => -(x*x + y*y),
                    grad: (x, y) => [-2*x, -2*y],
                    formula: 'f(x,y) = -(x¬≤ + y¬≤)',
                    vietnamese: 'T·ªëi ƒëa h√≥a kho·∫£ng c√°ch t·ª´ g·ªëc t·ªça ƒë·ªô'
                },
                equalityConstraints: [],
                inequalityConstraints: [
                    {
                        func: (x, y) => x*x + y*y - 4,
                        grad: (x, y) => [2*x, 2*y],
                        formula: 'h‚ÇÅ(x,y) = x¬≤ + y¬≤ - 4 ‚â§ 0',
                        vietnamese: 'ƒêi·ªÉm ph·∫£i n·∫±m trong h√¨nh tr√≤n b√°n k√≠nh 2'
                    }
                ],
                optimalPoint: { x: 0, y: 0 },
                optimalValue: 0,
                optimalMultipliers: { mu1: 0 },
                explanation: 'ƒêi·ªÉm t·ªëi ∆∞u ·ªü n·ªôi t·∫°i v√πng kh·∫£ thi, r√†ng bu·ªôc kh√¥ng active (Œº = 0)'
            },
            mixed: {
                name: 'B√†i To√°n R√†ng Bu·ªôc H·ªón H·ª£p',
                description: 'K·∫øt h·ª£p c·∫£ r√†ng bu·ªôc ƒë·∫≥ng th·ª©c v√† b·∫•t ƒë·∫≥ng th·ª©c. R√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c active.',
                objective: {
                    func: (x, y) => x*x + (y - 1)*(y - 1),
                    grad: (x, y) => [2*x, 2*(y - 1)],
                    formula: 'f(x,y) = x¬≤ + (y-1)¬≤',
                    vietnamese: 'T·ªëi thi·ªÉu h√≥a kho·∫£ng c√°ch ƒë·∫øn ƒëi·ªÉm (0,1)'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x - 1,
                        grad: (x, y) => [1, 0],
                        formula: 'g‚ÇÅ(x,y) = x - 1 = 0',
                        vietnamese: 'x ph·∫£i b·∫±ng 1'
                    }
                ],
                inequalityConstraints: [
                    {
                        func: (x, y) => y,
                        grad: (x, y) => [0, 1],
                        formula: 'h‚ÇÅ(x,y) = y ‚â§ 0',
                        vietnamese: 'y kh√¥ng ƒë∆∞·ª£c d∆∞∆°ng'
                    }
                ],
                optimalPoint: { x: 1, y: 0 },
                optimalValue: 1,
                optimalMultipliers: { lambda1: 2, mu1: 2 },
                explanation: 'C·∫£ hai r√†ng bu·ªôc ƒë·ªÅu active. Œº > 0 v√¨ r√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c ƒë·∫°t gi·ªõi h·∫°n.'
            },
            quadratic: {
                name: 'Quy Ho·∫°ch B·∫≠c Hai (Quadratic Programming)',
                description: 'B√†i to√°n QP c∆° b·∫£n v·ªõi r√†ng bu·ªôc kh√¥ng √¢m. ·ª®ng d·ª•ng trong portfolio optimization.',
                objective: {
                    func: (x, y) => 0.5*(x*x + y*y) - x - 2*y,
                    grad: (x, y) => [x - 1, y - 2],
                    formula: 'f(x,y) = ¬Ω(x¬≤ + y¬≤) - x - 2y',
                    vietnamese: 'H√†m b·∫≠c hai v·ªõi h·ªá s·ªë tuy·∫øn t√≠nh'
                },
                equalityConstraints: [],
                inequalityConstraints: [
                    {
                        func: (x, y) => -x,
                        grad: (x, y) => [-1, 0],
                        formula: 'h‚ÇÅ(x,y) = -x ‚â§ 0',
                        vietnamese: 'x ‚â• 0'
                    },
                    {
                        func: (x, y) => -y,
                        grad: (x, y) => [0, -1],
                        formula: 'h‚ÇÇ(x,y) = -y ‚â§ 0',
                        vietnamese: 'y ‚â• 0'
                    }
                ],
                optimalPoint: { x: 1, y: 2 },
                optimalValue: -2.5,
                optimalMultipliers: { mu1: 0, mu2: 0 },
                explanation: 'ƒêi·ªÉm t·ªëi ∆∞u ·ªü n·ªôi t·∫°i t·ª© ph·∫ßn th·ª© nh·∫•t, kh√¥ng c√≥ r√†ng bu·ªôc n√†o active.'
            },
            nonconvex: {
                name: 'B√†i To√°n Kh√¥ng L·ªìi (Non-convex)',
                description: 'H√†m m·ª•c ti√™u kh√¥ng l·ªìi. KKT ch·ªâ cho ƒëi·ªÅu ki·ªán c·∫ßn, kh√¥ng ƒë·∫£m b·∫£o t·ªëi ∆∞u to√†n c·ª•c.',
                objective: {
                    func: (x, y) => x*x*x - 3*x + y*y,
                    grad: (x, y) => [3*x*x - 3, 2*y],
                    formula: 'f(x,y) = x¬≥ - 3x + y¬≤',
                    vietnamese: 'H√†m b·∫≠c ba kh√¥ng l·ªìi theo x'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x*x + y*y - 1,
                        grad: (x, y) => [2*x, 2*y],
                        formula: 'g‚ÇÅ(x,y) = x¬≤ + y¬≤ - 1 = 0',
                        vietnamese: 'ƒêi·ªÉm n·∫±m tr√™n ƒë∆∞·ªùng tr√≤n ƒë∆°n v·ªã'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: { x: -1, y: 0 },
                optimalValue: 2,
                optimalMultipliers: { lambda1: 3 },
                explanation: 'C√≥ nhi·ªÅu ƒëi·ªÉm th·ªèa m√£n KKT, c·∫ßn ki·ªÉm tra ƒëi·ªÅu ki·ªán b·∫≠c hai ƒë·ªÉ x√°c ƒë·ªãnh t·ªëi ∆∞u ƒë·ªãa ph∆∞∆°ng.'
            },
            infeasible: {
                name: 'B√†i To√°n Kh√¥ng Kh·∫£ Thi',
                description: 'C√°c r√†ng bu·ªôc m√¢u thu·∫´n nhau, kh√¥ng t·ªìn t·∫°i ƒëi·ªÉm kh·∫£ thi.',
                objective: {
                    func: (x, y) => x + y,
                    grad: (x, y) => [1, 1],
                    formula: 'f(x,y) = x + y',
                    vietnamese: 'H√†m tuy·∫øn t√≠nh ƒë∆°n gi·∫£n'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x + y - 1,
                        grad: (x, y) => [1, 1],
                        formula: 'g‚ÇÅ(x,y) = x + y - 1 = 0',
                        vietnamese: 'x + y = 1'
                    },
                    {
                        func: (x, y) => x + y - 2,
                        grad: (x, y) => [1, 1],
                        formula: 'g‚ÇÇ(x,y) = x + y - 2 = 0',
                        vietnamese: 'x + y = 2 (m√¢u thu·∫´n!)'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: null,
                optimalValue: null,
                optimalMultipliers: {},
                explanation: 'Kh√¥ng th·ªÉ ƒë·ªìng th·ªùi c√≥ x + y = 1 v√† x + y = 2. B√†i to√°n kh√¥ng c√≥ nghi·ªám.'
            }
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function selectProblem(problemName, event) {
            currentProblem = problemName;
            
            // Update active button
            document.querySelectorAll('.problem-button').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Find button by problem name and activate it
                const targetButton = document.querySelector(`button[onclick*="${problemName}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                }
            }
            
            // Reset multipliers
            multipliers = {};
            const problem = problems[currentProblem];
            
            // Initialize multipliers to zero
            problem.equalityConstraints.forEach((_, i) => {
                multipliers[`lambda${i+1}`] = 0;
            });
            problem.inequalityConstraints.forEach((_, i) => {
                multipliers[`mu${i+1}`] = 0;
            });
            
            updateProblemDisplay();
            updateMultiplierControls();
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function updateProblemDisplay() {
            const problem = problems[currentProblem];
            let html = `<strong>${problem.name}</strong><br/>`;
            html += `<em style="color: #aaa; font-size: 11px;">${problem.description}</em><br/><br/>`;
            
            html += `<strong style="color: #00FFFF;">T·ªëi thi·ªÉu h√≥a:</strong> ${problem.objective.formula}<br/>`;
            html += `<em style="color: #ccc; font-size: 11px;">${problem.objective.vietnamese}</em><br/><br/>`;
            
            if (problem.equalityConstraints.length > 0) {
                html += '<strong style="color: #e74c3c;">R√†ng bu·ªôc ƒë·∫≥ng th·ª©c:</strong><br/>';
                problem.equalityConstraints.forEach((constraint, i) => {
                    html += `${constraint.formula}<br/>`;
                    html += `<em style="color: #ccc; font-size: 11px;">${constraint.vietnamese}</em><br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.inequalityConstraints.length > 0) {
                html += '<strong style="color: #f39c12;">R√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c:</strong><br/>';
                problem.inequalityConstraints.forEach((constraint, i) => {
                    html += `${constraint.formula}<br/>`;
                    html += `<em style="color: #ccc; font-size: 11px;">${constraint.vietnamese}</em><br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.optimalPoint) {
                html += `<strong style="color: #9b59b6;">ƒêi·ªÉm t·ªëi ∆∞u:</strong> x* = (${problem.optimalPoint.x}, ${problem.optimalPoint.y})<br/>`;
                html += `<strong style="color: #2ecc71;">Gi√° tr·ªã t·ªëi ∆∞u:</strong> f* = ${problem.optimalValue}<br/>`;
            } else {
                html += '<strong style="color: #e74c3c;">‚ö†Ô∏è B√†i to√°n kh√¥ng kh·∫£ thi!</strong><br/>';
            }
            
            html += `<br/><em style="color: #FFD700; font-size: 11px;">üí° ${problem.explanation}</em>`;
            
            document.getElementById('problem-setup').innerHTML = html;
        }
        
        function updateMultiplierControls() {
            const problem = problems[currentProblem];
            const container = document.getElementById('multiplier-controls');
            container.innerHTML = '';
            
            // Add equality multipliers
            problem.equalityConstraints.forEach((_, i) => {
                const div = document.createElement('div');
                div.className = 'multiplier-input';
                div.innerHTML = `
                    <label>Œª${i+1}</label>
                    <input type="number" step="0.1" value="0" onchange="updateMultiplier('lambda${i+1}', this.value)">
                `;
                container.appendChild(div);
            });
            
            // Add inequality multipliers
            problem.inequalityConstraints.forEach((_, i) => {
                const div = document.createElement('div');
                div.className = 'multiplier-input';
                div.innerHTML = `
                    <label>Œº${i+1}</label>
                    <input type="number" step="0.1" value="0" min="0" onchange="updateMultiplier('mu${i+1}', this.value)">
                `;
                container.appendChild(div);
            });
        }
        
        function updateMultiplier(name, value) {
            multipliers[name] = parseFloat(value) || 0;
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function updateLagrangianDisplay() {
            const problem = problems[currentProblem];
            let lagrangian = problem.objective.formula;
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                const constraintTerm = constraint.formula.split(' = ')[0];
                lagrangian += ` + Œª${i+1}(${constraintTerm})`;
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const constraintTerm = constraint.formula.split(' ‚â§ ')[0];
                lagrangian += ` + Œº${i+1}(${constraintTerm})`;
            });
            
            let multiplierValues = '<br/><strong style="color: #00FFFF;">Gi√° tr·ªã hi·ªán t·∫°i:</strong><br/>';
            Object.keys(multipliers).forEach(key => {
                const value = multipliers[key] || 0;
                multiplierValues += `${key} = ${value.toFixed(3)}<br/>`;
            });
            
            // Calculate Lagrangian value at current analysis point
            const point = analysisPoint;
            let lagrangianValue = problem.objective.func(point.x, point.y);
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                lagrangianValue += lambda * constraint.func(point.x, point.y);
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                lagrangianValue += mu * constraint.func(point.x, point.y);
            });
            
            document.getElementById('lagrangian-display').innerHTML = `
                <strong>H√†m Lagrangian:</strong><br/>
                L(x,y,Œª,Œº) = ${lagrangian}
                ${multiplierValues}
                <br/><strong style="color: #2ecc71;">T·∫°i ƒëi·ªÉm hi·ªán t·∫°i:</strong> L = ${lagrangianValue.toFixed(3)}
            `;
        }
        
        function updateKKTConditions() {
            const problem = problems[currentProblem];
            const point = analysisPoint;
            let html = '<strong>ƒêi·ªÅu Ki·ªán KKT t·∫°i ƒëi·ªÉm hi·ªán t·∫°i:</strong><br/><br/>';
            
            // Stationarity condition
            const objGrad = problem.objective.grad(point.x, point.y);
            let gradLagrangian = [objGrad[0], objGrad[1]];
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                const constraintGrad = constraint.grad(point.x, point.y);
                gradLagrangian[0] += lambda * constraintGrad[0];
                gradLagrangian[1] += lambda * constraintGrad[1];
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const constraintGrad = constraint.grad(point.x, point.y);
                gradLagrangian[0] += mu * constraintGrad[0];
                gradLagrangian[1] += mu * constraintGrad[1];
            });
            
            const stationarityViolation = Math.sqrt(gradLagrangian[0]**2 + gradLagrangian[1]**2);
            html += `<div class="condition-status ${stationarityViolation < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
            html += `<strong>1. ƒêi·ªÅu ki·ªán Stationarity:</strong><br/>`;
            html += `‚àáL = (${gradLagrangian[0].toFixed(3)}, ${gradLagrangian[1].toFixed(3)}) ‚âà (0, 0)<br/>`;
            html += `||‚àáL|| = ${stationarityViolation.toFixed(3)} ${stationarityViolation < 0.1 ? '‚úì' : '‚úó'}`;
            html += `</div>`;
            
            // Primal feasibility for equality constraints
            problem.equalityConstraints.forEach((constraint, i) => {
                const value = constraint.func(point.x, point.y);
                html += `<div class="condition-status ${Math.abs(value) < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>2.${i+1} Kh·∫£ thi primal (ƒë·∫≥ng th·ª©c):</strong><br/>`;
                html += `g${i+1}(x) = ${value.toFixed(3)} = 0 ${Math.abs(value) < 0.1 ? '‚úì' : '‚úó'}`;
                html += `</div>`;
            });
            
            // Primal feasibility for inequality constraints
            problem.inequalityConstraints.forEach((constraint, i) => {
                const value = constraint.func(point.x, point.y);
                html += `<div class="condition-status ${value <= 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>3.${i+1} Kh·∫£ thi primal (b·∫•t ƒë·∫≥ng th·ª©c):</strong><br/>`;
                html += `h${i+1}(x) = ${value.toFixed(3)} ‚â§ 0 ${value <= 0.1 ? '‚úì' : '‚úó'}`;
                if (value <= 0.01) html += ` (active)`;
                html += `</div>`;
            });
            
            // Dual feasibility
            problem.inequalityConstraints.forEach((_, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                html += `<div class="condition-status ${mu >= -0.01 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>4.${i+1} Kh·∫£ thi dual:</strong><br/>`;
                html += `Œº${i+1} = ${mu.toFixed(3)} ‚â• 0 ${mu >= -0.01 ? '‚úì' : '‚úó'}`;
                html += `</div>`;
            });
            
            // Complementary slackness
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const h = constraint.func(point.x, point.y);
                const complementarySlackness = Math.abs(mu * h);
                html += `<div class="condition-status ${complementarySlackness < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>5.${i+1} Complementary Slackness:</strong><br/>`;
                html += `Œº${i+1}¬∑h${i+1} = ${mu.toFixed(3)} √ó ${h.toFixed(3)} = ${complementarySlackness.toFixed(3)} = 0<br/>`;
                html += `${complementarySlackness < 0.1 ? '‚úì' : '‚úó'}`;
                if (complementarySlackness < 0.1) {
                    if (Math.abs(mu) < 0.01) html += ` (Œº ‚âà 0, r√†ng bu·ªôc kh√¥ng active)`;
                    else if (Math.abs(h) < 0.01) html += ` (h ‚âà 0, r√†ng bu·ªôc active)`;
                }
                html += `</div>`;
            });
            
            // Overall assessment
            const allConditionsSatisfied = stationarityViolation < 0.1 &&
                problem.equalityConstraints.every(c => Math.abs(c.func(point.x, point.y)) < 0.1) &&
                problem.inequalityConstraints.every(c => c.func(point.x, point.y) <= 0.1) &&
                problem.inequalityConstraints.every((_, i) => (multipliers[`mu${i+1}`] || 0) >= -0.01) &&
                problem.inequalityConstraints.every((c, i) => {
                    const mu = multipliers[`mu${i+1}`] || 0;
                    const h = c.func(point.x, point.y);
                    return Math.abs(mu * h) < 0.1;
                });
            
            html += `<br/><div class="condition-status ${allConditionsSatisfied ? 'condition-satisfied' : 'condition-violated'}">`;
            html += `<strong>üéØ T·ªïng k·∫øt:</strong> ${allConditionsSatisfied ? 
                'T·∫•t c·∫£ ƒëi·ªÅu ki·ªán KKT ƒë∆∞·ª£c th·ªèa m√£n! ƒê√¢y c√≥ th·ªÉ l√† ƒëi·ªÉm t·ªëi ∆∞u.' : 
                'M·ªôt s·ªë ƒëi·ªÅu ki·ªán KKT b·ªã vi ph·∫°m. ƒêi·ªÅu ch·ªânh ƒëi·ªÉm ho·∫∑c nh√¢n t·ª≠.'}`;
            html += `</div>`;
            
            document.getElementById('kkt-conditions').innerHTML = html;
        }
        
        function updatePointAnalysis() {
            const problem = problems[currentProblem];
            const point = analysisPoint;
            
            let html = `<strong>Ph√¢n T√≠ch ƒêi·ªÉm: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})</strong><br/><br/>`;
            
            const objectiveValue = problem.objective.func(point.x, point.y);
            const objectiveGrad = problem.objective.grad(point.x, point.y);
            
            html += `<strong style="color: #00FFFF;">H√†m m·ª•c ti√™u:</strong><br/>`;
            html += `f(x,y) = ${objectiveValue.toFixed(3)}<br/>`;
            html += `‚àáf = (${objectiveGrad.map(g => g.toFixed(3)).join(', ')})<br/>`;
            html += `||‚àáf|| = ${Math.sqrt(objectiveGrad[0]**2 + objectiveGrad[1]**2).toFixed(3)}<br/><br/>`;
            
            if (problem.equalityConstraints.length > 0) {
                html += '<strong style="color: #e74c3c;">R√†ng bu·ªôc ƒë·∫≥ng th·ª©c:</strong><br/>';
                problem.equalityConstraints.forEach((constraint, i) => {
                    const value = constraint.func(point.x, point.y);
                    const grad = constraint.grad(point.x, point.y);
                    html += `g${i+1}(x,y) = ${value.toFixed(3)} ${Math.abs(value) < 0.1 ? '(th·ªèa m√£n)' : '(vi ph·∫°m)'}<br/>`;
                    html += `‚àág${i+1} = (${grad.map(g => g.toFixed(3)).join(', ')})<br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.inequalityConstraints.length > 0) {
                html += '<strong style="color: #f39c12;">R√†ng bu·ªôc b·∫•t ƒë·∫≥ng th·ª©c:</strong><br/>';
                problem.inequalityConstraints.forEach((constraint, i) => {
                    const value = constraint.func(point.x, point.y);
                    const grad = constraint.grad(point.x, point.y);
                    let status = '';
                    if (value <= -0.1) status = '(kh√¥ng active)';
                    else if (value <= 0.1) status = '(active/bi√™n)';
                    else status = '(vi ph·∫°m)';
                    
                    html += `h${i+1}(x,y) = ${value.toFixed(3)} ${status}<br/>`;
                    html += `‚àáh${i+1} = (${grad.map(g => g.toFixed(3)).join(', ')})<br/>`;
                });
                html += '<br/>';
            }
            
            // Check if point is feasible
            let feasible = true;
            problem.equalityConstraints.forEach(c => {
                if (Math.abs(c.func(point.x, point.y)) > 0.1) feasible = false;
            });
            problem.inequalityConstraints.forEach(c => {
                if (c.func(point.x, point.y) > 0.1) feasible = false;
            });
            
            html += `<strong>T√¨nh tr·∫°ng kh·∫£ thi:</strong> `;
            html += feasible ? 
                '<span style="color: #2ecc71;">‚úì Kh·∫£ thi</span>' : 
                '<span style="color: #e74c3c;">‚úó Kh√¥ng kh·∫£ thi</span>';
            
            // Distance to optimal point
            if (problem.optimalPoint) {
                const dx = point.x - problem.optimalPoint.x;
                const dy = point.y - problem.optimalPoint.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                html += `<br/><strong>Kho·∫£ng c√°ch ƒë·∫øn x*:</strong> ${distance.toFixed(3)}`;
                
                if (problem.optimalValue !== null) {
                    const optimalityGap = objectiveValue - problem.optimalValue;
                    html += `<br/><strong>Optimality gap:</strong> ${optimalityGap.toFixed(3)}`;
                }
            }
            
            document.getElementById('point-analysis').innerHTML = html;
        }
        
        function findOptimalMultipliers() {
            const problem = problems[currentProblem];
            const optimalMults = problem.optimalMultipliers;
            
            // Set optimal multipliers
            Object.keys(optimalMults).forEach(key => {
                multipliers[key] = optimalMults[key];
            });
            
            // Update input fields
            Object.keys(optimalMults).forEach(key => {
                const input = document.querySelector(`input[onchange*="${key}"]`);
                if (input) input.value = optimalMults[key];
            });
            
            // Set analysis point to optimal point
            if (problem.optimalPoint) {
                analysisPoint = { ...problem.optimalPoint };
                document.getElementById('analysisX').value = analysisPoint.x;
                document.getElementById('analysisY').value = analysisPoint.y;
                document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
                document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            }
            
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function resetMultipliers() {
            Object.keys(multipliers).forEach(key => {
                multipliers[key] = 0;
            });
            
            // Reset input fields
            document.querySelectorAll('#multiplier-controls input').forEach(input => {
                input.value = 0;
            });
            
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -10; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawObjectiveContours() {
            if (!showOptions.objective) return;
            
            const problem = problems[currentProblem];
            const step = 0.08;
            
            // Calculate value range for better contour selection
            let minVal = Infinity, maxVal = -Infinity;
            for (let x = -4; x <= 4; x += 0.5) {
                for (let y = -3; y <= 3; y += 0.5) {
                    const val = problem.objective.func(x, y);
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                }
            }
            
            // Draw contour lines with adaptive levels
            const numLevels = 12;
            for (let i = 0; i < numLevels; i++) {
                const level = minVal + (maxVal - minVal) * i / (numLevels - 1);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + 0.4 * (1 - Math.abs(i - numLevels/2) / (numLevels/2))})`;
                ctx.lineWidth = Math.abs(i - numLevels/2) < 2 ? 2 : 1;
                
                drawContourLine(problem.objective.func, level, step);
            }
            
            // Add contour labels
            if (problem.optimalPoint) {
                const optimalValue = problem.objective.func(problem.optimalPoint.x, problem.optimalPoint.y);
                ctx.fillStyle = '#00FFFF';
                ctx.font = '12px Arial';
                ctx.fillText(`f* = ${optimalValue.toFixed(2)}`, 
                    toCanvasX(problem.optimalPoint.x) + 15, 
                    toCanvasY(problem.optimalPoint.y) + 20);
            }
        }
        
        function drawContourLine(func, level, step) {
            ctx.beginPath();
            let hasPoints = false;
            
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    const value = func(x, y);
                    if (Math.abs(value - level) < step * 2) {
                        if (!hasPoints) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            hasPoints = true;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    }
                }
            }
            
            if (hasPoints) {
                ctx.stroke();
            }
        }
        
        function drawConstraints() {
            if (!showOptions.constraints) return;
            
            const problem = problems[currentProblem];
            
            // Draw equality constraints
            problem.equalityConstraints.forEach((constraint, i) => {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                drawConstraintCurve(constraint.func, 0);
                
                // Add constraint labels
                ctx.fillStyle = '#e74c3c';
                ctx.font = '14px Arial';
                // Find a point on the constraint for labeling
                for (let x = -3; x <= 3; x += 0.5) {
                    for (let y = -2; y <= 2; y += 0.5) {
                        if (Math.abs(constraint.func(x, y)) < 0.1) {
                            ctx.fillText(`g${i+1}=0`, toCanvasX(x) + 10, toCanvasY(y) - 10);
                            break;
                        }
                    }
                }
            });
            
            // Draw inequality constraints
            problem.inequalityConstraints.forEach((constraint, i) => {
                // Draw constraint boundary
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                drawConstraintCurve(constraint.func, 0);
                ctx.setLineDash([]);
                
                // Add constraint labels
                ctx.fillStyle = '#f39c12';
                ctx.font = '14px Arial';
                for (let x = -3; x <= 3; x += 0.5) {
                    for (let y = -2; y <= 2; y += 0.5) {
                        if (Math.abs(constraint.func(x, y)) < 0.1) {
                            ctx.fillText(`h${i+1}‚â§0`, toCanvasX(x) + 10, toCanvasY(y) - 10);
                            break;
                        }
                    }
                }
                
                // Shade infeasible region
                if (showOptions.feasible) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    const step = 0.15;
                    for (let x = -4; x <= 4; x += step) {
                        for (let y = -3; y <= 3; y += step) {
                            if (constraint.func(x, y) > 0.05) {
                                ctx.fillRect(toCanvasX(x) - 2, toCanvasY(y) - 2, 4, 4);
                            }
                        }
                    }
                }
            });
        }
        
        function drawConstraintCurve(constraintFunc, level) {
            const step = 0.04;
            ctx.beginPath();
            let hasPoints = false;
            
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    const value = constraintFunc(x, y);
                    if (Math.abs(value - level) < step * 2) {
                        if (!hasPoints) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            hasPoints = true;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    }
                }
            }
            
            if (hasPoints) {
                ctx.stroke();
            }
        }
        
        function drawFeasibleRegion() {
            if (!showOptions.feasible) return;
            
            const problem = problems[currentProblem];
            ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
            
            const step = 0.1;
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    let feasible = true;
                    
                    // Check equality constraints
                    problem.equalityConstraints.forEach(constraint => {
                        if (Math.abs(constraint.func(x, y)) > 0.1) {
                            feasible = false;
                        }
                    });
                    
                    // Check inequality constraints
                    problem.inequalityConstraints.forEach(constraint => {
                        if (constraint.func(x, y) > 0.01) {
                            feasible = false;
                        }
                    });
                    
                    if (feasible) {
                        ctx.fillRect(toCanvasX(x) - 1, toCanvasY(y) - 1, 2, 2);
                    }
                }
            }
        }
        
        function drawGradients() {
            if (!showOptions.gradients) return;
            
            const problem = problems[currentProblem];
            const point = analysisPoint;
            
            // Draw objective gradient
            const objGrad = problem.objective.grad(point.x, point.y);
            drawGradientVector(point, objGrad, '#0ff', '‚àáf');
            
            // Draw constraint gradients
            problem.equalityConstraints.forEach((constraint, i) => {
                const grad = constraint.grad(point.x, point.y);
                drawGradientVector(point, grad, '#e74c3c', `‚àág${i+1}`);
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const grad = constraint.grad(point.x, point.y);
                drawGradientVector(point, grad, '#f39c12', `‚àáh${i+1}`);
            });
        }
        
        function drawGradientVector(point, grad, color, label) {
            const magnitude = Math.sqrt(grad[0]**2 + grad[1]**2);
            if (magnitude < 1e-6) return;
            
            const scale_factor = 0.5;
            const endX = point.x + grad[0] * scale_factor;
            const endY = point.y + grad[1] * scale_factor;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Arrow body
            ctx.beginPath();
            ctx.moveTo(toCanvasX(point.x), toCanvasY(point.y));
            ctx.lineTo(toCanvasX(endX), toCanvasY(endY));
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(endY - point.y, endX - point.x);
            const headLength = 0.2;
            
            ctx.beginPath();
            ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
            ctx.lineTo(
                toCanvasX(endX - headLength * Math.cos(angle - Math.PI / 6)),
                toCanvasY(endY - headLength * Math.sin(angle - Math.PI / 6))
            );
            ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
            ctx.lineTo(
                toCanvasX(endX - headLength * Math.cos(angle + Math.PI / 6)),
                toCanvasY(endY - headLength * Math.sin(angle + Math.PI / 6))
            );
            ctx.stroke();
            
            // Label
            ctx.font = '12px Arial';
            ctx.fillText(label, toCanvasX(endX) + 5, toCanvasY(endY) - 5);
        }
        
        function drawOptimalPoint() {
            if (!showOptions.optimal) return;
            
            const problem = problems[currentProblem];
            if (!problem.optimalPoint) return;
            
            const optimal = problem.optimalPoint;
            
            ctx.fillStyle = '#9b59b6';
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimal.x), toCanvasY(optimal.y), 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimal.x), toCanvasY(optimal.y), 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#9b59b6';
            ctx.font = '14px Arial';
            ctx.fillText('x*', toCanvasX(optimal.x) + 15, toCanvasY(optimal.y) - 10);
        }
        
        function drawAnalysisPoint() {
            const point = analysisPoint;
            
            ctx.fillStyle = '#00ff00';
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(point.x), toCanvasY(point.y), 6, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(point.x), toCanvasY(point.y), 10, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            drawFeasibleRegion();
            drawObjectiveContours();
            drawConstraints();
            drawGradients();
            drawOptimalPoint();
            drawAnalysisPoint();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        // Event listeners
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            analysisPoint.x = fromCanvasX(canvasX);
            analysisPoint.y = fromCanvasY(canvasY);
            
            document.getElementById('analysisX').value = analysisPoint.x;
            document.getElementById('analysisY').value = analysisPoint.y;
            document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
            document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        document.getElementById('analysisX').addEventListener('input', function() {
            analysisPoint.x = parseFloat(this.value);
            document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        document.getElementById('analysisY').addEventListener('input', function() {
            analysisPoint.y = parseFloat(this.value);
            document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        // Utility functions
        function isFeasible(x, y) {
            const problem = problems[currentProblem];
            
            // Check equality constraints
            for (let constraint of problem.equalityConstraints) {
                if (Math.abs(constraint.func(x, y)) > 0.05) {
                    return false;
                }
            }
            
            // Check inequality constraints
            for (let constraint of problem.inequalityConstraints) {
                if (constraint.func(x, y) > 0.01) {
                    return false;
                }
            }
            
            return true;
        }
        
        function findKKTSolution() {
            const problem = problems[currentProblem];
            
            // Numerical optimization to find KKT solution
            let bestX = analysisPoint.x;
            let bestY = analysisPoint.y;
            let bestValue = problem.objective.func(bestX, bestY);
            
            // Gradient descent with constraint handling
            const maxIterations = 200;
            const tolerance = 1e-6;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const objGrad = problem.objective.grad(bestX, bestY);
                
                // Collect active constraints
                const activeConstraints = [];
                const constraintGrads = [];
                const constraintValues = [];
                
                // Equality constraints (always active)
                problem.equalityConstraints.forEach(constraint => {
                    activeConstraints.push(constraint);
                    constraintGrads.push(constraint.grad(bestX, bestY));
                    constraintValues.push(constraint.func(bestX, bestY));
                });
                
                // Active inequality constraints
                problem.inequalityConstraints.forEach(constraint => {
                    const value = constraint.func(bestX, bestY);
                    if (value > -0.01) { // Nearly active or violated
                        activeConstraints.push(constraint);
                        constraintGrads.push(constraint.grad(bestX, bestY));
                        constraintValues.push(value);
                    }
                });
                
                // Calculate step using projected gradient
                let stepX = -objGrad[0] * 0.01;
                let stepY = -objGrad[1] * 0.01;
                
                // Project violations back to feasible region
                constraintGrads.forEach((grad, i) => {
                    const violation = constraintValues[i];
                    const gradNorm = grad[0]*grad[0] + grad[1]*grad[1];
                    
                    if (gradNorm > tolerance && Math.abs(violation) > tolerance) {
                        const correction = violation / gradNorm;
                        stepX -= grad[0] * correction * 0.5;
                        stepY -= grad[1] * correction * 0.5;
                    }
                });
                
                // Apply step
                const newX = bestX + stepX;
                const newY = bestY + stepY;
                
                // Check convergence
                const stepSize = Math.sqrt(stepX*stepX + stepY*stepY);
                if (stepSize < tolerance) {
                    break;
                }
                
                bestX = Math.max(-3.5, Math.min(3.5, newX));
                bestY = Math.max(-2.5, Math.min(2.5, newY));
            }
            
            // Update analysis point to the found solution
            analysisPoint.x = bestX;
            analysisPoint.y = bestY;
            
            document.getElementById('analysisX').value = bestX;
            document.getElementById('analysisY').value = bestY;
            document.getElementById('analysisXValue').textContent = bestX.toFixed(3);
            document.getElementById('analysisYValue').textContent = bestY.toFixed(3);
            
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        // Add KKT solver button functionality
        function addKKTSolverButton() {
            const controlPanel = document.querySelector('.controls');
            if (!controlPanel) {
                console.error('Control panel not found');
                return;
            }
            
            const solverButton = document.createElement('button');
            solverButton.textContent = 'T√¨m Nghi·ªám KKT';
            solverButton.className = 'kkt-solver-button';
            solverButton.onclick = findKKTSolution;
            solverButton.style.cssText = `
                background: linear-gradient(145deg, #9b59b6, #8e44ad);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                margin: 10px 5px;
                transition: all 0.3s ease;
            `;
            solverButton.onmouseover = () => {
                solverButton.style.transform = 'translateY(-2px)';
                solverButton.style.boxShadow = '0 5px 15px rgba(155, 89, 182, 0.4)';
            };
            solverButton.onmouseout = () => {
                solverButton.style.transform = 'translateY(0)';
                solverButton.style.boxShadow = 'none';
            };
            
            controlPanel.appendChild(solverButton);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            selectProblem('equality');
            addKKTSolverButton();
            init3DVisualization();
        });
        
        // Fallback initialization if DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            // Document is still loading
        } else {
            // Document has finished loading
            selectProblem('equality');
            addKKTSolverButton();
            init3DVisualization();
        }
        
        // ===== 3D VISUALIZATION CODE =====
        let scene3D, camera3D, renderer3D, controls3D;
        let objectiveSurface, constraintSurfaces = [], optimalPoint3D;
        
        function init3DVisualization() {
            const container = document.getElementById('canvas3d');
            if (!container) return;
            
            // Scene setup
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x000000);
            
            // Camera setup
            camera3D = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3D.position.set(8, 8, 8);
            
            // Renderer setup
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(container.clientWidth, container.clientHeight);
            renderer3D.shadowMap.enabled = true;
            renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer3D.domElement);
            
            // Controls
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene3D.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene3D.add(directionalLight);
            
            // Create coordinate axes
            const axesHelper = new THREE.AxesHelper(5);
            scene3D.add(axesHelper);
            
            // Initial visualization
            update3DVisualization();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (container && renderer3D) {
                    camera3D.aspect = container.clientWidth / container.clientHeight;
                    camera3D.updateProjectionMatrix();
                    renderer3D.setSize(container.clientWidth, container.clientHeight);
                }
            });
            
            // Animation loop
            animate3D();
        }
        
        function update3DVisualization() {
            if (!scene3D) return;
            
            const problem = problems[currentProblem];
            const resolution = document.getElementById('resolution3D')?.value || 40;
            document.getElementById('resolutionValue').textContent = resolution;
            
            // Clear existing surfaces
            if (objectiveSurface) {
                scene3D.remove(objectiveSurface);
            }
            constraintSurfaces.forEach(surface => scene3D.remove(surface));
            constraintSurfaces = [];
            if (optimalPoint3D) {
                scene3D.remove(optimalPoint3D);
            }
            
            // Create objective surface
            if (document.getElementById('show3DSurface')?.checked) {
                createObjectiveSurface(problem, resolution);
            }
            
            // Create constraint surfaces
            if (document.getElementById('show3DConstraints')?.checked) {
                createConstraintSurfaces(problem, resolution);
            }
            
            // Create optimal point
            if (document.getElementById('show3DOptimal')?.checked && problem.optimalPoint) {
                createOptimalPoint3D(problem);
            }
        }
        
        function createObjectiveSurface(problem, resolution) {
            const geometry = new THREE.PlaneGeometry(6, 6, resolution, resolution);
            const vertices = geometry.attributes.position.array;
            
            // Calculate heights for objective function
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = problem.objective.func(x, y) * 0.5; // Scale Z for better visualization
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const wireframe = document.getElementById('show3DWireframe')?.checked;
            const material = wireframe 
                ? new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })
                : new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
            
            objectiveSurface = new THREE.Mesh(geometry, material);
            scene3D.add(objectiveSurface);
        }
        
        function createConstraintSurfaces(problem, resolution) {
            // Equality constraints (planes)
            problem.equalityConstraints.forEach((constraint, i) => {
                const geometry = new THREE.PlaneGeometry(6, 6, 20, 20);
                const vertices = geometry.attributes.position.array;
                
                // For linear constraints, create planes
                for (let j = 0; j < vertices.length; j += 3) {
                    const x = vertices[j];
                    const y = vertices[j + 1];
                    const constraintValue = constraint.func(x, y);
                    if (Math.abs(constraintValue) < 0.1) {
                        vertices[j + 2] = 0; // Keep on constraint surface
                    } else {
                        vertices[j + 2] = NaN; // Hide points not on constraint
                    }
                }
                
                geometry.attributes.position.needsUpdate = true;
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true, 
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                
                const constraintSurface = new THREE.Mesh(geometry, material);
                constraintSurfaces.push(constraintSurface);
                scene3D.add(constraintSurface);
            });
            
            // Inequality constraints (boundary surfaces)
            problem.inequalityConstraints.forEach((constraint, i) => {
                const geometry = new THREE.PlaneGeometry(6, 6, 30, 30);
                const vertices = geometry.attributes.position.array;
                
                for (let j = 0; j < vertices.length; j += 3) {
                    const x = vertices[j];
                    const y = vertices[j + 1];
                    const constraintValue = constraint.func(x, y);
                    if (Math.abs(constraintValue) < 0.1) {
                        vertices[j + 2] = 0;
                    } else {
                        vertices[j + 2] = NaN;
                    }
                }
                
                geometry.attributes.position.needsUpdate = true;
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const constraintSurface = new THREE.Mesh(geometry, material);
                constraintSurfaces.push(constraintSurface);
                scene3D.add(constraintSurface);
            });
        }
        
        function createOptimalPoint3D(problem) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            
            optimalPoint3D = new THREE.Mesh(geometry, material);
            optimalPoint3D.position.set(
                problem.optimalPoint.x,
                problem.optimalPoint.y,
                problem.objective.func(problem.optimalPoint.x, problem.optimalPoint.y) * 0.5
            );
            
            scene3D.add(optimalPoint3D);
        }
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            if (controls3D) {
                controls3D.update();
            }
            
            if (renderer3D && scene3D && camera3D) {
                renderer3D.render(scene3D, camera3D);
            }
        }
    </script>
</body>
</html>