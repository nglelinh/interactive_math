<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lagrangian & Điều Kiện KKT - Tối Ưu Hóa Có Ràng Buộc</title>
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mtml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            chtml: {
                displayAlign: 'left'
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Main App Container */
        .app-container {
            max-width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header with Title */
        .app-header {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 30px;
            border-bottom: 3px solid rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 100;
        }
        
        .app-title {
            font-size: 1.5em;
            color: #00FFFF;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
            font-weight: 600;
        }
        
        .app-subtitle {
            color: #cccccc;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            background: rgba(0, 0, 0, 0.8);
            padding: 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .tab-button {
            background: transparent;
            border: none;
            color: #cccccc;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
        }
        
        .tab-button.active {
            color: #00FFFF;
            background: rgba(0, 255, 255, 0.1);
            border-bottom-color: #00FFFF;
        }
        
        /* Tab Content Container */
        .tab-content-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .tab-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            overflow-y: auto;
        }
        
        .tab-content.active {
            opacity: 1;
            visibility: visible;
        }
        
        /* Interactive Tab Styles */
        .interactive-content {
            display: flex;
            height: 100%;
            min-height: calc(100vh - 120px);
            flex-direction: column;
        }
        
        .visualization-row {
            display: flex;
            flex: 1;
            margin-bottom: 20px;
        }
        
        .canvas-3d-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 400px;
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        .info-panel-3d {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 165, 0, 0.3);
            max-width: 280px;
        }
        
        .section-divider {
            margin: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
            text-align: center;
        }
        
        .section-divider h3 {
            color: #ff6b6b;
            margin: 0;
            font-size: 1.1em;
        }
        
        .header-section {
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .header-section h1 {
            margin: 0 0 12px 0;
            font-size: 1.8em;
            color: #00FFFF;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
            font-weight: 600;
        }
        
        .header-section p {
            margin: 6px 0;
            font-size: 1.05em;
            color: #e0e0e0;
            line-height: 1.5;
        }
        
        .mathematical-foundation {
            background: rgba(255, 215, 0, 0.1);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #FFD700;
            backdrop-filter: blur(10px);
        }
        
        .foundation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }
        
        .foundation-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00FFFF;
        }
        
        .foundation-item h4 {
            color: #00FFFF;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        canvas {
            background: #000;
            border: none;
            width: 100%;
            height: auto;
            max-height: calc(100vh - 200px);
        }
        
        .info-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            max-width: 300px;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            margin: 4px 0;
            color: #cccccc;
        }
        
        .controls {
            width: 420px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            backdrop-filter: blur(15px);
            max-height: calc(100vh - 120px);
        }
        
        /* Theory Tab Styles */
        .theory-content {
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
            overflow-y: auto;
        }
        
        .theory-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .theory-header h1 {
            font-size: 2.2em;
            color: #00FFFF;
            margin-bottom: 15px;
            text-shadow: 2px 2px 6px rgba(0, 255, 255, 0.3);
        }
        
        .theory-header p {
            font-size: 1.1em;
            color: #e0e0e0;
            margin: 8px 0;
        }
        
        .mathematical-foundation {
            background: rgba(255, 215, 0, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #FFD700;
            backdrop-filter: blur(10px);
        }
        
        .foundation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        
        .foundation-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #00FFFF;
            transition: transform 0.3s ease;
        }
        
        .foundation-item:hover {
            transform: translateY(-5px);
        }
        
        .foundation-item h4 {
            color: #00FFFF;
            margin: 0 0 12px 0;
            font-size: 1.2em;
        }
        
        .theory-box {
            background: rgba(52, 152, 219, 0.12);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #3498db;
            backdrop-filter: blur(10px);
        }
        
        .theory-box h4 {
            color: #3498db;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .example-box {
            background: rgba(155, 89, 182, 0.12);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 5px solid #9b59b6;
            backdrop-filter: blur(10px);
        }
        
        .example-box h4 {
            color: #9b59b6;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .controls {
            width: 480px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-left: 1px solid #444;
            overflow-y: auto;
            backdrop-filter: blur(15px);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        .control-section {
            margin-bottom: 25px;
            padding: 18px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .control-section:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .control-section h3 {
            margin: 0 0 18px 0;
            color: #00FFFF;
            font-size: 1.1em;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.3);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 8px;
        }
        
        .problem-setup {
            background: rgba(0, 255, 255, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 18px;
            border-left: 4px solid #00FFFF;
            backdrop-filter: blur(5px);
        }
        
        .kkt-conditions {
            background: rgba(255, 255, 0, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 18px;
            border-left: 4px solid #FFD700;
            max-height: 280px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        
        .lagrangian-display {
            background: rgba(255, 0, 255, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 18px;
            border-left: 4px solid #FF69B4;
            backdrop-filter: blur(5px);
        }
        
        .toggle-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 18px;
        }
        
        .toggle-button {
            padding: 10px 8px;
            background: linear-gradient(145deg, #333, #2a2a2a);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .toggle-button:hover {
            background: linear-gradient(145deg, #444, #333);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .toggle-button.active {
            background: linear-gradient(145deg, #00FFFF, #0099CC);
            color: #000;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        
        .info-panel {
            position: relative;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.92);
            padding: 18px;
            border-radius: 12px;
            font-size: 13px;
            max-width: 420px;
            z-index: 10;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        .info-panel strong {
            color: #00FFFF;
            font-size: 1.1em;
            text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.3);
        }
        
        .legend {
            font-size: 12px;
            margin-top: 12px;
            line-height: 1.6;
        }
        
        .legend-item {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-item::before {
            content: "";
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-item:nth-child(1)::before { background: #00FFFF; }
        .legend-item:nth-child(2)::before { background: #e74c3c; }
        .legend-item:nth-child(3)::before { background: #f39c12; }
        .legend-item:nth-child(4)::before { background: #2ecc71; }
        .legend-item:nth-child(5)::before { background: #9b59b6; }
        .legend-item:nth-child(6)::before { background: #e67e22; }
        
        .slider-group {
            margin: 12px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #ccc;
            font-weight: 500;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, #00FFFF, #0099CC);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .slider-value {
            font-size: 12px;
            color: #00FFFF;
            text-align: right;
            margin-top: 5px;
            font-weight: 600;
        }
        
        .problem-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 18px;
        }
        
        .problem-button {
            padding: 12px 8px;
            background: linear-gradient(145deg, #333, #2a2a2a);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .problem-button:hover {
            background: linear-gradient(145deg, #444, #333);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .problem-button.active {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #000;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
        }
        
        .multiplier-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-bottom: 18px;
        }
        
        .multiplier-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .multiplier-input label {
            font-size: 13px;
            margin-bottom: 8px;
            color: #00FFFF;
            font-weight: 600;
        }
        
        .multiplier-input input {
            width: 80px;
            padding: 6px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .multiplier-input input:focus {
            outline: none;
            border-color: #00FFFF;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .point-analysis {
            background: rgba(0, 255, 0, 0.12);
            padding: 16px;
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: 18px;
            border-left: 4px solid #2ecc71;
            backdrop-filter: blur(5px);
        }
        
        .condition-status {
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            border-left: 3px solid;
            transition: all 0.3s ease;
        }
        
        .condition-satisfied {
            background: rgba(46, 204, 113, 0.25);
            color: #2ecc71;
            border-left-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.2);
        }
        
        .condition-violated {
            background: rgba(231, 76, 60, 0.25);
            color: #e74c3c;
            border-left-color: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.2);
        }
        
        .theory-box {
            background: rgba(52, 152, 219, 0.12);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
            backdrop-filter: blur(10px);
        }
        
        .theory-box h4 {
            color: #3498db;
            margin: 0 0 12px 0;
            font-size: 1.1em;
        }
        
        .example-box {
            background: rgba(155, 89, 182, 0.12);
            padding: 18px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #9b59b6;
            backdrop-filter: blur(10px);
        }
        
        .example-box h4 {
            color: #9b59b6;
            margin: 0 0 12px 0;
            font-size: 1.1em;
        }
    </style>

</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <h1 class="app-title">⚖️ Lagrangian & Điều Kiện KKT</h1>
            <p class="app-subtitle">Tối ưu hóa có ràng buộc - Interactive Learning</p>
        </header>
        
        <!-- Tab Navigation -->
        <nav class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('interactive', event)">
                🎯 Trực Quan Tương Tác
            </button>
            <button class="tab-button" onclick="switchTab('theory', event)">
                📐 Nền Tảng Toán Học
            </button>
        </nav>
        
        <!-- Tab Content Container -->
        <main class="tab-content-container">
            <!-- Interactive Tab -->
            <div id="interactive-tab" class="tab-content active">
                <div class="interactive-content">
                    <!-- 2D Visualization Row -->
                    <div class="visualization-row">
                        <div class="canvas-container">
                            <canvas id="canvas" width="800" height="600"></canvas>
                            <div class="info-panel">
                                <strong>⚖️ 2D Lagrangian Visualization</strong><br/>
                                Khám phá tương tác giữa hàm mục tiêu, ràng buộc và nhân tử Lagrange.
                                <div class="legend">
                                    <div class="legend-item">🔵 Đường mức hàm mục tiêu f(x,y)</div>
                                    <div class="legend-item">🔴 Ràng buộc đẳng thức g(x,y) = 0</div>
                                    <div class="legend-item">🟡 Ràng buộc bất đẳng thức h(x,y) ≤ 0</div>
                                    <div class="legend-item">🟢 Vùng khả thi</div>
                                    <div class="legend-item">🟣 Điểm tối ưu x*</div>
                                    <div class="legend-item">➡️ Vector gradient</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="controls">
                            <div class="control-section">
                                <h3>🎯 Chọn Bài Toán</h3>
                                <div class="problem-selector">
                                    <button class="problem-button active" onclick="selectProblem('equality', event)">Ràng Buộc Đẳng Thức</button>
                                    <button class="problem-button" onclick="selectProblem('inequality', event)">Ràng Buộc Bất Đẳng Thức</button>
                                    <button class="problem-button" onclick="selectProblem('mixed', event)">Ràng Buộc Hỗn Hợp</button>
                                    <button class="problem-button" onclick="selectProblem('quadratic', event)">Quy Hoạch Bậc 2</button>
                                    <button class="problem-button" onclick="selectProblem('nonconvex', event)">Không Lồi</button>
                                    <button class="problem-button" onclick="selectProblem('infeasible', event)">Không Khả Thi</button>
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>📋 Bài Toán Hiện Tại</h3>
                                <div id="problem-setup" class="problem-setup">
                                    <!-- Problem formulation will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>📚 Hàm Lagrangian</h3>
                                <div id="lagrangian-display" class="lagrangian-display">
                                    <!-- Lagrangian will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>⚖️ Điều Kiện KKT</h3>
                                <div id="kkt-conditions" class="kkt-conditions">
                                    <!-- KKT conditions will be displayed here -->
                                </div>
                            </div>
                            
                            <div class="control-section">
                                <h3>🎨 Tùy Chọn Hiển Thị</h3>
                                <div class="toggle-section">
                                    <div class="toggle-button active" id="toggle-objective" onclick="toggleVisualization('objective')">
                                        Đường Mức f(x,y)
                                    </div>
                                    <div class="toggle-button active" id="toggle-constraints" onclick="toggleVisualization('constraints')">
                                        Đường Ràng Buộc
                                    </div>
                                    <div class="toggle-button active" id="toggle-feasible" onclick="toggleVisualization('feasible')">
                                        Vùng Khả Thi
                                    </div>
                                    <div class="toggle-button active" id="toggle-gradients" onclick="toggleVisualization('gradients')">
                                        Vector Gradient
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Section Divider -->
                    <div class="section-divider">
                        <h3>🔄 3D Surface Visualization - Khám phá bề mặt tối ưu hóa trong không gian 3D</h3>
                    </div>
                    
                    <!-- 3D Visualization Row -->
                    <div class="visualization-row">
                        <div class="canvas-3d-container">
                            <div id="canvas3d"></div>
                            <div class="info-panel-3d">
                                <strong>🌐 3D Lagrangian Surface</strong><br/>
                                Bề mặt hàm mục tiêu và ràng buộc trong không gian 3D
                                <div class="legend">
                                    <div class="legend-item">🌊 Bề mặt hàm mục tiêu f(x,y)</div>
                                    <div class="legend-item">🔴 Mặt phẳng ràng buộc</div>
                                    <div class="legend-item">🟣 Điểm tối ưu</div>
                                    <div class="legend-item">🎮 Kéo để xoay, cuộn để zoom</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 3D Controls -->
                        <div class="controls">
                            <div class="control-section">
                                <h3>🌐 Điều Khiển 3D</h3>
                                <div class="toggle-section">
                                    <label>
                                        <input type="checkbox" id="show3DSurface" checked onchange="update3DVisualization()">
                                        Hiển thị bề mặt hàm mục tiêu
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DConstraints" checked onchange="update3DVisualization()">
                                        Hiển thị ràng buộc
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DOptimal" checked onchange="update3DVisualization()">
                                        Hiển thị điểm tối ưu
                                    </label><br>
                                    <label>
                                        <input type="checkbox" id="show3DWireframe" onchange="update3DVisualization()">
                                        Wireframe mode
                                    </label>
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>Độ phân giải:</label>
                                    <input type="range" id="resolution3D" min="20" max="80" value="40" onchange="update3DVisualization()">
                                    <span id="resolutionValue">40</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>📋 Bài Toán Hiện Tại</h3>
                <div id="problem-setup" class="problem-setup">
                    <!-- Problem formulation will be displayed here -->
                </div>
            </div>
            
            <div class="control-section">
                <h3>📚 Hàm Lagrangian</h3>
                <div id="lagrangian-display" class="lagrangian-display">
                    <!-- Lagrangian will be displayed here -->
                </div>
                <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; font-size: 11px; margin-top: 10px;">
                    <strong>💡 Ghi Chú:</strong> Hàm Lagrangian kết hợp hàm mục tiêu với các ràng buộc thông qua nhân tử Lagrange.
                    Việc tối ưu hóa Lagrangian cho phép xử lý ràng buộc một cách tự nhiên.
                </div>
            </div>
                    </div>
                </div>
            </div>
            
            <!-- Theory Tab -->
            <div id="theory-tab" class="tab-content">
                <div class="theory-content">
                    <div class="theory-header">
                        <h1>⚖️ Lagrangian & Điều Kiện KKT - Tối Ưu Hóa Có Ràng Buộc</h1>
                        <p><strong>🎯 Mục Tiêu:</strong> Khám phá phương pháp Lagrange và điều kiện Karush-Kuhn-Tucker (KKT) trong tối ưu hóa có ràng buộc</p>
                        <p><strong>💡 Ý Nghĩa:</strong> Tìm điểm tối ưu khi có các ràng buộc đẳng thức và bất đẳng thức</p>
                    </div>
                    
                    <div class="mathematical-foundation">
                        <h3 style="color: #FFD700; margin: 0 0 15px 0; font-size: 1.2em;">📐 Nền Tảng Toán Học</h3>
                        
                        <div class="foundation-grid">
                            <div class="foundation-item">
                                <h4>🔍 Bài Toán Tổng Quát</h4>
                                <p style="font-size: 0.9em; margin: 5px 0;">
                                    $$\min_{x} f(x)$$
                                    $$\text{s.t. } g_i(x) = 0, \quad i = 1,\ldots,m$$
                                    $$h_j(x) \leq 0, \quad j = 1,\ldots,p$$
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>📚 Hàm Lagrangian</h4>
                                <p style="font-size: 0.9em; margin: 5px 0;">
                                    $$L(x,\lambda,\mu) = f(x) + \sum_{i=1}^m \lambda_i g_i(x) + \sum_{j=1}^p \mu_j h_j(x)$$
                                    <br><strong>λ:</strong> nhân tử Lagrange cho ràng buộc đẳng thức
                                    <br><strong>μ:</strong> nhân tử KKT cho ràng buộc bất đẳng thức
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>⚡ Điều Kiện KKT</h4>
                                <p style="font-size: 0.85em; margin: 5px 0;">
                                    1. <strong>Stationarity:</strong> $\nabla_x L = 0$<br>
                                    2. <strong>Primal feasibility:</strong> $g_i(x) = 0$, $h_j(x) \leq 0$<br>
                                    3. <strong>Dual feasibility:</strong> $\mu_j \geq 0$<br>
                                    4. <strong>Complementary slackness:</strong> $\mu_j h_j(x) = 0$
                                </p>
                            </div>
                            
                            <div class="foundation-item">
                                <h4>🎯 Ý Nghĩa Hình Học</h4>
                                <p style="font-size: 0.85em; margin: 5px 0;">
                                    Tại điểm tối ưu, gradient của hàm mục tiêu là tổ hợp tuyến tính của gradient các ràng buộc active:
                                    $$\nabla f(x^*) = -\sum_i \lambda_i^* \nabla g_i(x^*) - \sum_j \mu_j^* \nabla h_j(x^*)$$
                                </p>
                            </div>
                        </div>
                        
                        <div class="theory-box">
                            <h4>🧮 Định Lý Cơ Bản</h4>
                            <p style="font-size: 0.9em; line-height: 1.6;">
                                <strong>Điều kiện cần:</strong> Nếu $x^*$ là điểm tối ưu địa phương và LICQ (Linear Independence Constraint Qualification) thỏa mãn, 
                                thì tồn tại $(\lambda^*, \mu^*)$ sao cho điều kiện KKT được thỏa mãn.<br><br>
                                
                                <strong>Điều kiện đủ:</strong> Nếu hàm mục tiêu và ràng buộc bất đẳng thức là convex, ràng buộc đẳng thức là affine, 
                                và điều kiện KKT thỏa mãn tại $(x^*, \lambda^*, \mu^*)$, thì $x^*$ là điểm tối ưu toàn cục.
                            </p>
                        </div>
                        
                        <div class="example-box">
                            <h4>📋 Ứng Dụng Thực Tế</h4>
                            <p style="font-size: 0.9em; line-height: 1.6;">
                                • <strong>Portfolio Optimization:</strong> Tối ưu hóa danh mục đầu tư với ràng buộc ngân sách và rủi ro<br>
                                • <strong>Machine Learning:</strong> Support Vector Machines (SVM) với ràng buộc margin<br>
                                • <strong>Engineering Design:</strong> Thiết kế tối ưu với ràng buộc về vật liệu và an toàn<br>
                                • <strong>Resource Allocation:</strong> Phân bổ tài nguyên với ràng buộc về dung lượng
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
            
            <div class="theory-box">
                <h4>🧮 Định Lý Cơ Bản</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    <strong>Điều kiện cần:</strong> Nếu $x^*$ là điểm tối ưu địa phương và LICQ (Linear Independence Constraint Qualification) thỏa mãn, 
                    thì tồn tại $(\lambda^*, \mu^*)$ sao cho điều kiện KKT được thỏa mãn.<br><br>
                    
                    <strong>Điều kiện đủ:</strong> Nếu hàm mục tiêu và ràng buộc bất đẳng thức là convex, ràng buộc đẳng thức là affine, 
                    và điều kiện KKT thỏa mãn tại $(x^*, \lambda^*, \mu^*)$, thì $x^*$ là điểm tối ưu toàn cục.
                </p>
            </div>
            
            <div class="example-box">
                <h4>📋 Ứng Dụng Thực Tế</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    • <strong>Portfolio Optimization:</strong> Tối ưu hóa danh mục đầu tư với ràng buộc ngân sách và rủi ro<br>
                    • <strong>Machine Learning:</strong> Support Vector Machines (SVM) với ràng buộc margin<br>
                    • <strong>Engineering Design:</strong> Thiết kế tối ưu với ràng buộc về vật liệu và an toàn<br>
                    • <strong>Resource Allocation:</strong> Phân bổ tài nguyên với ràng buộc về dung lượng
                </p>
            </div>
        </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Tab Management
        let currentTab = 'interactive';
        
        function switchTab(tabName, event) {
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected tab and button
            document.getElementById(tabName + '-tab').classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find the button by tab name
                document.querySelector(`[onclick*="${tabName}"]`).classList.add('active');
            }
            
            currentTab = tabName;
            
            // Redraw canvas when switching to interactive tab
            if (tabName === 'interactive' && typeof draw === 'function') {
                setTimeout(() => draw(), 100);
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === '1') {
                event.preventDefault();
                switchTab('interactive');
                document.querySelector('[onclick="switchTab(\'interactive\')"]').click();
            } else if (event.ctrlKey && event.key === '2') {
                event.preventDefault();
                switchTab('theory');
                document.querySelector('[onclick="switchTab(\'theory\')"]').click();
            }
        });
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 80;
        
        // Current problem
        let currentProblem = 'equality';
        let analysisPoint = { x: 0, y: 0 };
        let multipliers = {};
        
        // Visualization options
        let showOptions = {
            objective: true,
            constraints: true,
            feasible: true,
            gradients: true,
            optimal: true,
            lagrangian: false
        };
        
        // Problem definitions with Vietnamese descriptions
        const problems = {
            equality: {
                name: 'Tối Ưu Hóa Với Ràng Buộc Đẳng Thức',
                description: 'Bài toán cơ bản với ràng buộc đẳng thức tuyến tính. Phương pháp nhân tử Lagrange cổ điển.',
                objective: {
                    func: (x, y) => x*x + y*y,
                    grad: (x, y) => [2*x, 2*y],
                    formula: 'f(x,y) = x² + y²',
                    vietnamese: 'Tối thiểu hóa khoảng cách từ gốc tọa độ'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x + y - 2,
                        grad: (x, y) => [1, 1],
                        formula: 'g₁(x,y) = x + y - 2 = 0',
                        vietnamese: 'Điểm phải nằm trên đường thẳng x + y = 2'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: { x: 1, y: 1 },
                optimalValue: 2,
                optimalMultipliers: { lambda1: -2 },
                explanation: 'Tại điểm tối ưu, gradient hàm mục tiêu song song với gradient ràng buộc: ∇f = -λ∇g'
            },
            inequality: {
                name: 'Tối Ưu Hóa Với Ràng Buộc Bất Đẳng Thức',
                description: 'Bài toán với ràng buộc bất đẳng thức. Minh họa điều kiện complementary slackness.',
                objective: {
                    func: (x, y) => -(x*x + y*y),
                    grad: (x, y) => [-2*x, -2*y],
                    formula: 'f(x,y) = -(x² + y²)',
                    vietnamese: 'Tối đa hóa khoảng cách từ gốc tọa độ'
                },
                equalityConstraints: [],
                inequalityConstraints: [
                    {
                        func: (x, y) => x*x + y*y - 4,
                        grad: (x, y) => [2*x, 2*y],
                        formula: 'h₁(x,y) = x² + y² - 4 ≤ 0',
                        vietnamese: 'Điểm phải nằm trong hình tròn bán kính 2'
                    }
                ],
                optimalPoint: { x: 0, y: 0 },
                optimalValue: 0,
                optimalMultipliers: { mu1: 0 },
                explanation: 'Điểm tối ưu ở nội tại vùng khả thi, ràng buộc không active (μ = 0)'
            },
            mixed: {
                name: 'Bài Toán Ràng Buộc Hỗn Hợp',
                description: 'Kết hợp cả ràng buộc đẳng thức và bất đẳng thức. Ràng buộc bất đẳng thức active.',
                objective: {
                    func: (x, y) => x*x + (y - 1)*(y - 1),
                    grad: (x, y) => [2*x, 2*(y - 1)],
                    formula: 'f(x,y) = x² + (y-1)²',
                    vietnamese: 'Tối thiểu hóa khoảng cách đến điểm (0,1)'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x - 1,
                        grad: (x, y) => [1, 0],
                        formula: 'g₁(x,y) = x - 1 = 0',
                        vietnamese: 'x phải bằng 1'
                    }
                ],
                inequalityConstraints: [
                    {
                        func: (x, y) => y,
                        grad: (x, y) => [0, 1],
                        formula: 'h₁(x,y) = y ≤ 0',
                        vietnamese: 'y không được dương'
                    }
                ],
                optimalPoint: { x: 1, y: 0 },
                optimalValue: 1,
                optimalMultipliers: { lambda1: 2, mu1: 2 },
                explanation: 'Cả hai ràng buộc đều active. μ > 0 vì ràng buộc bất đẳng thức đạt giới hạn.'
            },
            quadratic: {
                name: 'Quy Hoạch Bậc Hai (Quadratic Programming)',
                description: 'Bài toán QP cơ bản với ràng buộc không âm. Ứng dụng trong portfolio optimization.',
                objective: {
                    func: (x, y) => 0.5*(x*x + y*y) - x - 2*y,
                    grad: (x, y) => [x - 1, y - 2],
                    formula: 'f(x,y) = ½(x² + y²) - x - 2y',
                    vietnamese: 'Hàm bậc hai với hệ số tuyến tính'
                },
                equalityConstraints: [],
                inequalityConstraints: [
                    {
                        func: (x, y) => -x,
                        grad: (x, y) => [-1, 0],
                        formula: 'h₁(x,y) = -x ≤ 0',
                        vietnamese: 'x ≥ 0'
                    },
                    {
                        func: (x, y) => -y,
                        grad: (x, y) => [0, -1],
                        formula: 'h₂(x,y) = -y ≤ 0',
                        vietnamese: 'y ≥ 0'
                    }
                ],
                optimalPoint: { x: 1, y: 2 },
                optimalValue: -2.5,
                optimalMultipliers: { mu1: 0, mu2: 0 },
                explanation: 'Điểm tối ưu ở nội tại tứ phần thứ nhất, không có ràng buộc nào active.'
            },
            nonconvex: {
                name: 'Bài Toán Không Lồi (Non-convex)',
                description: 'Hàm mục tiêu không lồi. KKT chỉ cho điều kiện cần, không đảm bảo tối ưu toàn cục.',
                objective: {
                    func: (x, y) => x*x*x - 3*x + y*y,
                    grad: (x, y) => [3*x*x - 3, 2*y],
                    formula: 'f(x,y) = x³ - 3x + y²',
                    vietnamese: 'Hàm bậc ba không lồi theo x'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x*x + y*y - 1,
                        grad: (x, y) => [2*x, 2*y],
                        formula: 'g₁(x,y) = x² + y² - 1 = 0',
                        vietnamese: 'Điểm nằm trên đường tròn đơn vị'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: { x: -1, y: 0 },
                optimalValue: 2,
                optimalMultipliers: { lambda1: 3 },
                explanation: 'Có nhiều điểm thỏa mãn KKT, cần kiểm tra điều kiện bậc hai để xác định tối ưu địa phương.'
            },
            infeasible: {
                name: 'Bài Toán Không Khả Thi',
                description: 'Các ràng buộc mâu thuẫn nhau, không tồn tại điểm khả thi.',
                objective: {
                    func: (x, y) => x + y,
                    grad: (x, y) => [1, 1],
                    formula: 'f(x,y) = x + y',
                    vietnamese: 'Hàm tuyến tính đơn giản'
                },
                equalityConstraints: [
                    {
                        func: (x, y) => x + y - 1,
                        grad: (x, y) => [1, 1],
                        formula: 'g₁(x,y) = x + y - 1 = 0',
                        vietnamese: 'x + y = 1'
                    },
                    {
                        func: (x, y) => x + y - 2,
                        grad: (x, y) => [1, 1],
                        formula: 'g₂(x,y) = x + y - 2 = 0',
                        vietnamese: 'x + y = 2 (mâu thuẫn!)'
                    }
                ],
                inequalityConstraints: [],
                optimalPoint: null,
                optimalValue: null,
                optimalMultipliers: {},
                explanation: 'Không thể đồng thời có x + y = 1 và x + y = 2. Bài toán không có nghiệm.'
            }
        };
        
        function toCanvasX(x) {
            return centerX + x * scale;
        }
        
        function toCanvasY(y) {
            return centerY - y * scale;
        }
        
        function fromCanvasX(canvasX) {
            return (canvasX - centerX) / scale;
        }
        
        function fromCanvasY(canvasY) {
            return (centerY - canvasY) / scale;
        }
        
        function selectProblem(problemName, event) {
            currentProblem = problemName;
            
            // Update active button
            document.querySelectorAll('.problem-button').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Find button by problem name and activate it
                const targetButton = document.querySelector(`button[onclick*="${problemName}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                }
            }
            
            // Reset multipliers
            multipliers = {};
            const problem = problems[currentProblem];
            
            // Initialize multipliers to zero
            problem.equalityConstraints.forEach((_, i) => {
                multipliers[`lambda${i+1}`] = 0;
            });
            problem.inequalityConstraints.forEach((_, i) => {
                multipliers[`mu${i+1}`] = 0;
            });
            
            updateProblemDisplay();
            updateMultiplierControls();
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function updateProblemDisplay() {
            const problem = problems[currentProblem];
            let html = `<strong>${problem.name}</strong><br/>`;
            html += `<em style="color: #aaa; font-size: 11px;">${problem.description}</em><br/><br/>`;
            
            html += `<strong style="color: #00FFFF;">Tối thiểu hóa:</strong> ${problem.objective.formula}<br/>`;
            html += `<em style="color: #ccc; font-size: 11px;">${problem.objective.vietnamese}</em><br/><br/>`;
            
            if (problem.equalityConstraints.length > 0) {
                html += '<strong style="color: #e74c3c;">Ràng buộc đẳng thức:</strong><br/>';
                problem.equalityConstraints.forEach((constraint, i) => {
                    html += `${constraint.formula}<br/>`;
                    html += `<em style="color: #ccc; font-size: 11px;">${constraint.vietnamese}</em><br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.inequalityConstraints.length > 0) {
                html += '<strong style="color: #f39c12;">Ràng buộc bất đẳng thức:</strong><br/>';
                problem.inequalityConstraints.forEach((constraint, i) => {
                    html += `${constraint.formula}<br/>`;
                    html += `<em style="color: #ccc; font-size: 11px;">${constraint.vietnamese}</em><br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.optimalPoint) {
                html += `<strong style="color: #9b59b6;">Điểm tối ưu:</strong> x* = (${problem.optimalPoint.x}, ${problem.optimalPoint.y})<br/>`;
                html += `<strong style="color: #2ecc71;">Giá trị tối ưu:</strong> f* = ${problem.optimalValue}<br/>`;
            } else {
                html += '<strong style="color: #e74c3c;">⚠️ Bài toán không khả thi!</strong><br/>';
            }
            
            html += `<br/><em style="color: #FFD700; font-size: 11px;">💡 ${problem.explanation}</em>`;
            
            document.getElementById('problem-setup').innerHTML = html;
        }
        
        function updateMultiplierControls() {
            const problem = problems[currentProblem];
            const container = document.getElementById('multiplier-controls');
            container.innerHTML = '';
            
            // Add equality multipliers
            problem.equalityConstraints.forEach((_, i) => {
                const div = document.createElement('div');
                div.className = 'multiplier-input';
                div.innerHTML = `
                    <label>λ${i+1}</label>
                    <input type="number" step="0.1" value="0" onchange="updateMultiplier('lambda${i+1}', this.value)">
                `;
                container.appendChild(div);
            });
            
            // Add inequality multipliers
            problem.inequalityConstraints.forEach((_, i) => {
                const div = document.createElement('div');
                div.className = 'multiplier-input';
                div.innerHTML = `
                    <label>μ${i+1}</label>
                    <input type="number" step="0.1" value="0" min="0" onchange="updateMultiplier('mu${i+1}', this.value)">
                `;
                container.appendChild(div);
            });
        }
        
        function updateMultiplier(name, value) {
            multipliers[name] = parseFloat(value) || 0;
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function updateLagrangianDisplay() {
            const problem = problems[currentProblem];
            let lagrangian = problem.objective.formula;
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                const constraintTerm = constraint.formula.split(' = ')[0];
                lagrangian += ` + λ${i+1}(${constraintTerm})`;
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const constraintTerm = constraint.formula.split(' ≤ ')[0];
                lagrangian += ` + μ${i+1}(${constraintTerm})`;
            });
            
            let multiplierValues = '<br/><strong style="color: #00FFFF;">Giá trị hiện tại:</strong><br/>';
            Object.keys(multipliers).forEach(key => {
                const value = multipliers[key] || 0;
                multiplierValues += `${key} = ${value.toFixed(3)}<br/>`;
            });
            
            // Calculate Lagrangian value at current analysis point
            const point = analysisPoint;
            let lagrangianValue = problem.objective.func(point.x, point.y);
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                lagrangianValue += lambda * constraint.func(point.x, point.y);
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                lagrangianValue += mu * constraint.func(point.x, point.y);
            });
            
            document.getElementById('lagrangian-display').innerHTML = `
                <strong>Hàm Lagrangian:</strong><br/>
                L(x,y,λ,μ) = ${lagrangian}
                ${multiplierValues}
                <br/><strong style="color: #2ecc71;">Tại điểm hiện tại:</strong> L = ${lagrangianValue.toFixed(3)}
            `;
        }
        
        function updateKKTConditions() {
            const problem = problems[currentProblem];
            const point = analysisPoint;
            let html = '<strong>Điều Kiện KKT tại điểm hiện tại:</strong><br/><br/>';
            
            // Stationarity condition
            const objGrad = problem.objective.grad(point.x, point.y);
            let gradLagrangian = [objGrad[0], objGrad[1]];
            
            problem.equalityConstraints.forEach((constraint, i) => {
                const lambda = multipliers[`lambda${i+1}`] || 0;
                const constraintGrad = constraint.grad(point.x, point.y);
                gradLagrangian[0] += lambda * constraintGrad[0];
                gradLagrangian[1] += lambda * constraintGrad[1];
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const constraintGrad = constraint.grad(point.x, point.y);
                gradLagrangian[0] += mu * constraintGrad[0];
                gradLagrangian[1] += mu * constraintGrad[1];
            });
            
            const stationarityViolation = Math.sqrt(gradLagrangian[0]**2 + gradLagrangian[1]**2);
            html += `<div class="condition-status ${stationarityViolation < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
            html += `<strong>1. Điều kiện Stationarity:</strong><br/>`;
            html += `∇L = (${gradLagrangian[0].toFixed(3)}, ${gradLagrangian[1].toFixed(3)}) ≈ (0, 0)<br/>`;
            html += `||∇L|| = ${stationarityViolation.toFixed(3)} ${stationarityViolation < 0.1 ? '✓' : '✗'}`;
            html += `</div>`;
            
            // Primal feasibility for equality constraints
            problem.equalityConstraints.forEach((constraint, i) => {
                const value = constraint.func(point.x, point.y);
                html += `<div class="condition-status ${Math.abs(value) < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>2.${i+1} Khả thi primal (đẳng thức):</strong><br/>`;
                html += `g${i+1}(x) = ${value.toFixed(3)} = 0 ${Math.abs(value) < 0.1 ? '✓' : '✗'}`;
                html += `</div>`;
            });
            
            // Primal feasibility for inequality constraints
            problem.inequalityConstraints.forEach((constraint, i) => {
                const value = constraint.func(point.x, point.y);
                html += `<div class="condition-status ${value <= 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>3.${i+1} Khả thi primal (bất đẳng thức):</strong><br/>`;
                html += `h${i+1}(x) = ${value.toFixed(3)} ≤ 0 ${value <= 0.1 ? '✓' : '✗'}`;
                if (value <= 0.01) html += ` (active)`;
                html += `</div>`;
            });
            
            // Dual feasibility
            problem.inequalityConstraints.forEach((_, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                html += `<div class="condition-status ${mu >= -0.01 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>4.${i+1} Khả thi dual:</strong><br/>`;
                html += `μ${i+1} = ${mu.toFixed(3)} ≥ 0 ${mu >= -0.01 ? '✓' : '✗'}`;
                html += `</div>`;
            });
            
            // Complementary slackness
            problem.inequalityConstraints.forEach((constraint, i) => {
                const mu = multipliers[`mu${i+1}`] || 0;
                const h = constraint.func(point.x, point.y);
                const complementarySlackness = Math.abs(mu * h);
                html += `<div class="condition-status ${complementarySlackness < 0.1 ? 'condition-satisfied' : 'condition-violated'}">`;
                html += `<strong>5.${i+1} Complementary Slackness:</strong><br/>`;
                html += `μ${i+1}·h${i+1} = ${mu.toFixed(3)} × ${h.toFixed(3)} = ${complementarySlackness.toFixed(3)} = 0<br/>`;
                html += `${complementarySlackness < 0.1 ? '✓' : '✗'}`;
                if (complementarySlackness < 0.1) {
                    if (Math.abs(mu) < 0.01) html += ` (μ ≈ 0, ràng buộc không active)`;
                    else if (Math.abs(h) < 0.01) html += ` (h ≈ 0, ràng buộc active)`;
                }
                html += `</div>`;
            });
            
            // Overall assessment
            const allConditionsSatisfied = stationarityViolation < 0.1 &&
                problem.equalityConstraints.every(c => Math.abs(c.func(point.x, point.y)) < 0.1) &&
                problem.inequalityConstraints.every(c => c.func(point.x, point.y) <= 0.1) &&
                problem.inequalityConstraints.every((_, i) => (multipliers[`mu${i+1}`] || 0) >= -0.01) &&
                problem.inequalityConstraints.every((c, i) => {
                    const mu = multipliers[`mu${i+1}`] || 0;
                    const h = c.func(point.x, point.y);
                    return Math.abs(mu * h) < 0.1;
                });
            
            html += `<br/><div class="condition-status ${allConditionsSatisfied ? 'condition-satisfied' : 'condition-violated'}">`;
            html += `<strong>🎯 Tổng kết:</strong> ${allConditionsSatisfied ? 
                'Tất cả điều kiện KKT được thỏa mãn! Đây có thể là điểm tối ưu.' : 
                'Một số điều kiện KKT bị vi phạm. Điều chỉnh điểm hoặc nhân tử.'}`;
            html += `</div>`;
            
            document.getElementById('kkt-conditions').innerHTML = html;
        }
        
        function updatePointAnalysis() {
            const problem = problems[currentProblem];
            const point = analysisPoint;
            
            let html = `<strong>Phân Tích Điểm: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})</strong><br/><br/>`;
            
            const objectiveValue = problem.objective.func(point.x, point.y);
            const objectiveGrad = problem.objective.grad(point.x, point.y);
            
            html += `<strong style="color: #00FFFF;">Hàm mục tiêu:</strong><br/>`;
            html += `f(x,y) = ${objectiveValue.toFixed(3)}<br/>`;
            html += `∇f = (${objectiveGrad.map(g => g.toFixed(3)).join(', ')})<br/>`;
            html += `||∇f|| = ${Math.sqrt(objectiveGrad[0]**2 + objectiveGrad[1]**2).toFixed(3)}<br/><br/>`;
            
            if (problem.equalityConstraints.length > 0) {
                html += '<strong style="color: #e74c3c;">Ràng buộc đẳng thức:</strong><br/>';
                problem.equalityConstraints.forEach((constraint, i) => {
                    const value = constraint.func(point.x, point.y);
                    const grad = constraint.grad(point.x, point.y);
                    html += `g${i+1}(x,y) = ${value.toFixed(3)} ${Math.abs(value) < 0.1 ? '(thỏa mãn)' : '(vi phạm)'}<br/>`;
                    html += `∇g${i+1} = (${grad.map(g => g.toFixed(3)).join(', ')})<br/>`;
                });
                html += '<br/>';
            }
            
            if (problem.inequalityConstraints.length > 0) {
                html += '<strong style="color: #f39c12;">Ràng buộc bất đẳng thức:</strong><br/>';
                problem.inequalityConstraints.forEach((constraint, i) => {
                    const value = constraint.func(point.x, point.y);
                    const grad = constraint.grad(point.x, point.y);
                    let status = '';
                    if (value <= -0.1) status = '(không active)';
                    else if (value <= 0.1) status = '(active/biên)';
                    else status = '(vi phạm)';
                    
                    html += `h${i+1}(x,y) = ${value.toFixed(3)} ${status}<br/>`;
                    html += `∇h${i+1} = (${grad.map(g => g.toFixed(3)).join(', ')})<br/>`;
                });
                html += '<br/>';
            }
            
            // Check if point is feasible
            let feasible = true;
            problem.equalityConstraints.forEach(c => {
                if (Math.abs(c.func(point.x, point.y)) > 0.1) feasible = false;
            });
            problem.inequalityConstraints.forEach(c => {
                if (c.func(point.x, point.y) > 0.1) feasible = false;
            });
            
            html += `<strong>Tình trạng khả thi:</strong> `;
            html += feasible ? 
                '<span style="color: #2ecc71;">✓ Khả thi</span>' : 
                '<span style="color: #e74c3c;">✗ Không khả thi</span>';
            
            // Distance to optimal point
            if (problem.optimalPoint) {
                const dx = point.x - problem.optimalPoint.x;
                const dy = point.y - problem.optimalPoint.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                html += `<br/><strong>Khoảng cách đến x*:</strong> ${distance.toFixed(3)}`;
                
                if (problem.optimalValue !== null) {
                    const optimalityGap = objectiveValue - problem.optimalValue;
                    html += `<br/><strong>Optimality gap:</strong> ${optimalityGap.toFixed(3)}`;
                }
            }
            
            document.getElementById('point-analysis').innerHTML = html;
        }
        
        function findOptimalMultipliers() {
            const problem = problems[currentProblem];
            const optimalMults = problem.optimalMultipliers;
            
            // Set optimal multipliers
            Object.keys(optimalMults).forEach(key => {
                multipliers[key] = optimalMults[key];
            });
            
            // Update input fields
            Object.keys(optimalMults).forEach(key => {
                const input = document.querySelector(`input[onchange*="${key}"]`);
                if (input) input.value = optimalMults[key];
            });
            
            // Set analysis point to optimal point
            if (problem.optimalPoint) {
                analysisPoint = { ...problem.optimalPoint };
                document.getElementById('analysisX').value = analysisPoint.x;
                document.getElementById('analysisY').value = analysisPoint.y;
                document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
                document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            }
            
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function resetMultipliers() {
            Object.keys(multipliers).forEach(key => {
                multipliers[key] = 0;
            });
            
            // Reset input fields
            document.querySelectorAll('#multiplier-controls input').forEach(input => {
                input.value = 0;
            });
            
            updateLagrangianDisplay();
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let i = -10; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(width, toCanvasY(i));
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
        }
        
        function drawObjectiveContours() {
            if (!showOptions.objective) return;
            
            const problem = problems[currentProblem];
            const step = 0.08;
            
            // Calculate value range for better contour selection
            let minVal = Infinity, maxVal = -Infinity;
            for (let x = -4; x <= 4; x += 0.5) {
                for (let y = -3; y <= 3; y += 0.5) {
                    const val = problem.objective.func(x, y);
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                }
            }
            
            // Draw contour lines with adaptive levels
            const numLevels = 12;
            for (let i = 0; i < numLevels; i++) {
                const level = minVal + (maxVal - minVal) * i / (numLevels - 1);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + 0.4 * (1 - Math.abs(i - numLevels/2) / (numLevels/2))})`;
                ctx.lineWidth = Math.abs(i - numLevels/2) < 2 ? 2 : 1;
                
                drawContourLine(problem.objective.func, level, step);
            }
            
            // Add contour labels
            if (problem.optimalPoint) {
                const optimalValue = problem.objective.func(problem.optimalPoint.x, problem.optimalPoint.y);
                ctx.fillStyle = '#00FFFF';
                ctx.font = '12px Arial';
                ctx.fillText(`f* = ${optimalValue.toFixed(2)}`, 
                    toCanvasX(problem.optimalPoint.x) + 15, 
                    toCanvasY(problem.optimalPoint.y) + 20);
            }
        }
        
        function drawContourLine(func, level, step) {
            ctx.beginPath();
            let hasPoints = false;
            
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    const value = func(x, y);
                    if (Math.abs(value - level) < step * 2) {
                        if (!hasPoints) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            hasPoints = true;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    }
                }
            }
            
            if (hasPoints) {
                ctx.stroke();
            }
        }
        
        function drawConstraints() {
            if (!showOptions.constraints) return;
            
            const problem = problems[currentProblem];
            
            // Draw equality constraints
            problem.equalityConstraints.forEach((constraint, i) => {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                drawConstraintCurve(constraint.func, 0);
                
                // Add constraint labels
                ctx.fillStyle = '#e74c3c';
                ctx.font = '14px Arial';
                // Find a point on the constraint for labeling
                for (let x = -3; x <= 3; x += 0.5) {
                    for (let y = -2; y <= 2; y += 0.5) {
                        if (Math.abs(constraint.func(x, y)) < 0.1) {
                            ctx.fillText(`g${i+1}=0`, toCanvasX(x) + 10, toCanvasY(y) - 10);
                            break;
                        }
                    }
                }
            });
            
            // Draw inequality constraints
            problem.inequalityConstraints.forEach((constraint, i) => {
                // Draw constraint boundary
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                drawConstraintCurve(constraint.func, 0);
                ctx.setLineDash([]);
                
                // Add constraint labels
                ctx.fillStyle = '#f39c12';
                ctx.font = '14px Arial';
                for (let x = -3; x <= 3; x += 0.5) {
                    for (let y = -2; y <= 2; y += 0.5) {
                        if (Math.abs(constraint.func(x, y)) < 0.1) {
                            ctx.fillText(`h${i+1}≤0`, toCanvasX(x) + 10, toCanvasY(y) - 10);
                            break;
                        }
                    }
                }
                
                // Shade infeasible region
                if (showOptions.feasible) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    const step = 0.15;
                    for (let x = -4; x <= 4; x += step) {
                        for (let y = -3; y <= 3; y += step) {
                            if (constraint.func(x, y) > 0.05) {
                                ctx.fillRect(toCanvasX(x) - 2, toCanvasY(y) - 2, 4, 4);
                            }
                        }
                    }
                }
            });
        }
        
        function drawConstraintCurve(constraintFunc, level) {
            const step = 0.04;
            ctx.beginPath();
            let hasPoints = false;
            
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    const value = constraintFunc(x, y);
                    if (Math.abs(value - level) < step * 2) {
                        if (!hasPoints) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            hasPoints = true;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    }
                }
            }
            
            if (hasPoints) {
                ctx.stroke();
            }
        }
        
        function drawFeasibleRegion() {
            if (!showOptions.feasible) return;
            
            const problem = problems[currentProblem];
            ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
            
            const step = 0.1;
            for (let x = -4; x <= 4; x += step) {
                for (let y = -3; y <= 3; y += step) {
                    let feasible = true;
                    
                    // Check equality constraints
                    problem.equalityConstraints.forEach(constraint => {
                        if (Math.abs(constraint.func(x, y)) > 0.1) {
                            feasible = false;
                        }
                    });
                    
                    // Check inequality constraints
                    problem.inequalityConstraints.forEach(constraint => {
                        if (constraint.func(x, y) > 0.01) {
                            feasible = false;
                        }
                    });
                    
                    if (feasible) {
                        ctx.fillRect(toCanvasX(x) - 1, toCanvasY(y) - 1, 2, 2);
                    }
                }
            }
        }
        
        function drawGradients() {
            if (!showOptions.gradients) return;
            
            const problem = problems[currentProblem];
            const point = analysisPoint;
            
            // Draw objective gradient
            const objGrad = problem.objective.grad(point.x, point.y);
            drawGradientVector(point, objGrad, '#0ff', '∇f');
            
            // Draw constraint gradients
            problem.equalityConstraints.forEach((constraint, i) => {
                const grad = constraint.grad(point.x, point.y);
                drawGradientVector(point, grad, '#e74c3c', `∇g${i+1}`);
            });
            
            problem.inequalityConstraints.forEach((constraint, i) => {
                const grad = constraint.grad(point.x, point.y);
                drawGradientVector(point, grad, '#f39c12', `∇h${i+1}`);
            });
        }
        
        function drawGradientVector(point, grad, color, label) {
            const magnitude = Math.sqrt(grad[0]**2 + grad[1]**2);
            if (magnitude < 1e-6) return;
            
            const scale_factor = 0.5;
            const endX = point.x + grad[0] * scale_factor;
            const endY = point.y + grad[1] * scale_factor;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Arrow body
            ctx.beginPath();
            ctx.moveTo(toCanvasX(point.x), toCanvasY(point.y));
            ctx.lineTo(toCanvasX(endX), toCanvasY(endY));
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(endY - point.y, endX - point.x);
            const headLength = 0.2;
            
            ctx.beginPath();
            ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
            ctx.lineTo(
                toCanvasX(endX - headLength * Math.cos(angle - Math.PI / 6)),
                toCanvasY(endY - headLength * Math.sin(angle - Math.PI / 6))
            );
            ctx.moveTo(toCanvasX(endX), toCanvasY(endY));
            ctx.lineTo(
                toCanvasX(endX - headLength * Math.cos(angle + Math.PI / 6)),
                toCanvasY(endY - headLength * Math.sin(angle + Math.PI / 6))
            );
            ctx.stroke();
            
            // Label
            ctx.font = '12px Arial';
            ctx.fillText(label, toCanvasX(endX) + 5, toCanvasY(endY) - 5);
        }
        
        function drawOptimalPoint() {
            if (!showOptions.optimal) return;
            
            const problem = problems[currentProblem];
            if (!problem.optimalPoint) return;
            
            const optimal = problem.optimalPoint;
            
            ctx.fillStyle = '#9b59b6';
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimal.x), toCanvasY(optimal.y), 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(optimal.x), toCanvasY(optimal.y), 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#9b59b6';
            ctx.font = '14px Arial';
            ctx.fillText('x*', toCanvasX(optimal.x) + 15, toCanvasY(optimal.y) - 10);
        }
        
        function drawAnalysisPoint() {
            const point = analysisPoint;
            
            ctx.fillStyle = '#00ff00';
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(toCanvasX(point.x), toCanvasY(point.y), 6, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(toCanvasX(point.x), toCanvasY(point.y), 10, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            drawGrid();
            drawFeasibleRegion();
            drawObjectiveContours();
            drawConstraints();
            drawGradients();
            drawOptimalPoint();
            drawAnalysisPoint();
        }
        
        function toggleVisualization(option) {
            showOptions[option] = !showOptions[option];
            const button = document.getElementById(`toggle-${option}`);
            button.classList.toggle('active', showOptions[option]);
            draw();
        }
        
        // Event listeners
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            
            analysisPoint.x = fromCanvasX(canvasX);
            analysisPoint.y = fromCanvasY(canvasY);
            
            document.getElementById('analysisX').value = analysisPoint.x;
            document.getElementById('analysisY').value = analysisPoint.y;
            document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
            document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        document.getElementById('analysisX').addEventListener('input', function() {
            analysisPoint.x = parseFloat(this.value);
            document.getElementById('analysisXValue').textContent = analysisPoint.x.toFixed(1);
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        document.getElementById('analysisY').addEventListener('input', function() {
            analysisPoint.y = parseFloat(this.value);
            document.getElementById('analysisYValue').textContent = analysisPoint.y.toFixed(1);
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        });
        
        // Utility functions
        function isFeasible(x, y) {
            const problem = problems[currentProblem];
            
            // Check equality constraints
            for (let constraint of problem.equalityConstraints) {
                if (Math.abs(constraint.func(x, y)) > 0.05) {
                    return false;
                }
            }
            
            // Check inequality constraints
            for (let constraint of problem.inequalityConstraints) {
                if (constraint.func(x, y) > 0.01) {
                    return false;
                }
            }
            
            return true;
        }
        
        function findKKTSolution() {
            const problem = problems[currentProblem];
            
            // Numerical optimization to find KKT solution
            let bestX = analysisPoint.x;
            let bestY = analysisPoint.y;
            let bestValue = problem.objective.func(bestX, bestY);
            
            // Gradient descent with constraint handling
            const maxIterations = 200;
            const tolerance = 1e-6;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const objGrad = problem.objective.grad(bestX, bestY);
                
                // Collect active constraints
                const activeConstraints = [];
                const constraintGrads = [];
                const constraintValues = [];
                
                // Equality constraints (always active)
                problem.equalityConstraints.forEach(constraint => {
                    activeConstraints.push(constraint);
                    constraintGrads.push(constraint.grad(bestX, bestY));
                    constraintValues.push(constraint.func(bestX, bestY));
                });
                
                // Active inequality constraints
                problem.inequalityConstraints.forEach(constraint => {
                    const value = constraint.func(bestX, bestY);
                    if (value > -0.01) { // Nearly active or violated
                        activeConstraints.push(constraint);
                        constraintGrads.push(constraint.grad(bestX, bestY));
                        constraintValues.push(value);
                    }
                });
                
                // Calculate step using projected gradient
                let stepX = -objGrad[0] * 0.01;
                let stepY = -objGrad[1] * 0.01;
                
                // Project violations back to feasible region
                constraintGrads.forEach((grad, i) => {
                    const violation = constraintValues[i];
                    const gradNorm = grad[0]*grad[0] + grad[1]*grad[1];
                    
                    if (gradNorm > tolerance && Math.abs(violation) > tolerance) {
                        const correction = violation / gradNorm;
                        stepX -= grad[0] * correction * 0.5;
                        stepY -= grad[1] * correction * 0.5;
                    }
                });
                
                // Apply step
                const newX = bestX + stepX;
                const newY = bestY + stepY;
                
                // Check convergence
                const stepSize = Math.sqrt(stepX*stepX + stepY*stepY);
                if (stepSize < tolerance) {
                    break;
                }
                
                bestX = Math.max(-3.5, Math.min(3.5, newX));
                bestY = Math.max(-2.5, Math.min(2.5, newY));
            }
            
            // Update analysis point to the found solution
            analysisPoint.x = bestX;
            analysisPoint.y = bestY;
            
            document.getElementById('analysisX').value = bestX;
            document.getElementById('analysisY').value = bestY;
            document.getElementById('analysisXValue').textContent = bestX.toFixed(3);
            document.getElementById('analysisYValue').textContent = bestY.toFixed(3);
            
            updateKKTConditions();
            updatePointAnalysis();
            draw();
        }
        
        // Add KKT solver button functionality
        function addKKTSolverButton() {
            const controlPanel = document.querySelector('.controls');
            if (!controlPanel) {
                console.error('Control panel not found');
                return;
            }
            
            const solverButton = document.createElement('button');
            solverButton.textContent = 'Tìm Nghiệm KKT';
            solverButton.className = 'kkt-solver-button';
            solverButton.onclick = findKKTSolution;
            solverButton.style.cssText = `
                background: linear-gradient(145deg, #9b59b6, #8e44ad);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                margin: 10px 5px;
                transition: all 0.3s ease;
            `;
            solverButton.onmouseover = () => {
                solverButton.style.transform = 'translateY(-2px)';
                solverButton.style.boxShadow = '0 5px 15px rgba(155, 89, 182, 0.4)';
            };
            solverButton.onmouseout = () => {
                solverButton.style.transform = 'translateY(0)';
                solverButton.style.boxShadow = 'none';
            };
            
            controlPanel.appendChild(solverButton);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            selectProblem('equality');
            addKKTSolverButton();
            init3DVisualization();
        });
        
        // Fallback initialization if DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            // Document is still loading
        } else {
            // Document has finished loading
            selectProblem('equality');
            addKKTSolverButton();
            init3DVisualization();
        }
        
        // ===== 3D VISUALIZATION CODE =====
        let scene3D, camera3D, renderer3D, controls3D;
        let objectiveSurface, constraintSurfaces = [], optimalPoint3D;
        
        function init3DVisualization() {
            const container = document.getElementById('canvas3d');
            if (!container) return;
            
            // Scene setup
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x000000);
            
            // Camera setup
            camera3D = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3D.position.set(8, 8, 8);
            
            // Renderer setup
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(container.clientWidth, container.clientHeight);
            renderer3D.shadowMap.enabled = true;
            renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer3D.domElement);
            
            // Controls
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene3D.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene3D.add(directionalLight);
            
            // Create coordinate axes
            const axesHelper = new THREE.AxesHelper(5);
            scene3D.add(axesHelper);
            
            // Initial visualization
            update3DVisualization();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (container && renderer3D) {
                    camera3D.aspect = container.clientWidth / container.clientHeight;
                    camera3D.updateProjectionMatrix();
                    renderer3D.setSize(container.clientWidth, container.clientHeight);
                }
            });
            
            // Animation loop
            animate3D();
        }
        
        function update3DVisualization() {
            if (!scene3D) return;
            
            const problem = problems[currentProblem];
            const resolution = document.getElementById('resolution3D')?.value || 40;
            document.getElementById('resolutionValue').textContent = resolution;
            
            // Clear existing surfaces
            if (objectiveSurface) {
                scene3D.remove(objectiveSurface);
            }
            constraintSurfaces.forEach(surface => scene3D.remove(surface));
            constraintSurfaces = [];
            if (optimalPoint3D) {
                scene3D.remove(optimalPoint3D);
            }
            
            // Create objective surface
            if (document.getElementById('show3DSurface')?.checked) {
                createObjectiveSurface(problem, resolution);
            }
            
            // Create constraint surfaces
            if (document.getElementById('show3DConstraints')?.checked) {
                createConstraintSurfaces(problem, resolution);
            }
            
            // Create optimal point
            if (document.getElementById('show3DOptimal')?.checked && problem.optimalPoint) {
                createOptimalPoint3D(problem);
            }
        }
        
        function createObjectiveSurface(problem, resolution) {
            const geometry = new THREE.PlaneGeometry(6, 6, resolution, resolution);
            const vertices = geometry.attributes.position.array;
            
            // Calculate heights for objective function
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = problem.objective.func(x, y) * 0.5; // Scale Z for better visualization
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const wireframe = document.getElementById('show3DWireframe')?.checked;
            const material = wireframe 
                ? new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })
                : new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
            
            objectiveSurface = new THREE.Mesh(geometry, material);
            scene3D.add(objectiveSurface);
        }
        
        function createConstraintSurfaces(problem, resolution) {
            // Equality constraints (planes)
            problem.equalityConstraints.forEach((constraint, i) => {
                const geometry = new THREE.PlaneGeometry(6, 6, 20, 20);
                const vertices = geometry.attributes.position.array;
                
                // For linear constraints, create planes
                for (let j = 0; j < vertices.length; j += 3) {
                    const x = vertices[j];
                    const y = vertices[j + 1];
                    const constraintValue = constraint.func(x, y);
                    if (Math.abs(constraintValue) < 0.1) {
                        vertices[j + 2] = 0; // Keep on constraint surface
                    } else {
                        vertices[j + 2] = NaN; // Hide points not on constraint
                    }
                }
                
                geometry.attributes.position.needsUpdate = true;
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true, 
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                
                const constraintSurface = new THREE.Mesh(geometry, material);
                constraintSurfaces.push(constraintSurface);
                scene3D.add(constraintSurface);
            });
            
            // Inequality constraints (boundary surfaces)
            problem.inequalityConstraints.forEach((constraint, i) => {
                const geometry = new THREE.PlaneGeometry(6, 6, 30, 30);
                const vertices = geometry.attributes.position.array;
                
                for (let j = 0; j < vertices.length; j += 3) {
                    const x = vertices[j];
                    const y = vertices[j + 1];
                    const constraintValue = constraint.func(x, y);
                    if (Math.abs(constraintValue) < 0.1) {
                        vertices[j + 2] = 0;
                    } else {
                        vertices[j + 2] = NaN;
                    }
                }
                
                geometry.attributes.position.needsUpdate = true;
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const constraintSurface = new THREE.Mesh(geometry, material);
                constraintSurfaces.push(constraintSurface);
                scene3D.add(constraintSurface);
            });
        }
        
        function createOptimalPoint3D(problem) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            
            optimalPoint3D = new THREE.Mesh(geometry, material);
            optimalPoint3D.position.set(
                problem.optimalPoint.x,
                problem.optimalPoint.y,
                problem.objective.func(problem.optimalPoint.x, problem.optimalPoint.y) * 0.5
            );
            
            scene3D.add(optimalPoint3D);
        }
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            if (controls3D) {
                controls3D.update();
            }
            
            if (renderer3D && scene3D && camera3D) {
                renderer3D.render(scene3D, camera3D);
            }
        }
    </script>
</body>
</html>