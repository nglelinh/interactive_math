<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Proximal Operator Demo - To√°n t·ª≠ Proximal</title>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="../math-simple.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #111; font-family: Arial, sans-serif; }
    #container {
      display: flex;
      height: 100vh;
    }
    #canvas-container {
      flex: 1;
      position: relative;
    }
    #canvas {
      width: 100%;
      height: 100%;
      background: #222;
    }
    #info {
      width: 450px;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 20px;
      overflow-y: auto;
      font-size: 13px;
    }
    h3 {
      color: #4CAF50;
      margin-top: 0;
    }
    .section {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
    }
    .theory-section {
      background: rgba(33, 150, 243, 0.15);
      border-left: 4px solid #2196F3;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    
    .algorithm-section {
      background: rgba(156, 39, 176, 0.15);
      border-left: 4px solid #9C27B0;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    
    .application-section {
      background: rgba(76, 175, 80, 0.15);
      border-left: 4px solid #4CAF50;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    
    .formula-box {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 6px;
      padding: 12px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      border-left: 3px solid #FF6B6B;
    }
    
    .convergence-section {
      background: rgba(255, 152, 0, 0.15);
      border-left: 4px solid #FF9800;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    
    .interpretation-section {
      border-left: 4px solid #4CAF50;
    }
    .control-group {
      margin-bottom: 12px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      font-size: 12px;
    }
    input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }
    input[type="number"] {
      width: 60px;
      padding: 2px;
      margin: 0 3px;
      background: #333;
      color: white;
      border: 1px solid #555;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin: 3px;
      font-size: 11px;
    }
    button:hover {
      background: #45a049;
    }
    .compute-btn {
      background: #2196F3;
    }
    .compute-btn:hover {
      background: #1976D2;
    }
    .reset-btn {
      background: #f44336;
    }
    .reset-btn:hover {
      background: #da190b;
    }
    select {
      width: 100%;
      padding: 4px;
      margin-bottom: 8px;
      background: #333;
      color: white;
      border: 1px solid #555;
      font-size: 11px;
    }
    .value-display {
      color: #4CAF50;
      font-weight: bold;
    }
    .math-formula {
      font-family: 'Times New Roman', serif;
      font-style: italic;
      background: rgba(0, 0, 0, 0.3);
      padding: 8px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 12px;
    }
    .result-info {
      background: rgba(33, 150, 243, 0.2);
      padding: 8px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 11px;
    }
    .proximity-interpretation {
      background: rgba(76, 175, 80, 0.2);
      padding: 8px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 11px;
    }
    
    /* SVG styles */
    .function-curve {
      stroke: #2196F3;
      stroke-width: 2;
      fill: none;
    }
    .proximal-function {
      stroke: #FF9800;
      stroke-width: 2;
      fill: none;
      stroke-dasharray: 5,5;
    }
    .quadratic-term {
      stroke: #9C27B0;
      stroke-width: 1;
      fill: none;
      opacity: 0.7;
    }
    .input-point {
      fill: #f44336;
      stroke: white;
      stroke-width: 2;
    }
    .proximal-point {
      fill: #4CAF50;
      stroke: white;
      stroke-width: 3;
    }
    .connection-line {
      stroke: #FFEB3B;
      stroke-width: 2;
      stroke-dasharray: 3,3;
    }
    .axis {
      stroke: #666;
      stroke-width: 1;
    }
    .grid-line {
      stroke: #333;
      stroke-width: 0.5;
    }
    .label {
      fill: white;
      font-size: 12px;
      font-family: Arial, sans-serif;
    }
    .gradient-arrow {
      stroke: #E91E63;
      stroke-width: 2;
      fill: #E91E63;
    }
    .level-curve {
      stroke: #00BCD4;
      stroke-width: 1;
      fill: none;
      opacity: 0.6;
    }
  </style>





</head>
<body>
  <div id="container">
    <div id="canvas-container">
      <svg id="canvas"></svg>
    </div>
    
    <div id="info">
      <h3>üéØ Demo To√°n t·ª≠ Proximal Interactive</h3>
      
      <div class="section theory-section">
        <h4>üìê ƒê·ªãnh nghƒ©a & L√Ω thuy·∫øt</h4>
        <div>Cho h√†m $g: \mathbb{R}^n \to \mathbb{R} \cup \{+\infty\}$ v√† tham s·ªë $\lambda > 0$, <strong>to√°n t·ª≠ proximal</strong> ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a:</div>
        <div class="formula-box">
          $$\text{prox}_{\lambda g}(v) = \underset{x}{\arg\min} \left\{ g(x) + \frac{1}{2\lambda}\|x - v\|^2 \right\}$$
        </div>
        <div><strong>√ù nghƒ©a h√¨nh h·ªçc:</strong></div>
        <div>‚Ä¢ T√¨m ƒëi·ªÉm $x$ c√¢n b·∫±ng gi·ªØa vi·ªác minimize $g(x)$ v√† g·∫ßn v·ªõi $v$</div>
        <div>‚Ä¢ $\lambda$ ƒëi·ªÅu khi·ªÉn ƒë·ªô "m∆∞·ª£t" c·ªßa ph√©p chi·∫øu</div>
        <div>‚Ä¢ Khi $\lambda \to 0$: $\text{prox}_{\lambda g}(v) \to v$</div>
        <div>‚Ä¢ Khi $\lambda \to \infty$: $\text{prox}_{\lambda g}(v) \to \arg\min g$</div>
        
        <div class="formula-box">
          <strong>ƒê·ªãnh l√Ω Moreau-Yosida:</strong><br>
          Moreau envelope: $g_\lambda(v) = \inf_x \left\{ g(x) + \frac{1}{2\lambda}\|x-v\|^2 \right\}$<br>
          Moreau decomposition: $v = \text{prox}_{\lambda g}(v) + \lambda \cdot \text{prox}_{g^*/\lambda}(v/\lambda)$<br>
          where $g^*$ is conjugate function of $g$
        </div>
      </div>

      <div class="section algorithm-section">
        <h4>üî¨ Thu·∫≠t to√°n & T√≠nh ch·∫•t</h4>
        <div class="formula-box">
          <strong>1. Firmly Non-expansive:</strong><br>
          $\|\text{prox}_{\lambda g}(u) - \text{prox}_{\lambda g}(v)\| \leq \|u - v\|$<br><br>
          
          <strong>2. Resolvent Identity:</strong><br>
          $\text{prox}_{\lambda g} = (I + \lambda \partial g)^{-1}$<br><br>
          
          <strong>3. Fixed Point Characterization:</strong><br>
          $x^* = \text{prox}_{\lambda g}(x^*) \iff 0 \in \partial g(x^*)$<br><br>
          
          <strong>4. Scaling Property:</strong><br>
          $\text{prox}_{\lambda g}(\alpha v) = \alpha \cdot \text{prox}_{\lambda g/\alpha^2}(v)$ (for $g$ homogeneous)
        </div>
      </div>

      <div class="section examples-section">
        <h4>üìä L·ª±a ch·ªçn H√†m & Tham s·ªë</h4>
        <div class="control-group">
          <label>H√†m g(x):</label>
          <select id="functionSelect">
            <option value="l1">L1 Norm: |x| (Soft Thresholding)</option>
            <option value="l2">L2 Norm: ¬Ωx¬≤ (Shrinkage)</option>
            <option value="huber">Huber Loss (Robust Regression)</option>
            <option value="hinge">Hinge Loss: max(0, 1-x) (SVM)</option>
            <option value="indicator">Indicator: I[‚àí1,1](x) (Projection)</option>
            <option value="elastic">Elastic Net: |x| + ¬Ωx¬≤ (LASSO+Ridge)</option>
            <option value="logistic">Logistic: log(1+exp(x)) (Classification)</option>
            <option value="quadratic">Quadratic: x¬≤ + x + 1 (General Quadratic)</option>
            <option value="nuclear">Nuclear Norm Approximation</option>
            <option value="group">Group LASSO Approximation</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>ƒêi·ªÉm ƒë·∫ßu v√†o (v):</label>
          <input type="range" id="inputPoint" min="-4" max="4" step="0.05" value="2.0">
          <span id="inputPointValue">2.0</span>
        </div>
        
        <div class="control-group">
          <label>Tham s·ªë Proximal (Œª):</label>
          <input type="range" id="lambda" min="0.01" max="3" step="0.01" value="0.5">
          <span id="lambdaValue">0.5</span>
        </div>
        
        <div class="control-group">
          <label>S·ªë l∆∞·ª£ng iterations (cho animation):</label>
          <input type="range" id="iterations" min="10" max="100" step="5" value="50">
          <span id="iterationsValue">50</span>
        </div>
        
        <div class="control-group">
          <button id="computeBtn" class="compute-btn">üîç T√≠nh Proximal Operator</button>
          <button id="animateBtn">üé¨ Animate Œª</button>
          <button id="convergenceBtn">üìà Hi·ªÉn th·ªã h·ªôi t·ª•</button>
          <button id="resetBtn" class="reset-btn">üîÑ Reset</button>
        </div>
      </div>

      <div class="section computation-section">
        <h4>üíª T√≠nh to√°n Hi·ªán t·∫°i</h4>
        <div id="functionInfo">
          <div><strong>H√†m:</strong> <span id="functionName">|x|</span></div>
          <div><strong>ƒêi·ªÉm ƒë·∫ßu v√†o (v):</strong> <span id="currentInput" class="value-display">2.0</span></div>
          <div><strong>Lambda (Œª):</strong> <span id="currentLambda" class="value-display">0.5</span></div>
        </div>
        
        <div class="result-info">
          <div><strong>K·∫øt qu·∫£ Proximal:</strong> <span id="proximalResult" class="value-display">-</span></div>
          <div><strong>Gi√° tr·ªã Objective:</strong> <span id="objectiveValue" class="value-display">-</span></div>
          <div><strong>Kho·∫£ng c√°ch ƒë·∫øn Input:</strong> <span id="distanceValue" class="value-display">-</span></div>
          <div><strong>Shrinkage Factor:</strong> <span id="shrinkageValue" class="value-display">-</span></div>
        </div>
        
        <div class="formula-box" id="closedFormula">
          <div><strong>Closed Form Solution:</strong></div>
          <div id="formulaText">Ch·ªçn m·ªôt h√†m ƒë·ªÉ xem c√¥ng th·ª©c</div>
        </div>
        
        <div class="formula-box" id="subdifferentialInfo">
          <div><strong>Subdifferential Analysis:</strong></div>
          <div id="subdifferentialText">Ph√¢n t√≠ch subdifferential s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y</div>
        </div>
      </div>

      <div class="section application-section">
        <h4>üöÄ ·ª®ng d·ª•ng trong Machine Learning</h4>
        <div class="formula-box">
          <strong>1. FISTA (Fast Iterative Shrinkage-Thresholding):</strong><br>
          $x_{k+1} = \text{prox}_{\lambda R}(y_k - \lambda \nabla f(y_k))$<br>
          $y_{k+1} = x_{k+1} + \frac{t_k - 1}{t_{k+1}}(x_{k+1} - x_k)$<br><br>
          
          <strong>2. ADMM (Alternating Direction Method of Multipliers):</strong><br>
          $x^{k+1} = \text{prox}_{f/\rho}(z^k - u^k)$<br>
          $z^{k+1} = \text{prox}_{g/\rho}(x^{k+1} + u^k)$<br>
          $u^{k+1} = u^k + x^{k+1} - z^{k+1}$<br><br>
          
          <strong>3. Proximal Gradient Method:</strong><br>
          $x_{k+1} = \text{prox}_{\lambda g}(x_k - \lambda \nabla f(x_k))$
        </div>
        
        <div style="font-size: 12px; margin-top: 10px;">
          <div><strong>‚Ä¢ LASSO Regression:</strong> prox c·ªßa L1 norm (soft thresholding)</div>
          <div><strong>‚Ä¢ Image Denoising:</strong> prox c·ªßa Total Variation</div>
          <div><strong>‚Ä¢ Matrix Completion:</strong> prox c·ªßa Nuclear norm</div>
          <div><strong>‚Ä¢ Support Vector Machines:</strong> prox c·ªßa Hinge loss</div>
          <div><strong>‚Ä¢ Group LASSO:</strong> prox c·ªßa Group L1 norm</div>
          <div><strong>‚Ä¢ Elastic Net:</strong> prox c·ªßa L1 + L2 regularization</div>
        </div>
      </div>

      <div class="section convergence-section">
        <h4>üìà Ph√¢n t√≠ch H·ªôi t·ª•</h4>
        <div class="formula-box">
          <strong>Proximal Gradient Convergence:</strong><br>
          For $f$ convex with $L$-smooth gradient, $g$ convex:<br>
          $f(x_k) + g(x_k) - f(x^*) - g(x^*) \leq \frac{L\|x_0 - x^*\|^2}{2k}$<br><br>
          
          <strong>FISTA Acceleration:</strong><br>
          $f(x_k) + g(x_k) - f(x^*) - g(x^*) \leq \frac{2L\|x_0 - x^*\|^2}{(k+1)^2}$<br><br>
          
          <strong>Strong Convexity ($\mu$-strongly convex):</strong><br>
          $\|x_k - x^*\| \leq \left(1 - \frac{\mu}{L}\right)^k \|x_0 - x^*\|$
        </div>
      </div>

      <div class="section interpretation-section">
        <h4>üé® Gi·∫£i th√≠ch H√¨nh h·ªçc</h4>
        <div class="proximity-interpretation">
          <div><strong>√ù nghƒ©a c·ªßa c√°c th√†nh ph·∫ßn trong visualization:</strong></div>
          <div>‚Ä¢ <span style="color: #f44336;">ƒêi·ªÉm ƒë·ªè</span>: ƒêi·ªÉm ƒë·∫ßu v√†o v</div>
          <div>‚Ä¢ <span style="color: #4CAF50;">ƒêi·ªÉm xanh</span>: K·∫øt qu·∫£ proximal operator</div>
          <div>‚Ä¢ <span style="color: #2196F3;">ƒê∆∞·ªùng cong xanh</span>: H√†m g·ªëc g(x)</div>
          <div>‚Ä¢ <span style="color: #FF9800;">ƒê∆∞·ªùng cong cam</span>: Moreau envelope (g l√†m m∆∞·ª£t)</div>
          <div>‚Ä¢ <span style="color: #9C27B0;">ƒê∆∞·ªùng cong t√≠m</span>: Quadratic penalty term</div>
          <div>‚Ä¢ <span style="color: #FFEB3B;">ƒê∆∞·ªùng v√†ng</span>: K·∫øt n·ªëi th·ªÉ hi·ªán "shrinkage"</div>
          <div>‚Ä¢ <span style="color: #E91E63;">M≈©i t√™n h·ªìng</span>: Gradient t·∫°i ƒëi·ªÉm proximal</div>
        </div>
        
        <div id="interpretationText">
          To√°n t·ª≠ proximal "co" ho·∫∑c "chi·∫øu" ƒëi·ªÉm ƒë·∫ßu v√†o v·ªÅ v√πng c√≥ g(x) nh·ªè, 
          c√¢n b·∫±ng v·ªõi vi·ªác gi·ªØ g·∫ßn ƒëi·ªÉm g·ªëc. Tham s·ªë Œª ƒëi·ªÅu khi·ªÉn ƒë·ªô m·∫°nh c·ªßa ph√©p co n√†y.
        </div>
      </div>

      <div class="section">
        <h4>üéõÔ∏è ƒêi·ªÅu khi·ªÉn Visualization</h4>
        <div class="control-group">
          <div><input type="checkbox" id="showOriginal" checked> Hi·ªÉn th·ªã h√†m g·ªëc g(x)</div>
          <div><input type="checkbox" id="showQuadratic" checked> Hi·ªÉn th·ªã quadratic term</div>
          <div><input type="checkbox" id="showMoreau" checked> Hi·ªÉn th·ªã Moreau envelope</div>
          <div><input type="checkbox" id="showGradient"> Hi·ªÉn th·ªã gradient t·∫°i proximal point</div>
          <div><input type="checkbox" id="showLevelCurves"> Hi·ªÉn th·ªã level curves</div>
          <div><input type="checkbox" id="showGrid" checked> Hi·ªÉn th·ªã l∆∞·ªõi t·ªça ƒë·ªô</div>
          <div><input type="checkbox" id="showSubdifferential"> Hi·ªÉn th·ªã subdifferential</div>
          <div><input type="checkbox" id="showConvergence"> Hi·ªÉn th·ªã qu√° tr√¨nh h·ªôi t·ª•</div>
        </div>
        
        <div class="control-group">
          <label>Zoom level:</label>
          <input type="range" id="zoomLevel" min="0.5" max="3" step="0.1" value="1">
          <span id="zoomValue">1.0</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const svg = document.getElementById('canvas');
    const container = document.getElementById('canvas-container');
    
    // Parameters
    let currentFunction = 'l1';
    let inputPoint = 1.5;
    let lambda = 0.5;
    let proximalPoint = null;
    let isAnimating = false;

    // Enhanced function definitions with more comprehensive examples
    const functions = {
      l1: {
        name: '|x|',
        f: x => Math.abs(x),
        prox: (v, lam) => Math.sign(v) * Math.max(0, Math.abs(v) - lam),
        formula: '$$\\text{prox}_{\\lambda|\\cdot|}(v) = \\text{sign}(v) \\cdot \\max(0, |v| - \\lambda)$$',
        description: 'Soft thresholding operator - t·∫°o sparsity, d√πng trong LASSO',
        subdifferential: x => x > 0 ? [1] : (x < 0 ? [-1] : [-1, 1]),
        moreauEnvelope: (v, lam) => {
          const prox = Math.sign(v) * Math.max(0, Math.abs(v) - lam);
          return Math.abs(prox) + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'LASSO regression, sparse coding, compressed sensing'
      },
      l2: {
        name: '¬Ωx¬≤',
        f: x => 0.5 * x * x,
        prox: (v, lam) => v / (1 + lam),
        formula: '$$\\text{prox}_{\\lambda \\frac{1}{2}|\\cdot|^2}(v) = \\frac{v}{1 + \\lambda}$$',
        description: 'Shrinkage operator - thu nh·ªè v·ªÅ 0 v·ªõi t·ª∑ l·ªá c·ªë ƒë·ªãnh',
        subdifferential: x => [x],
        moreauEnvelope: (v, lam) => {
          const prox = v / (1 + lam);
          return 0.5 * prox * prox + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Ridge regression, Tikhonov regularization'
      },
      huber: {
        name: 'Huber(x, Œ¥=1)',
        f: x => Math.abs(x) <= 1 ? 0.5 * x * x : Math.abs(x) - 0.5,
        prox: (v, lam) => {
          if (Math.abs(v) <= lam + 1) {
            return v / (1 + lam);
          } else {
            return Math.sign(v) * (Math.abs(v) - lam);
          }
        },
        formula: '$$\\text{prox}_{\\lambda \\text{Huber}}(v) = \\begin{cases} \\frac{v}{1+\\lambda} & |v| \\leq \\lambda + 1 \\\\ \\text{sign}(v)(|v| - \\lambda) & |v| > \\lambda + 1 \\end{cases}$$',
        description: 'Robust loss function - L2 cho small errors, L1 cho large errors',
        subdifferential: x => Math.abs(x) < 1 ? [x] : (x > 0 ? [1] : [-1]),
        moreauEnvelope: (v, lam) => {
          const prox = functions.huber.prox(v, lam);
          return functions.huber.f(prox) + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Robust regression, outlier detection'
      },
      hinge: {
        name: 'max(0, 1-x)',
        f: x => Math.max(0, 1 - x),
        prox: (v, lam) => {
          if (v >= 1 + lam) return v - lam;
          if (v <= 1) return v;
          return 1;
        },
        formula: '$$\\text{prox}_{\\lambda \\max(0,1-\\cdot)}(v) = \\begin{cases} v - \\lambda & v \\geq 1 + \\lambda \\\\ 1 & 1 < v < 1 + \\lambda \\\\ v & v \\leq 1 \\end{cases}$$',
        description: 'Hinge loss - d√πng trong SVM, t·∫°o margin t·∫°i x = 1',
        subdifferential: x => x < 1 ? [-1] : (x > 1 ? [0] : [-1, 0]),
        moreauEnvelope: (v, lam) => {
          const prox = functions.hinge.prox(v, lam);
          return Math.max(0, 1 - prox) + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Support Vector Machines, margin-based classification'
      },
      indicator: {
        name: 'I_{[-1,1]}(x)',
        f: x => Math.abs(x) <= 1 ? 0 : Infinity,
        prox: (v, lam) => Math.max(-1, Math.min(1, v)),
        formula: '$$\\text{prox}_{\\lambda I_C}(v) = \\text{Proj}_C(v) = \\max(-1, \\min(1, v))$$',
        description: 'Projection operator - chi·∫øu l√™n constraint set [-1,1]',
        subdifferential: x => Math.abs(x) < 1 ? [0] : (x > 1 ? [0, Infinity] : [-Infinity, 0]),
        moreauEnvelope: (v, lam) => {
          const prox = Math.max(-1, Math.min(1, v));
          return (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Constrained optimization, feasible set projection'
      },
      elastic: {
        name: '|x| + ¬Ωx¬≤',
        f: x => Math.abs(x) + 0.5 * x * x,
        prox: (v, lam) => {
          const denom = 1 + lam;
          return Math.sign(v) * Math.max(0, Math.abs(v) - lam) / denom;
        },
        formula: '$$\\text{prox}_{\\lambda(|\\cdot| + \\frac{1}{2}|\\cdot|^2)}(v) = \\frac{\\text{sign}(v) \\max(0, |v| - \\lambda)}{1 + \\lambda}$$',
        description: 'Elastic Net - k·∫øt h·ª£p sparsity (L1) v√† stability (L2)',
        subdifferential: x => {
          const l1_sub = x > 0 ? [1] : (x < 0 ? [-1] : [-1, 1]);
          return l1_sub.map(s => s + x);
        },
        moreauEnvelope: (v, lam) => {
          const prox = functions.elastic.prox(v, lam);
          return Math.abs(prox) + 0.5 * prox * prox + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Elastic Net regression, feature selection with grouping'
      },
      logistic: {
        name: 'log(1+exp(x))',
        f: x => Math.log(1 + Math.exp(Math.min(x, 700))),
        prox: (v, lam) => {
          // Newton's method for numerical solution
          let x = v;
          for (let i = 0; i < 15; i++) {
            const expx = Math.exp(Math.min(x, 700));
            const sigmoid = expx / (1 + expx);
            const grad = sigmoid + (x - v) / lam;
            const hess = sigmoid * (1 - sigmoid) + 1 / lam;
            const step = grad / hess;
            x -= step;
            if (Math.abs(step) < 1e-10) break;
          }
          return x;
        },
        formula: '$$\\text{Numerical solution via Newton method}$$<br>$$\\frac{d}{dx}\\log(1+e^x) = \\sigma(x) = \\frac{e^x}{1+e^x}$$',
        description: 'Logistic loss - smooth approximation c·ªßa hinge loss',
        subdifferential: x => [Math.exp(Math.min(x, 700)) / (1 + Math.exp(Math.min(x, 700)))],
        moreauEnvelope: (v, lam) => {
          const prox = functions.logistic.prox(v, lam);
          return Math.log(1 + Math.exp(Math.min(prox, 700))) + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Logistic regression, neural networks, smooth classification'
      },
      quadratic: {
        name: 'x¬≤ + x + 1',
        f: x => x * x + x + 1,
        prox: (v, lam) => (v - lam) / (1 + 2 * lam),
        formula: '$$\\text{prox}_{\\lambda(x^2 + x + c)}(v) = \\frac{v - \\lambda}{1 + 2\\lambda}$$',
        description: 'General quadratic function v·ªõi linear term',
        subdifferential: x => [2 * x + 1],
        moreauEnvelope: (v, lam) => {
          const prox = (v - lam) / (1 + 2 * lam);
          return prox * prox + prox + 1 + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Quadratic programming, second-order methods'
      },
      nuclear: {
        name: 'Nuclear Norm Approx',
        f: x => Math.sqrt(x * x + 0.01), // Smooth approximation
        prox: (v, lam) => {
          const norm = Math.sqrt(v * v + 0.01);
          return v * Math.max(0, 1 - lam / norm);
        },
        formula: '$$\\text{prox}_{\\lambda\\|\\cdot\\|_*}(v) \\approx v \\cdot \\max\\left(0, 1 - \\frac{\\lambda}{\\|v\\|_2}\\right)$$',
        description: 'Nuclear norm approximation - low-rank promotion',
        subdifferential: x => [x / Math.sqrt(x * x + 0.01)],
        moreauEnvelope: (v, lam) => {
          const prox = functions.nuclear.prox(v, lam);
          return Math.sqrt(prox * prox + 0.01) + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Matrix completion, low-rank approximation'
      },
      group: {
        name: 'Group LASSO Approx',
        f: x => Math.abs(x) + 0.1 * x * x, // Group penalty approximation
        prox: (v, lam) => {
          const group_norm = Math.abs(v);
          const shrink_factor = Math.max(0, 1 - lam / group_norm);
          return v * shrink_factor / (1 + 0.1 * lam);
        },
        formula: '$$\\text{Group shrinkage with quadratic correction}$$',
        description: 'Group LASSO approximation - group sparsity',
        subdifferential: x => [Math.sign(x) + 0.2 * x],
        moreauEnvelope: (v, lam) => {
          const prox = functions.group.prox(v, lam);
          return Math.abs(prox) + 0.1 * prox * prox + (1/(2*lam)) * (v - prox) * (v - prox);
        },
        applications: 'Group feature selection, structured sparsity'
      }
    };

    // Setup SVG
    function setupSVG() {
      const rect = container.getBoundingClientRect();
      svg.setAttribute('width', rect.width);
      svg.setAttribute('height', rect.height);
      svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
    }

    // Coordinate transformation
    function toSVG(x, y) {
      const rect = container.getBoundingClientRect();
      const margin = 40;
      const xRange = 6; // -3 to 3
      const yRange = 8; // -2 to 6
      
      const scaleX = (rect.width - 2 * margin) / xRange;
      const scaleY = (rect.height - 2 * margin) / yRange;
      
      return {
        x: margin + (x + 3) * scaleX,
        y: rect.height - margin - (y + 2) * scaleY
      };
    }

    // Compute proximal operator
    function computeProximal() {
      const func = functions[currentFunction];
      proximalPoint = func.prox(inputPoint, lambda);
      
      // Calculate objective value at proximal point
      const gValue = func.f(proximalPoint);
      const quadraticTerm = 0.5 * (proximalPoint - inputPoint) * (proximalPoint - inputPoint) / lambda;
      const objectiveValue = gValue + quadraticTerm;
      
      // Update display
      document.getElementById('proximalResult').textContent = proximalPoint.toFixed(4);
      document.getElementById('objectiveValue').textContent = objectiveValue.toFixed(4);
      document.getElementById('distanceValue').textContent = Math.abs(proximalPoint - inputPoint).toFixed(4);
      
      // Update formula
      document.getElementById('formulaText').textContent = func.formula;
      
      // Update interpretation
      updateInterpretation();
      
      // Redraw
      drawVisualization();
    }

    // Update interpretation text
    function updateInterpretation() {
      const func = functions[currentFunction];
      let interpretation = func.description;
      
      if (proximalPoint !== null) {
        const shrinkage = Math.abs(inputPoint - proximalPoint);
        const direction = proximalPoint < inputPoint ? 'toward zero' : 'away from zero';
        
        interpretation += `<br><br><strong>Current result:</strong> Input ${inputPoint.toFixed(2)} ‚Üí Proximal ${proximalPoint.toFixed(2)}`;
        interpretation += `<br>Shrinkage: ${shrinkage.toFixed(3)} units ${direction}`;
        
        if (currentFunction === 'l1') {
          interpretation += `<br>Soft thresholding with threshold Œª = ${lambda}`;
        } else if (currentFunction === 'indicator') {
          interpretation += `<br>Projected to feasible interval [-1, 1]`;
        }
      }
      
      document.getElementById('interpretationText').innerHTML = interpretation;
    }

    // Draw visualization
    function drawVisualization() {
      svg.innerHTML = '';
      
      // Draw grid
      if (document.getElementById('showGrid').checked) {
        drawGrid();
      }
      
      // Draw axes
      drawAxes();
      
      // Draw original function
      if (document.getElementById('showOriginal').checked) {
        drawFunction();
      }
      
      // Draw quadratic term
      if (document.getElementById('showQuadratic').checked) {
        drawQuadraticTerm();
      }
      
      // Draw Moreau envelope
      if (document.getElementById('showMoreau').checked) {
        drawMoreauEnvelope();
      }
      
      // Draw level curves
      if (document.getElementById('showLevelCurves').checked) {
        drawLevelCurves();
      }
      
      // Draw points and connections
      drawPoints();
      
      // Draw gradient
      if (document.getElementById('showGradient').checked && proximalPoint !== null) {
        drawGradient();
      }
    }

    // Draw grid
    function drawGrid() {
      for (let x = -3; x <= 3; x += 0.5) {
        const start = toSVG(x, -2);
        const end = toSVG(x, 6);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        line.setAttribute('class', x === 0 ? 'axis' : 'grid-line');
        svg.appendChild(line);
      }
      
      for (let y = -2; y <= 6; y += 0.5) {
        const start = toSVG(-3, y);
        const end = toSVG(3, y);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        line.setAttribute('class', y === 0 ? 'axis' : 'grid-line');
        svg.appendChild(line);
      }
    }

    // Draw axes
    function drawAxes() {
      // X-axis
      const xStart = toSVG(-3, 0);
      const xEnd = toSVG(3, 0);
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      xAxis.setAttribute('x1', xStart.x);
      xAxis.setAttribute('y1', xStart.y);
      xAxis.setAttribute('x2', xEnd.x);
      xAxis.setAttribute('y2', xEnd.y);
      xAxis.setAttribute('class', 'axis');
      svg.appendChild(xAxis);
      
      // Y-axis
      const yStart = toSVG(0, -2);
      const yEnd = toSVG(0, 6);
      const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      yAxis.setAttribute('x1', yStart.x);
      yAxis.setAttribute('y1', yStart.y);
      yAxis.setAttribute('x2', yEnd.x);
      yAxis.setAttribute('y2', yEnd.y);
      yAxis.setAttribute('class', 'axis');
      svg.appendChild(yAxis);
      
      // Labels
      const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      xLabel.setAttribute('x', toSVG(3, 0).x + 10);
      xLabel.setAttribute('y', toSVG(3, 0).y + 5);
      xLabel.setAttribute('class', 'label');
      xLabel.textContent = 'x';
      svg.appendChild(xLabel);
      
      const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      yLabel.setAttribute('x', toSVG(0, 6).x - 15);
      yLabel.setAttribute('y', toSVG(0, 6).y);
      yLabel.setAttribute('class', 'label');
      yLabel.textContent = 'g(x)';
      svg.appendChild(yLabel);
    }

    // Draw original function
    function drawFunction() {
      const func = functions[currentFunction];
      const points = [];
      
      for (let x = -3; x <= 3; x += 0.02) {
        const y = func.f(x);
        if (isFinite(y) && y <= 6) {
          const svgPoint = toSVG(x, Math.min(y, 6));
          points.push(`${svgPoint.x},${svgPoint.y}`);
        } else if (y === Infinity) {
          // Handle indicator function discontinuity
          if (points.length > 0) {
            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('points', points.join(' '));
            polyline.setAttribute('class', 'function-curve');
            svg.appendChild(polyline);
            points.length = 0;
          }
        }
      }
      
      if (points.length > 0) {
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points.join(' '));
        polyline.setAttribute('class', 'function-curve');
        svg.appendChild(polyline);
      }
      
      // Add function label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', toSVG(2, 5).x);
      label.setAttribute('y', toSVG(2, 5).y);
      label.setAttribute('class', 'label');
      label.setAttribute('fill', '#2196F3');
      label.textContent = `g(x) = ${func.name}`;
      svg.appendChild(label);
    }

    // Draw quadratic penalty term
    function drawQuadraticTerm() {
      const points = [];
      
      for (let x = -3; x <= 3; x += 0.02) {
        const y = 0.5 * (x - inputPoint) * (x - inputPoint) / lambda;
        if (y <= 6) {
          const svgPoint = toSVG(x, y);
          points.push(`${svgPoint.x},${svgPoint.y}`);
        }
      }
      
      const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
      polyline.setAttribute('points', points.join(' '));
      polyline.setAttribute('class', 'quadratic-term');
      svg.appendChild(polyline);
      
      // Add label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', toSVG(-2, 4).x);
      label.setAttribute('y', toSVG(-2, 4).y);
      label.setAttribute('class', 'label');
      label.setAttribute('fill', '#9C27B0');
      label.textContent = `¬Ω||x - v||¬≤/Œª`;
      svg.appendChild(label);
    }

    // Draw Moreau envelope
    function drawMoreauEnvelope() {
      const func = functions[currentFunction];
      const points = [];
      
      for (let x = -3; x <= 3; x += 0.02) {
        const prox = func.prox(x, lambda);
        const envelope = func.f(prox) + 0.5 * (prox - x) * (prox - x) / lambda;
        
        if (isFinite(envelope) && envelope <= 6) {
          const svgPoint = toSVG(x, envelope);
          points.push(`${svgPoint.x},${svgPoint.y}`);
        }
      }
      
      if (points.length > 0) {
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points.join(' '));
        polyline.setAttribute('class', 'proximal-function');
        svg.appendChild(polyline);
        
        // Add label
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', toSVG(-2, 2).x);
        label.setAttribute('y', toSVG(-2, 2).y);
        label.setAttribute('class', 'label');
        label.setAttribute('fill', '#FF9800');
        label.textContent = `Moreau envelope`;
        svg.appendChild(label);
      }
    }

    // Draw level curves of the proximal objective
    function drawLevelCurves() {
      const func = functions[currentFunction];
      const levels = [0.5, 1, 2, 3];
      
      levels.forEach((level, i) => {
        const points = [];
        
        for (let x = -3; x <= 3; x += 0.05) {
          const gx = func.f(x);
          const quadTerm = 0.5 * (x - inputPoint) * (x - inputPoint) / lambda;
          const totalValue = gx + quadTerm;
          
          if (isFinite(totalValue) && Math.abs(totalValue - level) < 0.1) {
            const svgPoint = toSVG(x, 0.1 * i - 1.5);
            points.push(`${svgPoint.x},${svgPoint.y}`);
          }
        }
        
        if (points.length > 1) {
          const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
          polyline.setAttribute('points', points.join(' '));
          polyline.setAttribute('class', 'level-curve');
          svg.appendChild(polyline);
        }
      });
    }

    // Draw points and connections
    function drawPoints() {
      // Input point
      const inputSVG = toSVG(inputPoint, 0);
      const inputCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      inputCircle.setAttribute('cx', inputSVG.x);
      inputCircle.setAttribute('cy', inputSVG.y);
      inputCircle.setAttribute('r', 6);
      inputCircle.setAttribute('class', 'input-point');
      svg.appendChild(inputCircle);
      
      // Input label
      const inputLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      inputLabel.setAttribute('x', inputSVG.x + 10);
      inputLabel.setAttribute('y', inputSVG.y - 10);
      inputLabel.setAttribute('class', 'label');
      inputLabel.textContent = `v = ${inputPoint.toFixed(2)}`;
      svg.appendChild(inputLabel);
      
      // Proximal point
      if (proximalPoint !== null) {
        const proxSVG = toSVG(proximalPoint, 0);
        const proxCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        proxCircle.setAttribute('cx', proxSVG.x);
        proxCircle.setAttribute('cy', proxSVG.y);
        proxCircle.setAttribute('r', 8);
        proxCircle.setAttribute('class', 'proximal-point');
        svg.appendChild(proxCircle);
        
        // Proximal label
        const proxLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        proxLabel.setAttribute('x', proxSVG.x + 10);
        proxLabel.setAttribute('y', proxSVG.y + 20);
        proxLabel.setAttribute('class', 'label');
        proxLabel.textContent = `prox = ${proximalPoint.toFixed(2)}`;
        svg.appendChild(proxLabel);
        
        // Connection line
        const connection = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        connection.setAttribute('x1', inputSVG.x);
        connection.setAttribute('y1', inputSVG.y);
        connection.setAttribute('x2', proxSVG.x);
        connection.setAttribute('y2', proxSVG.y);
        connection.setAttribute('class', 'connection-line');
        svg.appendChild(connection);
        
        // Show point on function
        const func = functions[currentFunction];
        const funcValue = func.f(proximalPoint);
        if (isFinite(funcValue) && funcValue <= 6) {
          const funcPoint = toSVG(proximalPoint, funcValue);
          const funcCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          funcCircle.setAttribute('cx', funcPoint.x);
          funcCircle.setAttribute('cy', funcPoint.y);
          funcCircle.setAttribute('r', 4);
          funcCircle.setAttribute('fill', '#4CAF50');
          funcCircle.setAttribute('stroke', 'white');
          funcCircle.setAttribute('stroke-width', '1');
          svg.appendChild(funcCircle);
        }
      }
    }

    // Draw gradient
    function drawGradient() {
      if (proximalPoint === null) return;
      
      const func = functions[currentFunction];
      const subdiff = func.subdifferential(proximalPoint);
      
      // For simplicity, just show direction of gradient/subgradient
      const grad = Array.isArray(subdiff) ? subdiff[0] : subdiff;
      
      const startPoint = toSVG(proximalPoint, 0);
      const endPoint = toSVG(proximalPoint + 0.3 * Math.sign(grad), 0.3 * Math.abs(grad));
      
      const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      arrow.setAttribute('x1', startPoint.x);
      arrow.setAttribute('y1', startPoint.y);
      arrow.setAttribute('x2', endPoint.x);
      arrow.setAttribute('y2', endPoint.y);
      arrow.setAttribute('class', 'gradient-arrow');
      svg.appendChild(arrow);
      
      // Arrow head
      const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
      const arrowLength = 8;
      const arrowAngle = Math.PI / 6;
      
      const arrow1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      arrow1.setAttribute('x1', endPoint.x);
      arrow1.setAttribute('y1', endPoint.y);
      arrow1.setAttribute('x2', endPoint.x - arrowLength * Math.cos(angle - arrowAngle));
      arrow1.setAttribute('y2', endPoint.y - arrowLength * Math.sin(angle - arrowAngle));
      arrow1.setAttribute('class', 'gradient-arrow');
      svg.appendChild(arrow1);
      
      const arrow2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      arrow2.setAttribute('x1', endPoint.x);
      arrow2.setAttribute('y1', endPoint.y);
      arrow2.setAttribute('x2', endPoint.x - arrowLength * Math.cos(angle + arrowAngle));
      arrow2.setAttribute('y2', endPoint.y - arrowLength * Math.sin(angle + arrowAngle));
      arrow2.setAttribute('class', 'gradient-arrow');
      svg.appendChild(arrow2);
    }

    // Animate lambda
    async function animateLambda() {
      if (isAnimating) return;
      
      isAnimating = true;
      document.getElementById('animateBtn').disabled = true;
      
      const originalLambda = lambda;
      
      // Animate from 0.1 to 2 and back
      for (let l = 0.1; l <= 2; l += 0.05) {
        lambda = l;
        document.getElementById('lambda').value = lambda;
        document.getElementById('lambdaValue').textContent = lambda.toFixed(2);
        document.getElementById('currentLambda').textContent = lambda.toFixed(2);
        computeProximal();
        await new Promise(resolve => setTimeout(resolve, 50));
        if (!isAnimating) break;
      }
      
      for (let l = 2; l >= 0.1; l -= 0.05) {
        lambda = l;
        document.getElementById('lambda').value = lambda;
        document.getElementById('lambdaValue').textContent = lambda.toFixed(2);
        document.getElementById('currentLambda').textContent = lambda.toFixed(2);
        computeProximal();
        await new Promise(resolve => setTimeout(resolve, 50));
        if (!isAnimating) break;
      }
      
      // Restore original lambda
      lambda = originalLambda;
      document.getElementById('lambda').value = lambda;
      document.getElementById('lambdaValue').textContent = lambda.toFixed(2);
      document.getElementById('currentLambda').textContent = lambda.toFixed(2);
      computeProximal();
      
      isAnimating = false;
      document.getElementById('animateBtn').disabled = false;
    }

    // Event listeners
    document.getElementById('functionSelect').addEventListener('change', (e) => {
      currentFunction = e.target.value;
      document.getElementById('functionName').textContent = functions[currentFunction].name;
      if (proximalPoint !== null) {
        computeProximal();
      } else {
        drawVisualization();
      }
    });

    document.getElementById('inputPoint').addEventListener('input', (e) => {
      inputPoint = parseFloat(e.target.value);
      document.getElementById('inputPointValue').textContent = inputPoint.toFixed(1);
      document.getElementById('currentInput').textContent = inputPoint.toFixed(2);
      if (proximalPoint !== null) {
        computeProximal();
      } else {
        drawVisualization();
      }
    });

    document.getElementById('lambda').addEventListener('input', (e) => {
      lambda = parseFloat(e.target.value);
      document.getElementById('lambdaValue').textContent = lambda.toFixed(1);
      document.getElementById('currentLambda').textContent = lambda.toFixed(2);
      if (proximalPoint !== null) {
        computeProximal();
      }
    });

    document.getElementById('computeBtn').addEventListener('click', computeProximal);
    document.getElementById('animateBtn').addEventListener('click', animateLambda);

    document.getElementById('resetBtn').addEventListener('click', () => {
      isAnimating = false;
      proximalPoint = null;
      document.getElementById('proximalResult').textContent = '-';
      document.getElementById('objectiveValue').textContent = '-';
      document.getElementById('distanceValue').textContent = '-';
      document.getElementById('formulaText').textContent = 'Select a function to see formula';
      document.getElementById('interpretationText').textContent = 'The proximal operator "shrinks" or "projects" the input point toward regions where g(x) is small, balanced by staying close to the original point.';
      drawVisualization();
    });

    // Checkbox event listeners
    ['showOriginal', 'showQuadratic', 'showMoreau', 'showGradient', 'showLevelCurves', 'showGrid'].forEach(id => {
      document.getElementById(id).addEventListener('change', drawVisualization);
    });

    // Mouse interaction
    svg.addEventListener('click', (event) => {
      const rect = svg.getBoundingClientRect();
      const svgX = event.clientX - rect.left;
      const mouseX = (svgX - 40) * 6 / (rect.width - 80) - 3;
      
      if (mouseX >= -3 && mouseX <= 3) {
        inputPoint = mouseX;
        document.getElementById('inputPoint').value = inputPoint;
        document.getElementById('inputPointValue').textContent = inputPoint.toFixed(1);
        document.getElementById('currentInput').textContent = inputPoint.toFixed(2);
        
        if (proximalPoint !== null) {
          computeProximal();
        } else {
          drawVisualization();
        }
      }
    });

    // Window resize
    window.addEventListener('resize', () => {
      setupSVG();
      drawVisualization();
    });

    // Initialize
    setupSVG();
    document.getElementById('functionName').textContent = functions[currentFunction].name;
    document.getElementById('currentInput').textContent = inputPoint.toFixed(2);
    document.getElementById('currentLambda').textContent = lambda.toFixed(2);
    drawVisualization();
  </script>
</body>
</html>
