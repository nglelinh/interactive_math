<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Numbers in Audio Processing - Advanced Applications - Interactive Math</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4fc3f7;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        h2 {
            color: #81c784;
            border-bottom: 2px solid #81c784;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        
        h3 {
            color: #ffb74d;
            margin-top: 30px;
        }
        
        .theory-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #4fc3f7;
        }
        
        .example-section {
            background: rgba(129, 199, 132, 0.2);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #81c784;
        }
        
        .interactive-demo {
            background: rgba(255, 183, 77, 0.2);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #ffb74d;
        }
        
        .controls-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            color: #b3e5fc;
            font-weight: bold;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #37474f;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        select {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #4fc3f7;
            border-radius: 5px;
            padding: 8px;
            font-size: 14px;
        }

        select option {
            background: #1a1a2e;
            color: white;
        }
        
        button {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
        }
        
        button:hover {
            background: linear-gradient(45deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.4);
        }
        
        .math-formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 3px solid #4fc3f7;
        }
        
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .plot-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            height: 400px;
        }
        
        .single-plot {
            grid-column: span 2;
            height: 500px;
        }
        
        .audio-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .value-display {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 16px;
        }

        .navigation-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 40px 0;
            border-left: 4px solid #ff7043;
            text-align: center;
        }

        .nav-button {
            background: linear-gradient(45deg, #ff7043, #ff5722);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 112, 67, 0.3);
            margin: 10px;
            text-decoration: none;
            display: inline-block;
        }

        .nav-button:hover {
            background: linear-gradient(45deg, #ff5722, #e64a19);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 112, 67, 0.4);
        }
        
        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
            .single-plot {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Complex Numbers in Audio Processing - Advanced Applications</h1>
        
        <div class="navigation-section">
            <h3>üìö Tutorial Series Navigation</h3>
            <p>This is <strong>Part 2</strong> of our comprehensive guide to complex numbers in audio processing.</p>
            <a href="complex_numbers_audio_fundamentals.html" class="nav-button">üìñ Part 1: Fundamentals</a>
            <a href="complex_numbers_audio_advanced.html" class="nav-button">üöÄ Part 2: Advanced Applications (Current)</a>
        </div>

        <div class="example-section">
            <h2>üéöÔ∏è Digital Filters and Complex Transfer Functions</h2>
            <p><strong>The Power of Complex Transfer Functions:</strong> Digital filters are the workhorses of audio processing, from simple bass/treble controls to sophisticated noise reduction. They're described mathematically by complex transfer functions H(z), where z is a complex variable representing frequency.</p>
            
            <p><strong>Understanding the Z-Transform:</strong> The z-transform extends the concept of Fourier transforms to discrete-time systems. When we substitute z = e^(jœâ) (points on the unit circle), we get the frequency response H(e^(jœâ)) that tells us exactly how the filter affects each frequency.</p>
            
            <div class="math-formula">
                <h4>Transfer Function:</h4>
                $$H(z) = \frac{b_0 + b_1z^{-1} + b_2z^{-2} + ...}{1 + a_1z^{-1} + a_2z^{-2} + ...}$$
                <p><strong>Component Explanation:</strong></p>
                <ul>
                    <li><strong>Numerator coefficients (b_k):</strong> Control zeros - frequencies that get completely blocked</li>
                    <li><strong>Denominator coefficients (a_k):</strong> Control poles - frequencies that get resonant peaks</li>
                    <li><strong>z^(-k):</strong> Represents k-sample delays in the time domain</li>
                </ul>
                
                <h4>Frequency Response:</h4>
                $$H(e^{j\omega}) = H(z)|_{z=e^{j\omega}}$$
                <p><strong>Complex Frequency Response Properties:</strong></p>
                <ul>
                    <li><strong>Magnitude |H(e^(jœâ))|:</strong> How much each frequency is amplified/attenuated</li>
                    <li><strong>Phase ‚à†H(e^(jœâ)):</strong> How much each frequency is delayed (phase shift)</li>
                    <li><strong>Group Delay:</strong> -d‚à†H(e^(jœâ))/dœâ - perceptually important for audio quality</li>
                </ul>
            </div>
            
            <p><strong>Pole-Zero Analysis:</strong></p>
            <ul>
                <li><strong>Poles (denominator roots):</strong> Create resonant peaks in the frequency response. Poles close to the unit circle create sharp, high-Q resonances</li>
                <li><strong>Zeros (numerator roots):</strong> Create notches (attenuation) in the frequency response. Zeros on the unit circle create perfect nulls</li>
                <li><strong>Stability:</strong> All poles must be inside the unit circle for a stable filter</li>
                <li><strong>Filter Design:</strong> Place poles/zeros strategically to achieve desired frequency response</li>
            </ul>
            
            <p><strong>Real-world Filter Applications:</strong></p>
            <ul>
                <li><strong>Equalizers:</strong> Multiple bandpass/shelf filters with adjustable gain</li>
                <li><strong>Crossovers:</strong> Split audio into frequency bands for different speakers</li>
                <li><strong>De-essing:</strong> Notch filters to reduce harsh 's' sounds in vocals</li>
                <li><strong>Rumble filters:</strong> High-pass filters to remove low-frequency noise</li>
                <li><strong>Anti-aliasing:</strong> Low-pass filters to prevent frequency folding in digital systems</li>
                <li><strong>Echo cancellation:</strong> Adaptive filters that learn and cancel acoustic echoes</li>
            </ul>
            
            <p><strong>Why Complex Math Is Crucial:</strong> Audio filters must preserve both the amplitude relationships AND the phase relationships between frequency components. Complex transfer functions capture both aspects, ensuring that filtered audio maintains its natural timbre and spatial characteristics.</p>
        </div>

        <div class="interactive-demo">
            <h2>üîç Interactive Demo: Digital Filter Analysis</h2>
            <p><strong>Filter Design in Action:</strong> This demo lets you design and analyze digital filters by manipulating their complex transfer functions. You'll see how mathematical concepts translate directly into audible effects.</p>
            
            <p><strong>Filter Types and Their Mathematics:</strong></p>
            <ul>
                <li><strong>Low-pass:</strong> Allows low frequencies to pass through. Poles near DC (z=1), zeros at high frequencies (z=-1)</li>
                <li><strong>High-pass:</strong> Allows high frequencies to pass through. Zeros near DC, poles at high frequencies</li>
                <li><strong>Band-pass:</strong> Allows a specific frequency range. Poles near the desired frequency, zeros at DC and Nyquist</li>
                <li><strong>Notch (Band-stop):</strong> Rejects a specific frequency range. Zeros at the rejected frequency, poles nearby for sharpness</li>
            </ul>
            
            <p><strong>Key Parameters:</strong></p>
            <ul>
                <li><strong>Cutoff Frequency:</strong> Determines where poles/zeros are placed in the complex plane</li>
                <li><strong>Q Factor:</strong> Controls filter sharpness - higher Q means poles closer to unit circle, creating sharper response</li>
                <li><strong>Gain:</strong> Overall amplification, controlled by the ratio of numerator to denominator magnitudes</li>
            </ul>
            
            <div class="controls-panel">
                <div class="control-group">
                    <label for="filter-type">Filter Type:</label>
                    <select id="filter-type" onchange="updateFilter()">
                        <option value="lowpass">Low Pass</option>
                        <option value="highpass">High Pass</option>
                        <option value="bandpass">Band Pass</option>
                        <option value="notch">Notch</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cutoff-freq">Cutoff Frequency (Hz): <span id="cutoff-value" class="value-display">1000</span></label>
                    <input type="range" id="cutoff-freq" min="100" max="4000" value="1000" step="50">
                </div>
                <div class="control-group">
                    <label for="filter-q">Q Factor: <span id="q-value" class="value-display">1.0</span></label>
                    <input type="range" id="filter-q" min="0.5" max="10" value="1.0" step="0.1">
                </div>
            </div>
            
            <div class="audio-controls">
                <button onclick="applyFilter()">üéõÔ∏è Apply Filter to Test Signal</button>
                <button onclick="playFilteredAudio()">üîä Play Filtered Audio</button>
            </div>
            
            <div class="visualization-container">
                <div class="plot-container">
                    <div id="filter-response-plot"></div>
                </div>
                <div class="plot-container">
                    <div id="pole-zero-plot"></div>
                </div>
            </div>
        </div>

        <div class="example-section">
            <h2>üåä Spectrograms and Time-Frequency Analysis</h2>
            <p><strong>Beyond Static Frequency Analysis:</strong> While the DFT tells us "what frequencies are present," it doesn't tell us "when they occur." The Short-Time Fourier Transform (STFT) solves this by applying the DFT to short, overlapping windows of the signal, creating a time-frequency representation called a spectrogram.</p>
            
            <p><strong>The STFT Process:</strong> Imagine sliding a "magnifying glass" (window function) across your audio signal, taking a "frequency snapshot" at each position. Each snapshot is a complex DFT that captures both magnitude and phase information for that time slice.</p>
            
            <div class="math-formula">
                <h4>STFT Formula:</h4>
                $$X[m,k] = \sum_{n=0}^{N-1} x[n+mH] \cdot w[n] \cdot e^{-j2\pi kn/N}$$
                <p><strong>Parameter Breakdown:</strong></p>
                <ul>
                    <li><strong>m:</strong> Time frame index (which "snapshot" in time)</li>
                    <li><strong>k:</strong> Frequency bin index (which frequency component)</li>
                    <li><strong>H:</strong> Hop size (how far to move the window each time)</li>
                    <li><strong>w[n]:</strong> Window function (typically Hann or Hamming) - tapers edges to reduce artifacts</li>
                    <li><strong>N:</strong> Window size - determines frequency resolution vs. time resolution trade-off</li>
                </ul>
                
                <h4>Time-Frequency Trade-off (Uncertainty Principle):</h4>
                $$\Delta t \cdot \Delta f \geq \frac{1}{4\pi}$$
                <p><strong>Practical Implications:</strong></p>
                <ul>
                    <li><strong>Large window (large N):</strong> Good frequency resolution, poor time resolution</li>
                    <li><strong>Small window (small N):</strong> Good time resolution, poor frequency resolution</li>
                    <li><strong>Overlap:</strong> Hop size H < N provides smoother time evolution</li>
                </ul>
            </div>
            
            <p><strong>Complex STFT Coefficients:</strong></p>
            <ul>
                <li><strong>Magnitude |X[m,k]|:</strong> Creates the spectrogram - brightness indicates how much of frequency k is present at time m</li>
                <li><strong>Phase ‚à†X[m,k]:</strong> Critical for reconstruction and advanced processing like phase vocoding</li>
                <li><strong>Instantaneous Frequency:</strong> Derivative of phase over time reveals how frequency changes</li>
                <li><strong>Group Delay:</strong> Derivative of phase over frequency shows temporal characteristics</li>
            </ul>
            
            <p><strong>Real-world Spectrogram Applications:</strong></p>
            <ul>
                <li><strong>Speech Recognition:</strong> Convert speech to visual patterns for machine learning algorithms</li>
                <li><strong>Music Transcription:</strong> Identify notes, chords, and instruments from their spectral signatures</li>
                <li><strong>Audio Forensics:</strong> Detect edited regions, identify speakers, reveal hidden information</li>
                <li><strong>Bioacoustics:</strong> Analyze animal communication patterns (whale songs, bird calls)</li>
                <li><strong>Medical Diagnosis:</strong> Analyze heart sounds, respiratory patterns, brain signals</li>
                <li><strong>Vibration Analysis:</strong> Detect mechanical faults in rotating machinery</li>
                <li><strong>Seismic Analysis:</strong> Earthquake detection and geological surveying</li>
            </ul>
        </div>

        <div class="interactive-demo">
            <h2>üìà Interactive Demo: Spectrogram Generation</h2>
            <p><strong>Time-Frequency Analysis in Practice:</strong> This demo demonstrates how different types of audio signals create distinctive spectrogram patterns. Each signal type reveals different aspects of time-frequency analysis and shows why spectrograms are so powerful for audio understanding.</p>
            
            <p><strong>Signal Types and Their Spectral Signatures:</strong></p>
            <ul>
                <li><strong>Frequency Sweep (Chirp):</strong> Shows diagonal line from low to high frequency, revealing linear frequency progression</li>
                <li><strong>Multiple Tones:</strong> Shows horizontal lines at specific frequencies, revealing harmonic relationships</li>
                <li><strong>Synthetic Music Chord:</strong> Shows multiple horizontal lines changing over time (chord progressions)</li>
                <li><strong>Colored Noise:</strong> Shows broadband energy with frequency-dependent intensity patterns</li>
            </ul>
            
            <div class="controls-panel">
                <div class="control-group">
                    <label for="signal-type">Signal Type:</label>
                    <select id="signal-type" onchange="generateSpectrogram()">
                        <option value="chirp">Frequency Sweep (Chirp)</option>
                        <option value="multitone">Multiple Tones</option>
                        <option value="music">Synthetic Music Chord</option>
                        <option value="noise">Colored Noise</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="window-size">Window Size: <span id="window-value" class="value-display">512</span></label>
                    <input type="range" id="window-size" min="256" max="2048" value="512" step="256">
                </div>
                <div class="control-group">
                    <label for="hop-size">Hop Size: <span id="hop-value" class="value-display">128</span></label>
                    <input type="range" id="hop-size" min="64" max="512" value="128" step="64">
                </div>
            </div>
            
            <div class="audio-controls">
                <button onclick="generateSpectrogram()">üîÑ Generate Spectrogram</button>
                <button onclick="playSpectrogramAudio()">üîä Play Signal</button>
            </div>
            
            <div class="visualization-container">
                <div class="plot-container single-plot">
                    <div id="spectrogram-plot"></div>
                </div>
            </div>
        </div>

        <div class="example-section">
            <h2>üéº Audio Effects Using Complex Numbers</h2>
            <p><strong>Spectral Audio Processing Revolution:</strong> Modern audio effects work by manipulating complex frequency-domain representations rather than time-domain samples. This approach enables effects that would be impossible or computationally prohibitive in the time domain.</p>
            
            <p><strong>The Frequency Domain Processing Pipeline:</strong></p>
            <ol>
                <li><strong>Analysis:</strong> Convert audio to complex STFT coefficients X[m,k]</li>
                <li><strong>Manipulation:</strong> Modify magnitude |X[m,k]| and/or phase ‚à†X[m,k]|</li>
                <li><strong>Synthesis:</strong> Convert back to time domain via inverse STFT</li>
            </ol>
            
            <div class="math-formula">
                <h4>Frequency Domain Processing:</h4>
                $$Y[m,k] = H[m,k] \cdot X[m,k]$$
                <p><strong>Where:</strong></p>
                <ul>
                    <li><strong>X[m,k]:</strong> Input complex spectrum (time m, frequency k)</li>
                    <li><strong>H[m,k]:</strong> Complex effect transfer function</li>
                    <li><strong>Y[m,k]:</strong> Output complex spectrum</li>
                </ul>
                
                <h4>Magnitude and Phase Manipulation:</h4>
                $$Y[m,k] = |Y[m,k]| \cdot e^{j\angle Y[m,k]}$$
                <p><strong>Independent Control:</strong></p>
                <ul>
                    <li><strong>Magnitude |Y[m,k]|:</strong> Controls spectral envelope (timbre)</li>
                    <li><strong>Phase ‚à†Y[m,k]:</strong> Controls temporal structure and spatial imaging</li>
                </ul>
            </div>
            
            <p><strong>Advanced Spectral Effects:</strong></p>
            <ul>
                <li><strong>Pitch Shifting:</strong> Shift frequency bins while preserving phase relationships for auto-tune and harmony generation</li>
                <li><strong>Time Stretching (Phase Vocoder):</strong> Modify phase evolution rate while keeping magnitudes for tempo change without pitch change</li>
                <li><strong>Spectral Filtering:</strong> Perfect linear phase filtering impossible with time-domain IIR filters</li>
                <li><strong>Spectral Gating/Noise Reduction:</strong> Attenuate frequencies below threshold using psychoacoustic modeling</li>
                <li><strong>Phase Scrambling/Vocoding:</strong> Create noise-like textures and robotic voices for sound design</li>
            </ul>
        </div>

        <div class="interactive-demo">
            <h2>üé® Interactive Demo: Spectral Audio Effects</h2>
            <p><strong>Advanced Spectral Manipulation:</strong> This demo showcases how professional audio effects manipulate complex STFT coefficients to create sophisticated sonic transformations. Each effect demonstrates a different aspect of complex number manipulation in audio processing.</p>
            
            <p><strong>Effect Types and Their Complex Mathematics:</strong></p>
            <ul>
                <li><strong>Pitch Shift:</strong> Resampling the frequency axis with phase correction</li>
                <li><strong>Spectral Gate:</strong> Threshold-based magnitude attenuation while preserving phase</li>
                <li><strong>Phase Scrambling:</strong> Randomizing phase while keeping magnitude spectrum</li>
                <li><strong>Spectral Delay:</strong> Frequency-dependent time delays using complex multiplication</li>
            </ul>
            
            <div class="controls-panel">
                <div class="control-group">
                    <label for="effect-type">Effect Type:</label>
                    <select id="effect-type" onchange="updateEffect()">
                        <option value="none">No Effect</option>
                        <option value="pitch-shift">Pitch Shift</option>
                        <option value="spectral-gate">Spectral Gate</option>
                        <option value="phase-scramble">Phase Scrambling</option>
                        <option value="spectral-delay">Spectral Delay</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="effect-amount">Effect Amount: <span id="effect-amount-value" class="value-display">0.5</span></label>
                    <input type="range" id="effect-amount" min="0" max="1" value="0.5" step="0.1">
                </div>
                <div class="control-group">
                    <label for="mix-level">Dry/Wet Mix: <span id="mix-value" class="value-display">0.5</span></label>
                    <input type="range" id="mix-level" min="0" max="1" value="0.5" step="0.1">
                </div>
            </div>
            
            <div class="audio-controls">
                <button onclick="generateTestTone()">üéµ Generate Test Tone</button>
                <button onclick="applySpectralEffect()">‚ö° Apply Effect</button>
                <button onclick="playOriginal()">üîä Play Original</button>
                <button onclick="playProcessed()">üîä Play Processed</button>
            </div>
            
            <div class="visualization-container">
                <div class="plot-container">
                    <div id="original-spectrum-plot"></div>
                </div>
                <div class="plot-container">
                    <div id="processed-spectrum-plot"></div>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h2>üî¨ Advanced Applications</h2>
            
            <h3>1. Convolution and Complex Multiplication</h3>
            <div class="math-formula">
                $$y[n] = x[n] * h[n] \Leftrightarrow Y[k] = X[k] \cdot H[k]$$
                <p>Convolution in time domain equals multiplication in frequency domain - fundamental for real-time audio processing.</p>
            </div>
            
            <h3>2. Hilbert Transform and Analytic Signals</h3>
            <div class="math-formula">
                $$x_a(t) = x(t) + j\mathcal{H}\{x(t)\}$$
                <p>Creates complex-valued analytic signals used in AM/FM demodulation and envelope detection.</p>
            </div>
            
            <h3>3. Adaptive Filtering</h3>
            <p>Complex LMS algorithms for noise cancellation and echo suppression in telecommunications.</p>
            
            <h3>4. Spatial Audio Processing</h3>
            <p>Complex numbers represent directional information in surround sound and binaural audio processing.</p>
            
            <h3>5. Music Information Retrieval</h3>
            <p>Chromagrams, constant-Q transforms, and harmonic analysis all rely on complex spectral representations.</p>
        </div>

        <div class="example-section">
            <h2>üéØ Real-World Examples Summary</h2>
            
            <h3>üéß Digital Audio Workstations (DAWs)</h3>
            <ul>
                <li><strong>EQ Plugins:</strong> Use complex transfer functions to shape frequency response</li>
                <li><strong>Reverb Effects:</strong> Convolution with complex impulse responses</li>
                <li><strong>Time Stretching:</strong> Phase vocoder algorithms preserve audio quality</li>
            </ul>
            
            <h3>üì± Streaming and Compression</h3>
            <ul>
                <li><strong>MP3 Encoding:</strong> Modified DCT using complex transforms for psychoacoustic modeling</li>
                <li><strong>Perceptual Coding:</strong> Complex spectral analysis for bit allocation</li>
                <li><strong>Error Correction:</strong> Complex channel coding for robust transmission</li>
            </ul>
            
            <h3>üéôÔ∏è Speech Processing</h3>
            <ul>
                <li><strong>Voice Recognition:</strong> Complex cepstral analysis and MFCC features</li>
                <li><strong>Speech Enhancement:</strong> Spectral subtraction using complex noise estimation</li>
                <li><strong>Vocoder Technology:</strong> Phase vocoder for voice transformation</li>
            </ul>
            
            <h3>üéµ Music Technology</h3>
            <ul>
                <li><strong>Auto-Tune:</strong> Complex pitch detection and frequency domain correction</li>
                <li><strong>Beat Detection:</strong> Complex wavelet transforms for rhythm analysis</li>
                <li><strong>Instrument Separation:</strong> Complex matrix factorization techniques</li>
            </ul>
        </div>

        <div class="navigation-section">
            <h3>üéØ Congratulations!</h3>
            <p>You've completed our comprehensive guide to complex numbers in audio processing! You now understand both the fundamentals and advanced applications of this powerful mathematical tool in modern audio technology.</p>
            <a href="complex_numbers_audio_fundamentals.html" class="nav-button">üîÑ Review Part 1: Fundamentals</a>
            <a href="index.html" class="nav-button">üè† Return to Complex Analysis Home</a>
        </div>
    </div>

    <script>
        // Global variables for audio context and data
        let audioContext;
        let isPlaying1 = false;
        let isPlaying2 = false;
        let animationFrame;
        let currentTime = 0;
        let oscillator1, oscillator2;
        
        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Complex number operations
        class Complex {
            constructor(real, imag) {
                this.real = real;
                this.imag = imag;
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
            
            phase() {
                return Math.atan2(this.imag, this.real);
            }
            
            multiply(other) {
                return new Complex(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
        }

        // Update value displays
        function updateValueDisplays() {
            document.getElementById('cutoff-value').textContent = document.getElementById('cutoff-freq').value;
            document.getElementById('q-value').textContent = document.getElementById('filter-q').value;
            document.getElementById('window-value').textContent = document.getElementById('window-size').value;
            document.getElementById('hop-value').textContent = document.getElementById('hop-size').value;
            document.getElementById('effect-amount-value').textContent = document.getElementById('effect-amount').value;
            document.getElementById('mix-value').textContent = document.getElementById('mix-level').value;
            
            updateFilter();
            generateSpectrogram();
        }

        // Filter analysis
        function updateFilter() {
            const filterType = document.getElementById('filter-type').value;
            const cutoffFreq = parseFloat(document.getElementById('cutoff-freq').value);
            const qFactor = parseFloat(document.getElementById('filter-q').value);
            const sampleRate = 8192;
            
            // Generate frequency response
            const freqPoints = 1024;
            const frequencies = [];
            const magnitudeResponse = [];
            const phaseResponse = [];
            const poles = [];
            const zeros = [];
            
            for (let i = 0; i < freqPoints; i++) {
                const freq = (i / freqPoints) * (sampleRate / 2);
                frequencies.push(freq);
                
                // Normalized frequency
                const omega = 2 * Math.PI * freq / sampleRate;
                
                // Simplified filter response calculation
                let magnitude, phase;
                
                switch (filterType) {
                    case 'lowpass':
                        const lpCutoff = 2 * Math.PI * cutoffFreq / sampleRate;
                        magnitude = 1 / Math.sqrt(1 + Math.pow(omega / lpCutoff, 2 * qFactor));
                        phase = -Math.atan(Math.pow(omega / lpCutoff, qFactor));
                        if (i === 0) {
                            poles.push({x: 0.8 * Math.cos(lpCutoff), y: 0.8 * Math.sin(lpCutoff)});
                            poles.push({x: 0.8 * Math.cos(lpCutoff), y: -0.8 * Math.sin(lpCutoff)});
                            zeros.push({x: -1, y: 0});
                        }
                        break;
                        
                    case 'highpass':
                        const hpCutoff = 2 * Math.PI * cutoffFreq / sampleRate;
                        magnitude = (omega / hpCutoff) / Math.sqrt(1 + Math.pow(omega / hpCutoff, 2 * qFactor));
                        phase = Math.PI/2 - Math.atan(Math.pow(hpCutoff / omega, qFactor));
                        if (i === 0) {
                            poles.push({x: -0.8 * Math.cos(hpCutoff), y: 0.8 * Math.sin(hpCutoff)});
                            poles.push({x: -0.8 * Math.cos(hpCutoff), y: -0.8 * Math.sin(hpCutoff)});
                            zeros.push({x: 1, y: 0});
                        }
                        break;
                        
                    case 'bandpass':
                        const bpCenterFreq = 2 * Math.PI * cutoffFreq / sampleRate;
                        const bpQ = qFactor;
                        const bandwidth = bpCenterFreq / bpQ;
                        magnitude = (bandwidth * omega) / 
                                   Math.sqrt(Math.pow(omega * omega - bpCenterFreq * bpCenterFreq, 2) + 
                                            Math.pow(bandwidth * omega, 2));
                        phase = Math.atan2(bandwidth * omega, omega * omega - bpCenterFreq * bpCenterFreq);
                        if (i === 0) {
                            const radius = 0.9;
                            poles.push({x: radius * Math.cos(bpCenterFreq), y: radius * Math.sin(bpCenterFreq)});
                            poles.push({x: radius * Math.cos(bpCenterFreq), y: -radius * Math.sin(bpCenterFreq)});
                            zeros.push({x: 1, y: 0});
                            zeros.push({x: -1, y: 0});
                        }
                        break;
                        
                    case 'notch':
                        const notchFreq = 2 * Math.PI * cutoffFreq / sampleRate;
                        const notchQ = qFactor;
                        magnitude = Math.sqrt(Math.pow(omega * omega - notchFreq * notchFreq, 2)) / 
                                   Math.sqrt(Math.pow(omega * omega - notchFreq * notchFreq, 2) + 
                                            Math.pow(notchFreq * omega / notchQ, 2));
                        phase = Math.atan2(notchFreq * omega / notchQ, omega * omega - notchFreq * notchFreq);
                        if (i === 0) {
                            zeros.push({x: Math.cos(notchFreq), y: Math.sin(notchFreq)});
                            zeros.push({x: Math.cos(notchFreq), y: -Math.sin(notchFreq)});
                            poles.push({x: 0.8 * Math.cos(notchFreq), y: 0.8 * Math.sin(notchFreq)});
                            poles.push({x: 0.8 * Math.cos(notchFreq), y: -0.8 * Math.sin(notchFreq)});
                        }
                        break;
                        
                    default:
                        magnitude = 1;
                        phase = 0;
                }
                
                magnitudeResponse.push(20 * Math.log10(magnitude + 1e-10));
                phaseResponse.push(phase * 180 / Math.PI);
            }
            
            // Plot frequency response
            const magTrace = {
                x: frequencies,
                y: magnitudeResponse,
                mode: 'lines',
                type: 'scatter',
                name: 'Magnitude',
                line: {color: '#4fc3f7', width: 3}
            };
            
            const phaseTrace = {
                x: frequencies,
                y: phaseResponse,
                mode: 'lines',
                type: 'scatter',
                name: 'Phase',
                line: {color: '#ff7043', width: 3},
                yaxis: 'y2'
            };
            
            Plotly.newPlot('filter-response-plot', [magTrace, phaseTrace], {
                title: `${filterType.charAt(0).toUpperCase() + filterType.slice(1)} Filter Response`,
                xaxis: {title: 'Frequency (Hz)', type: 'log'},
                yaxis: {title: 'Magnitude (dB)', color: '#4fc3f7'},
                yaxis2: {title: 'Phase (degrees)', side: 'right', overlaying: 'y', color: '#ff7043'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                showlegend: true
            });
            
            // Plot pole-zero diagram
            const unitCircle = [];
            for (let i = 0; i <= 100; i++) {
                const angle = 2 * Math.PI * i / 100;
                unitCircle.push({x: Math.cos(angle), y: Math.sin(angle)});
            }
            
            const circleTrace = {
                x: unitCircle.map(p => p.x),
                y: unitCircle.map(p => p.y),
                mode: 'lines',
                type: 'scatter',
                name: 'Unit Circle',
                line: {color: '#81c784', width: 2, dash: 'dash'}
            };
            
            const poleTrace = {
                x: poles.map(p => p.x),
                y: poles.map(p => p.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Poles',
                marker: {symbol: 'x', size: 15, color: '#ff5722', line: {width: 3}}
            };
            
            const zeroTrace = {
                x: zeros.map(z => z.x),
                y: zeros.map(z => z.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Zeros',
                marker: {symbol: 'circle-open', size: 12, color: '#2196f3', line: {width: 3}}
            };
            
            Plotly.newPlot('pole-zero-plot', [circleTrace, poleTrace, zeroTrace], {
                title: 'Pole-Zero Diagram',
                xaxis: {title: 'Real Part', range: [-1.5, 1.5]},
                yaxis: {title: 'Imaginary Part', range: [-1.5, 1.5]},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'},
                showlegend: true
            });
        }

        // DFT computation for spectrogram
        function computeDFT(signal) {
            const N = signal.length;
            const spectrum = [];
            
            for (let k = 0; k < N / 2; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                
                spectrum.push(new Complex(real, imag));
            }
            
            return spectrum;
        }

        // Spectrogram generation
        function generateSpectrogram() {
            const signalType = document.getElementById('signal-type').value;
            const windowSize = parseInt(document.getElementById('window-size').value);
            const hopSize = parseInt(document.getElementById('hop-size').value);
            
            const sampleRate = 8192;
            const duration = 2.0;
            const samples = Math.floor(duration * sampleRate);
            
            // Generate signal based on type
            let signal = [];
            
            switch (signalType) {
                case 'chirp':
                    for (let i = 0; i < samples; i++) {
                        const t = i / sampleRate;
                        const freq = 200 + (1000 * t / duration); // Linear chirp from 200 to 1200 Hz
                        signal.push(Math.cos(2 * Math.PI * freq * t));
                    }
                    break;
                    
                case 'multitone':
                    for (let i = 0; i < samples; i++) {
                        const t = i / sampleRate;
                        signal.push(
                            Math.cos(2 * Math.PI * 440 * t) +
                            0.7 * Math.cos(2 * Math.PI * 880 * t) +
                            0.5 * Math.cos(2 * Math.PI * 1320 * t)
                        );
                    }
                    break;
                    
                case 'music':
                    // Simulate a C major chord progression
                    for (let i = 0; i < samples; i++) {
                        const t = i / sampleRate;
                        const chord = Math.floor(t / 0.5) % 3;
                        let freq1, freq2, freq3;
                        
                        switch (chord) {
                            case 0: // C major (C-E-G)
                                freq1 = 261.63; freq2 = 329.63; freq3 = 392.00;
                                break;
                            case 1: // F major (F-A-C)
                                freq1 = 349.23; freq2 = 440.00; freq3 = 523.25;
                                break;
                            case 2: // G major (G-B-D)
                                freq1 = 392.00; freq2 = 493.88; freq3 = 587.33;
                                break;
                        }
                        
                        signal.push(
                            Math.cos(2 * Math.PI * freq1 * t) +
                            Math.cos(2 * Math.PI * freq2 * t) +
                            Math.cos(2 * Math.PI * freq3 * t)
                        );
                    }
                    break;
                    
                case 'noise':
                    // Pink noise approximation
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < samples; i++) {
                        const white = Math.random() - 0.5;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        b6 = white * 0.115926;
                        signal.push(pink * 0.11);
                    }
                    break;
            }
            
            // Compute STFT
            const numFrames = Math.floor((samples - windowSize) / hopSize) + 1;
            const spectrogram = [];
            const timeAxis = [];
            const freqAxis = [];
            
            // Frequency axis
            for (let k = 0; k < windowSize / 2; k++) {
                freqAxis.push(k * sampleRate / windowSize);
            }
            
            // Compute STFT for each frame
            for (let frame = 0; frame < numFrames; frame++) {
                const startSample = frame * hopSize;
                timeAxis.push(startSample / sampleRate);
                
                // Extract windowed frame
                const frameData = [];
                for (let i = 0; i < windowSize; i++) {
                    if (startSample + i < samples) {
                        // Apply Hanning window
                        const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
                        frameData.push(signal[startSample + i] * window);
                    } else {
                        frameData.push(0);
                    }
                }
                
                // Compute DFT for this frame
                const frameSpectrum = computeDFT(frameData);
                const frameMagnitudes = [];
                
                for (let k = 0; k < windowSize / 2; k++) {
                    frameMagnitudes.push(20 * Math.log10(frameSpectrum[k].magnitude() + 1e-10));
                }
                
                spectrogram.push(frameMagnitudes);
            }
            
            // Transpose for correct orientation
            const spectrogramTransposed = [];
            for (let k = 0; k < windowSize / 2; k++) {
                spectrogramTransposed.push([]);
                for (let frame = 0; frame < numFrames; frame++) {
                    spectrogramTransposed[k].push(spectrogram[frame][k]);
                }
            }
            
            // Create spectrogram plot
            Plotly.newPlot('spectrogram-plot', [{
                z: spectrogramTransposed.reverse(), // Reverse to have low frequencies at bottom
                x: timeAxis,
                y: freqAxis.reverse(),
                type: 'heatmap',
                colorscale: 'Viridis',
                colorbar: {title: 'Magnitude (dB)'}
            }], {
                title: `Spectrogram - ${signalType.charAt(0).toUpperCase() + signalType.slice(1)} Signal`,
                xaxis: {title: 'Time (s)'},
                yaxis: {title: 'Frequency (Hz)'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            });
        }

        // Audio effect functions
        function generateTestTone() {
            console.log("Generating test tone for spectral effects");
            // Generate spectrum visualization
            const frequencies = [];
            const magnitudes = [];
            
            for (let i = 0; i < 512; i++) {
                const freq = i * 8192 / 1024;
                frequencies.push(freq);
                
                // Simulate a test tone with harmonics
                let magnitude = 0;
                if (Math.abs(freq - 440) < 10) magnitude = 0.8;
                else if (Math.abs(freq - 880) < 10) magnitude = 0.4;
                else if (Math.abs(freq - 1320) < 10) magnitude = 0.2;
                else magnitude = 0.01 * Math.random();
                
                magnitudes.push(20 * Math.log10(magnitude + 1e-10));
            }
            
            const trace = {
                x: frequencies,
                y: magnitudes,
                mode: 'lines',
                type: 'scatter',
                name: 'Original Spectrum',
                line: {color: '#4fc3f7', width: 2}
            };
            
            Plotly.newPlot('original-spectrum-plot', [trace], {
                title: 'Original Signal Spectrum',
                xaxis: {title: 'Frequency (Hz)'},
                yaxis: {title: 'Magnitude (dB)'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            });
        }

        function applySpectralEffect() {
            const effectType = document.getElementById('effect-type').value;
            const effectAmount = parseFloat(document.getElementById('effect-amount').value);
            
            console.log(`Applying ${effectType} effect with amount ${effectAmount}`);
            
            // Simulate processed spectrum
            const frequencies = [];
            const magnitudes = [];
            
            for (let i = 0; i < 512; i++) {
                const freq = i * 8192 / 1024;
                frequencies.push(freq);
                
                let magnitude = 0;
                switch (effectType) {
                    case 'pitch-shift':
                        // Shift frequencies
                        const shiftedFreq = freq * (1 + effectAmount * 0.5);
                        if (Math.abs(shiftedFreq - 440) < 10) magnitude = 0.8;
                        else if (Math.abs(shiftedFreq - 880) < 10) magnitude = 0.4;
                        else magnitude = 0.01 * Math.random();
                        break;
                        
                    case 'spectral-gate':
                        // Gate lower frequencies
                        if (Math.abs(freq - 440) < 10) magnitude = 0.8;
                        else if (Math.abs(freq - 880) < 10) magnitude = freq > 500 ? 0.4 * effectAmount : 0.1;
                        else magnitude = freq > 300 ? 0.01 * Math.random() * effectAmount : 0.001;
                        break;
                        
                    case 'phase-scramble':
                        // Keep magnitude, randomize phase (shown as noise floor increase)
                        if (Math.abs(freq - 440) < 10) magnitude = 0.8;
                        else if (Math.abs(freq - 880) < 10) magnitude = 0.4;
                        else magnitude = 0.01 * Math.random() * (1 + effectAmount);
                        break;
                        
                    default:
                        if (Math.abs(freq - 440) < 10) magnitude = 0.8;
                        else if (Math.abs(freq - 880) < 10) magnitude = 0.4;
                        else magnitude = 0.01 * Math.random();
                }
                
                magnitudes.push(20 * Math.log10(magnitude + 1e-10));
            }
            
            const trace = {
                x: frequencies,
                y: magnitudes,
                mode: 'lines',
                type: 'scatter',
                name: 'Processed Spectrum',
                line: {color: '#ff7043', width: 2}
            };
            
            Plotly.newPlot('processed-spectrum-plot', [trace], {
                title: `Processed Spectrum - ${effectType}`,
                xaxis: {title: 'Frequency (Hz)'},
                yaxis: {title: 'Magnitude (dB)'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            });
        }

        // Placeholder functions
        function applyFilter() {
            console.log("Applying filter to test signal");
        }

        function playFilteredAudio() {
            console.log("Playing filtered audio");
        }

        function playSpectrogramAudio() {
            console.log("Playing spectrogram signal");
        }

        function playOriginal() {
            console.log("Playing original audio");
        }

        function playProcessed() {
            console.log("Playing processed audio");
        }

        function updateEffect() {
            updateValueDisplays();
            applySpectralEffect();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners for all controls
            document.getElementById('cutoff-freq').addEventListener('input', updateValueDisplays);
            document.getElementById('filter-q').addEventListener('input', updateValueDisplays);
            document.getElementById('window-size').addEventListener('input', updateValueDisplays);
            document.getElementById('hop-size').addEventListener('input', updateValueDisplays);
            document.getElementById('effect-amount').addEventListener('input', updateValueDisplays);
            document.getElementById('mix-level').addEventListener('input', updateValueDisplays);
            
            // Initialize displays and plots
            updateValueDisplays();
            updateFilter();
            generateSpectrogram();
            generateTestTone();
        });
    </script>
</body>
</html>
