<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Path Algorithms - Interactive Learning</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="../math-simple.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 30px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            text-decoration: none;
            color: white;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-top: 20px;
        }
        .visualization-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }
        .controls-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }
        canvas {
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 800px;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .control-group h3 {
            margin-top: 0;
            color: #ffd700;
        }
        button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        button.active {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
        }
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .algorithm-steps {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        .step {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }
        .step.current {
            background: rgba(255, 215, 0, 0.2);
            border-left-color: #ffd700;
        }
        .distance-table {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ffd700;
        }
        .complexity-info {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 3px solid #667eea;
        }
        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 5px;
            margin: 5px;
        }
        .path-result {
            background: rgba(0, 255, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 3px solid #00ff00;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px;
            text-align: left;
        }
        .comparison-table th {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Quay l·∫°i Graph Theory Hub</a>
        
        <h1>üéØ Shortest Path Algorithms</h1>
        
        <div class="info-panel">
            <h2>üöÄ Thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t</h2>
            <p>
                <strong>Shortest Path Problems</strong> l√† m·ªôt trong nh·ªØng b√†i to√°n c∆° b·∫£n v√† quan tr·ªçng nh·∫•t trong graph theory. 
                Ch√∫ng ta s·∫Ω kh√°m ph√° 3 thu·∫≠t to√°n ch√≠nh: <strong>Dijkstra's Algorithm</strong> (single-source shortest path), 
                <strong>Bellman-Ford Algorithm</strong> (x·ª≠ l√Ω negative weights), v√† <strong>Floyd-Warshall Algorithm</strong> (all-pairs shortest path).
            </p>
            
            <div class="math-formula">
                <h4>üìê Mathematical Foundation</h4>
                <p>Cho ƒë·ªì th·ªã c√≥ tr·ªçng s·ªë \(G = (V, E, w)\) v·ªõi h√†m tr·ªçng s·ªë \(w: E \rightarrow \mathbb{R}\)</p>
                <p><strong>Shortest Path Distance:</strong> \(d(u,v) = \min\{w(p) : p \text{ is a path from } u \text{ to } v\}\)</p>
                <p><strong>Relaxation Operation:</strong> \(d[v] = \min(d[v], d[u] + w(u,v))\)</p>
            </div>
        </div>

        <div class="content-grid">
            <div class="visualization-panel">
                <h3>Interactive Graph Visualization</h3>
                <canvas id="graphCanvas" width="750" height="500"></canvas>
                
                <div class="path-result" id="pathResult" style="display: none;">
                    <h4>üéØ Path Found!</h4>
                    <div id="pathDetails"></div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="control-group">
                    <h3>üõ†Ô∏è Algorithm Selection</h3>
                    <button id="dijkstraBtn" class="active" onclick="selectAlgorithm('dijkstra')">Dijkstra's</button>
                    <button id="bellmanFordBtn" onclick="selectAlgorithm('bellmanFord')">Bellman-Ford</button>
                    <button id="floydWarshallBtn" onclick="selectAlgorithm('floydWarshall')">Floyd-Warshall</button>
                </div>
                
                <div class="control-group">
                    <h3>üéÆ Controls</h3>
                    <button onclick="generateRandomGraph()">üé≤ Random Graph</button>
                    <button onclick="addNegativeEdges()">‚ûñ Add Negative Edges</button>
                    <button onclick="resetGraph()">üîÑ Reset</button>
                    <br>
                    <label>Speed: <input type="range" id="speedSlider" min="1" max="10" value="5"></label>
                    <br>
                    <button id="runBtn" onclick="runAlgorithm()">‚ñ∂Ô∏è Run Algorithm</button>
                    <button id="stepBtn" onclick="stepAlgorithm()">üëâ Step</button>
                    <button onclick="pauseAlgorithm()">‚è∏Ô∏è Pause</button>
                </div>
                
                <div class="control-group">
                    <h3>üéØ Source & Target</h3>
                    <select id="sourceSelect">
                        <option value="0">Node A (0)</option>
                        <option value="1">Node B (1)</option>
                        <option value="2">Node C (2)</option>
                        <option value="3">Node D (3)</option>
                        <option value="4">Node E (4)</option>
                    </select>
                    <select id="targetSelect">
                        <option value="4" selected>Node E (4)</option>
                        <option value="0">Node A (0)</option>
                        <option value="1">Node B (1)</option>
                        <option value="2">Node C (2)</option>
                        <option value="3">Node D (3)</option>
                    </select>
                </div>
                
                <div class="algorithm-steps" id="algorithmSteps">
                    <h4>üìã Algorithm Steps</h4>
                    <div id="stepsContent">Select an algorithm and click Run to see steps...</div>
                </div>
                
                <div class="distance-table" id="distanceTable">
                    <h4>üìä Distance Table</h4>
                    <div id="tableContent">Distance information will appear here...</div>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>üßÆ Algorithm Comparison</h2>
            <table class="comparison-table">
                <tr>
                    <th>Algorithm</th>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                    <th>Negative Weights</th>
                    <th>Use Case</th>
                </tr>
                <tr>
                    <td><strong>Dijkstra's</strong></td>
                    <td>\(O((V + E) \log V)\)</td>
                    <td>\(O(V)\)</td>
                    <td>‚ùå No</td>
                    <td>Single-source, non-negative weights</td>
                </tr>
                <tr>
                    <td><strong>Bellman-Ford</strong></td>
                    <td>\(O(VE)\)</td>
                    <td>\(O(V)\)</td>
                    <td>‚úÖ Yes</td>
                    <td>Single-source, detects negative cycles</td>
                </tr>
                <tr>
                    <td><strong>Floyd-Warshall</strong></td>
                    <td>\(O(V^3)\)</td>
                    <td>\(O(V^2)\)</td>
                    <td>‚úÖ Yes</td>
                    <td>All-pairs shortest paths</td>
                </tr>
            </table>
        </div>
        
        <div class="info-panel">
            <h2>üåü Real-World Applications</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div class="complexity-info">
                    <h4>üó∫Ô∏è GPS Navigation</h4>
                    <p>Dijkstra's algorithm powers most GPS systems to find the fastest route considering traffic, road conditions, and distance.</p>
                </div>
                <div class="complexity-info">
                    <h4>üí∞ Currency Arbitrage</h4>
                    <p>Bellman-Ford detects negative cycles in currency exchange rates to identify arbitrage opportunities.</p>
                </div>
                <div class="complexity-info">
                    <h4>üåê Network Routing</h4>
                    <p>Internet protocols use shortest path algorithms to route packets efficiently across networks.</p>
                </div>
                <div class="complexity-info">
                    <h4>üéÆ Game AI</h4>
                    <p>Pathfinding in games uses these algorithms for NPC movement and AI decision making.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Graph representation and visualization
        class Graph {
            constructor() {
                this.vertices = [];
                this.edges = [];
                this.adjacencyList = new Map();
                this.resetDefaultGraph();
            }
            
            resetDefaultGraph() {
                this.vertices = [
                    {id: 0, x: 100, y: 100, label: 'A'},
                    {id: 1, x: 300, y: 80, label: 'B'},
                    {id: 2, x: 500, y: 120, label: 'C'},
                    {id: 3, x: 200, y: 250, label: 'D'},
                    {id: 4, x: 400, y: 280, label: 'E'}
                ];
                
                this.edges = [
                    {from: 0, to: 1, weight: 4},
                    {from: 0, to: 3, weight: 2},
                    {from: 1, to: 2, weight: 3},
                    {from: 1, to: 3, weight: 1},
                    {from: 1, to: 4, weight: 6},
                    {from: 2, to: 4, weight: 2},
                    {from: 3, to: 4, weight: 5}
                ];
                
                this.buildAdjacencyList();
            }
            
            buildAdjacencyList() {
                this.adjacencyList.clear();
                this.vertices.forEach(v => this.adjacencyList.set(v.id, []));
                
                this.edges.forEach(edge => {
                    this.adjacencyList.get(edge.from).push({
                        to: edge.to,
                        weight: edge.weight
                    });
                });
            }
            
            addNegativeEdges() {
                // Add some negative weight edges for Bellman-Ford demonstration
                this.edges.push({from: 2, to: 1, weight: -2});
                this.edges.push({from: 4, to: 3, weight: -1});
                this.buildAdjacencyList();
            }
            
            generateRandom() {
                this.vertices = [];
                this.edges = [];
                
                // Generate random vertices
                const numVertices = 5 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numVertices; i++) {
                    this.vertices.push({
                        id: i,
                        x: 80 + Math.random() * 600,
                        y: 80 + Math.random() * 340,
                        label: String.fromCharCode(65 + i)
                    });
                }
                
                // Generate random edges
                const numEdges = Math.floor(numVertices * 1.5);
                const edgeSet = new Set();
                
                for (let i = 0; i < numEdges; i++) {
                    let from, to;
                    do {
                        from = Math.floor(Math.random() * numVertices);
                        to = Math.floor(Math.random() * numVertices);
                    } while (from === to || edgeSet.has(`${from}-${to}`));
                    
                    edgeSet.add(`${from}-${to}`);
                    this.edges.push({
                        from: from,
                        to: to,
                        weight: 1 + Math.floor(Math.random() * 9)
                    });
                }
                
                this.buildAdjacencyList();
                updateSelectors();
            }
        }
        
        // Algorithm implementations
        class ShortestPathAlgorithms {
            constructor(graph) {
                this.graph = graph;
                this.distances = [];
                this.previous = [];
                this.visited = [];
                this.currentStep = 0;
                this.steps = [];
                this.isRunning = false;
                this.currentAlgorithm = 'dijkstra';
            }
            
            async dijkstra(source, target = null) {
                console.log(`Dijkstra: Starting from ${source} to ${target}`);
                console.log('Graph vertices:', this.graph.vertices.length);
                console.log('Graph edges:', this.graph.edges.length);
                
                this.reset();
                const n = this.graph.vertices.length;
                this.distances = new Array(n).fill(Infinity);
                this.previous = new Array(n).fill(null);
                this.visited = new Array(n).fill(false);
                
                this.distances[source] = 0;
                const pq = [{vertex: source, distance: 0}];
                
                console.log('Initial distances:', this.distances);
                
                this.addStep(`Initialize: d[${source}] = 0, all others = ‚àû`);
                
                // Initial visualization update
                this.updateVisualization();
                await this.delay();
                
                let iterations = 0;
                while (pq.length > 0 && this.isRunning && iterations < n * 2) { // Safety limit
                    iterations++;
                    console.log(`Dijkstra iteration ${iterations}, PQ size: ${pq.length}`);
                    
                    // Sort by distance (simple implementation)
                    pq.sort((a, b) => a.distance - b.distance);
                    const current = pq.shift();
                    const u = current.vertex;
                    
                    console.log(`Processing vertex ${u} with distance ${current.distance}`);
                    
                    if (this.visited[u]) {
                        console.log(`Vertex ${u} already visited, skipping`);
                        continue;
                    }
                    
                    this.visited[u] = true;
                    
                    this.addStep(`Visit vertex ${this.graph.vertices[u].label} (${u}) with distance ${this.distances[u]}`);
                    
                    // Update visualization after visiting vertex
                    this.updateVisualization();
                    await this.delay();
                    
                    if (target !== null && u === target) {
                        this.addStep(`Target reached! Shortest distance: ${this.distances[target]}`);
                        this.updateVisualization();
                        console.log(`Target ${target} reached with distance ${this.distances[target]}`);
                        break;
                    }
                    
                    const neighbors = this.graph.adjacencyList.get(u) || [];
                    console.log(`Vertex ${u} has ${neighbors.length} neighbors:`, neighbors);
                    
                    for (const neighbor of neighbors) {
                        const v = neighbor.to;
                        const weight = neighbor.weight;
                        
                        if (!this.visited[v]) {
                            const oldDist = this.distances[v];
                            const newDist = this.distances[u] + weight;
                            if (newDist < this.distances[v]) {
                                console.log(`Relaxing edge ${u}->${v}: ${oldDist} -> ${newDist}`);
                                this.distances[v] = newDist;
                                this.previous[v] = u;
                                pq.push({vertex: v, distance: newDist});
                                
                                const oldDistStr = oldDist === Infinity ? '‚àû' : oldDist;
                                this.addStep(`Relax edge (${u},${v}): d[${v}] = min(${oldDistStr}, ${this.distances[u]} + ${weight}) = ${newDist}`);
                                
                                // Update visualization after relaxation
                                this.updateVisualization();
                                await this.delay();
                            }
                        }
                    }
                }
                
                console.log('Final distances:', this.distances);
                console.log('Dijkstra completed after', iterations, 'iterations');
                
                return this.reconstructPath(source, target);
            }
            
            async bellmanFord(source, target = null) {
                this.reset();
                const n = this.graph.vertices.length;
                this.distances = new Array(n).fill(Infinity);
                this.previous = new Array(n).fill(null);
                
                this.distances[source] = 0;
                this.addStep(`Initialize: d[${source}] = 0, all others = ‚àû`);
                
                // Initial visualization update
                this.updateVisualization();
                await this.delay();
                
                // Relax edges V-1 times
                for (let i = 0; i < n - 1; i++) {
                    this.addStep(`Iteration ${i + 1}: Relax all edges`);
                    let updated = false;
                    
                    for (const edge of this.graph.edges) {
                        const u = edge.from;
                        const v = edge.to;
                        const weight = edge.weight;
                        
                        if (this.distances[u] !== Infinity) {
                            const newDist = this.distances[u] + weight;
                            if (newDist < this.distances[v]) {
                                this.distances[v] = newDist;
                                this.previous[v] = u;
                                updated = true;
                                
                                this.addStep(`Update: d[${v}] = ${newDist} via edge (${u},${v})`);
                            }
                        }
                    }
                    
                    if (!updated) {
                        this.addStep(`No updates in iteration ${i + 1}, algorithm converged early`);
                        this.updateVisualization();
                        break;
                    }
                    
                    // Update visualization after each iteration
                    this.updateVisualization();
                    await this.delay();
                }
                
                // Check for negative cycles
                this.addStep(`Check for negative cycles...`);
                for (const edge of this.graph.edges) {
                    const u = edge.from;
                    const v = edge.to;
                    const weight = edge.weight;
                    
                    if (this.distances[u] !== Infinity && this.distances[u] + weight < this.distances[v]) {
                        this.addStep(`‚ùå Negative cycle detected! Edge (${u},${v}) can still be relaxed`);
                        this.updateVisualization();
                        return null;
                    }
                }
                
                this.addStep(`‚úÖ No negative cycles found`);
                this.updateVisualization();
                return this.reconstructPath(source, target);
            }
            
            async floydWarshall() {
                this.reset();
                const n = this.graph.vertices.length;
                
                // Initialize distance matrix
                const dist = Array(n).fill().map(() => Array(n).fill(Infinity));
                const next = Array(n).fill().map(() => Array(n).fill(null));
                
                // Initialize distances
                for (let i = 0; i < n; i++) {
                    dist[i][i] = 0;
                }
                
                for (const edge of this.graph.edges) {
                    dist[edge.from][edge.to] = edge.weight;
                    next[edge.from][edge.to] = edge.to;
                }
                
                this.addStep(`Initialize distance matrix with direct edges`);
                this.updateFloydWarshallTable(dist);
                await this.delay();
                
                // Floyd-Warshall algorithm
                for (let k = 0; k < n; k++) {
                    this.addStep(`Using vertex ${k} as intermediate vertex`);
                    
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                                dist[i][j] = dist[i][k] + dist[k][j];
                                next[i][j] = next[i][k];
                                
                                this.addStep(`Update: d[${i}][${j}] = ${dist[i][j]} via vertex ${k}`);
                            }
                        }
                    }
                    
                    this.updateFloydWarshallTable(dist);
                    await this.delay();
                }
                
                this.distances = dist;
                this.next = next;
                return dist;
            }
            
            reconstructPath(source, target) {
                if (target === null || this.distances[target] === Infinity) {
                    return null;
                }
                
                const path = [];
                let current = target;
                
                while (current !== null) {
                    path.unshift(current);
                    current = this.previous[current];
                }
                
                if (path[0] !== source) {
                    return null; // No path exists
                }
                
                return {
                    path: path,
                    distance: this.distances[target],
                    edges: this.getPathEdges(path)
                };
            }
            
            getPathEdges(path) {
                const pathEdges = [];
                for (let i = 0; i < path.length - 1; i++) {
                    pathEdges.push({from: path[i], to: path[i + 1]});
                }
                return pathEdges;
            }
            
            addStep(description) {
                this.steps.push({
                    step: this.steps.length + 1,
                    description: description,
                    distances: [...this.distances],
                    visited: [...this.visited]
                });
            }
            
            reset() {
                this.distances = [];
                this.previous = [];
                this.visited = [];
                this.steps = [];
                this.currentStep = 0;
                this.isRunning = false;
            }
            
            async delay() {
                const speed = document.getElementById('speedSlider').value;
                const delayTime = Math.max(100, 1100 - (speed * 100)); // Minimum 100ms delay
                return new Promise(resolve => setTimeout(resolve, delayTime));
            }
            
            updateVisualization() {
                drawGraph();
                this.updateStepsDisplay();
                this.updateDistanceTable();
            }
            
            updateStepsDisplay() {
                const stepsContent = document.getElementById('stepsContent');
                stepsContent.innerHTML = '';
                
                this.steps.forEach((step, index) => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'step' + (index === this.currentStep ? ' current' : '');
                    stepDiv.textContent = `${step.step}. ${step.description}`;
                    stepsContent.appendChild(stepDiv);
                });
                
                stepsContent.scrollTop = stepsContent.scrollHeight;
            }
            
            updateDistanceTable() {
                const tableContent = document.getElementById('tableContent');
                let content = '';
                
                if (this.currentAlgorithm === 'floydWarshall') {
                    // Show full distance matrix
                    content = this.formatFloydWarshallTable();
                } else {
                    // Show single-source distances
                    content = 'Vertex | Distance | Previous\n';
                    content += '-------|----------|----------\n';
                    
                    this.graph.vertices.forEach((vertex, i) => {
                        const dist = this.distances[i] === Infinity ? '‚àû' : this.distances[i];
                        const prev = this.previous[i] === null ? '-' : this.graph.vertices[this.previous[i]].label;
                        const visited = this.visited[i] ? '‚úì' : '';
                        content += `${vertex.label}(${i})   | ${dist}        | ${prev} ${visited}\n`;
                    });
                }
                
                tableContent.textContent = content;
            }
            
            updateFloydWarshallTable(dist) {
                const tableContent = document.getElementById('tableContent');
                let content = 'All-Pairs Shortest Distances:\n\n';
                content += '     ';
                
                // Header
                this.graph.vertices.forEach(v => {
                    content += `${v.label}    `;
                });
                content += '\n';
                
                // Rows
                this.graph.vertices.forEach((v, i) => {
                    content += `${v.label}    `;
                    this.graph.vertices.forEach((w, j) => {
                        const d = dist[i][j] === Infinity ? '‚àû' : dist[i][j].toString();
                        content += `${d.padStart(3)}  `;
                    });
                    content += '\n';
                });
                
                tableContent.textContent = content;
            }
            
            formatFloydWarshallTable() {
                return 'Floyd-Warshall distance matrix will be displayed during execution.';
            }
        }
        
        // Visualization
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const graph = new Graph();
        const algorithms = new ShortestPathAlgorithms(graph);
        
        let currentPath = null;
        let selectedAlgorithm = 'dijkstra';
        
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            graph.edges.forEach(edge => {
                const from = graph.vertices[edge.from];
                const to = graph.vertices[edge.to];
                
                const isInPath = currentPath && currentPath.edges.some(e => 
                    e.from === edge.from && e.to === edge.to
                );
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = isInPath ? '#ffd700' : (edge.weight < 0 ? '#ff6b6b' : '#4ecdc4');
                ctx.lineWidth = isInPath ? 4 : 2;
                ctx.stroke();
                
                // Draw arrow
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const arrowLength = 15;
                const arrowX = to.x - Math.cos(angle) * 25;
                const arrowY = to.y - Math.sin(angle) * 25;
                
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX - arrowLength * Math.cos(angle - Math.PI / 6), 
                          arrowY - arrowLength * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX - arrowLength * Math.cos(angle + Math.PI / 6), 
                          arrowY - arrowLength * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
                
                // Draw weight
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                
                ctx.fillStyle = edge.weight < 0 ? '#ff6b6b' : '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(edge.weight.toString(), midX, midY - 5);
            });
            
            // Draw vertices
            graph.vertices.forEach((vertex, index) => {
                const isVisited = algorithms.visited && algorithms.visited[index];
                const distance = algorithms.distances && algorithms.distances[index];
                
                // Vertex circle
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = isVisited ? '#f093fb' : '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Vertex label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(vertex.label, vertex.x, vertex.y + 5);
                
                // Distance label
                if (distance !== undefined && distance !== Infinity) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(distance.toString(), vertex.x, vertex.y - 30);
                }
            });
        }
        
        function selectAlgorithm(algorithm) {
            selectedAlgorithm = algorithm;
            algorithms.currentAlgorithm = algorithm;
            algorithms.graph = graph; // Ensure graph reference is updated
            
            // Update button states
            document.querySelectorAll('.control-group button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(algorithm + 'Btn').classList.add('active');
            
            // Reset visualization
            algorithms.reset();
            currentPath = null;
            drawGraph();
            
            // Update info based on algorithm
            updateAlgorithmInfo();
        }
        
        function updateAlgorithmInfo() {
            const stepsContent = document.getElementById('stepsContent');
            const tableContent = document.getElementById('tableContent');
            
            switch (selectedAlgorithm) {
                case 'dijkstra':
                    stepsContent.innerHTML = `
                        <div class="complexity-info">
                            <h4>üöÄ Dijkstra's Algorithm</h4>
                            <p><strong>Time:</strong> O((V + E) log V) | <strong>Space:</strong> O(V)</p>
                            <p>Works with non-negative edge weights. Uses a priority queue to always process the vertex with minimum distance.</p>
                        </div>
                    `;
                    tableContent.textContent = 'Select source and target, then click Run to see distances...';
                    break;
                case 'bellmanFord':
                    stepsContent.innerHTML = `
                        <div class="complexity-info">
                            <h4>‚ö° Bellman-Ford Algorithm</h4>
                            <p><strong>Time:</strong> O(VE) | <strong>Space:</strong> O(V)</p>
                            <p>Handles negative edge weights and detects negative cycles. Relaxes all edges V-1 times.</p>
                        </div>
                    `;
                    tableContent.textContent = 'Works with negative weights. Click Run to start...';
                    break;
                case 'floydWarshall':
                    stepsContent.innerHTML = `
                        <div class="complexity-info">
                            <h4>üåê Floyd-Warshall Algorithm</h4>
                            <p><strong>Time:</strong> O(V¬≥) | <strong>Space:</strong> O(V¬≤)</p>
                            <p>Finds shortest paths between all pairs of vertices. Uses dynamic programming approach.</p>
                        </div>
                    `;
                    tableContent.textContent = 'Computes all-pairs shortest paths. Click Run to start...';
                    break;
            }
        }
        
        async function runAlgorithm() {
            const source = parseInt(document.getElementById('sourceSelect').value);
            const target = parseInt(document.getElementById('targetSelect').value);
            
            console.log(`Running ${selectedAlgorithm} from ${source} to ${target}`);
            
            // Reset algorithms and visualization
            algorithms.reset();
            algorithms.graph = graph; // Ensure graph reference is updated
            currentPath = null;
            
            algorithms.isRunning = true;
            document.getElementById('runBtn').disabled = true;
            document.getElementById('pathResult').style.display = 'none';
            
            // Clear previous visualization
            drawGraph();
            
            try {
                let result;
                switch (selectedAlgorithm) {
                    case 'dijkstra':
                        console.log('Starting Dijkstra algorithm...');
                        result = await algorithms.dijkstra(source, target);
                        break;
                    case 'bellmanFord':
                        console.log('Starting Bellman-Ford algorithm...');
                        result = await algorithms.bellmanFord(source, target);
                        break;
                    case 'floydWarshall':
                        console.log('Starting Floyd-Warshall algorithm...');
                        result = await algorithms.floydWarshall();
                        break;
                }
                
                console.log('Algorithm completed, result:', result);
                
                if (result && selectedAlgorithm !== 'floydWarshall') {
                    currentPath = result;
                    showPathResult(result, source, target);
                } else if (selectedAlgorithm === 'floydWarshall') {
                    showFloydWarshallResult();
                }
                
                // Final visualization update
                drawGraph();
            } catch (error) {
                console.error('Algorithm execution error:', error);
                algorithms.updateVisualization(); // Force update even on error
            } finally {
                document.getElementById('runBtn').disabled = false;
                algorithms.isRunning = false;
            }
        }
        
        function stepAlgorithm() {
            // Implementation for step-by-step execution
            console.log('Step execution not implemented yet');
        }
        
        function pauseAlgorithm() {
            algorithms.isRunning = false;
            document.getElementById('runBtn').disabled = false;
        }
        
        function showPathResult(result, source, target) {
            const pathResult = document.getElementById('pathResult');
            const pathDetails = document.getElementById('pathDetails');
            
            const pathString = result.path.map(v => graph.vertices[v].label).join(' ‚Üí ');
            
            pathDetails.innerHTML = `
                <p><strong>Path:</strong> ${pathString}</p>
                <p><strong>Total Distance:</strong> ${result.distance}</p>
                <p><strong>Number of Edges:</strong> ${result.path.length - 1}</p>
            `;
            
            pathResult.style.display = 'block';
        }
        
        function showFloydWarshallResult() {
            const pathResult = document.getElementById('pathResult');
            const pathDetails = document.getElementById('pathDetails');
            
            pathDetails.innerHTML = `
                <p><strong>Floyd-Warshall Complete!</strong></p>
                <p>All-pairs shortest paths computed successfully.</p>
                <p>Check the distance table for complete matrix.</p>
            `;
            
            pathResult.style.display = 'block';
        }
        
        function generateRandomGraph() {
            graph.generateRandom();
            algorithms.reset();
            currentPath = null;
            drawGraph();
        }
        
        function addNegativeEdges() {
            graph.addNegativeEdges();
            algorithms.reset();
            currentPath = null;
            drawGraph();
        }
        
        function resetGraph() {
            graph.resetDefaultGraph();
            algorithms.reset();
            currentPath = null;
            updateSelectors();
            drawGraph();
        }
        
        function updateSelectors() {
            const sourceSelect = document.getElementById('sourceSelect');
            const targetSelect = document.getElementById('targetSelect');
            
            sourceSelect.innerHTML = '';
            targetSelect.innerHTML = '';
            
            graph.vertices.forEach((vertex, index) => {
                const option1 = new Option(`Node ${vertex.label} (${index})`, index);
                const option2 = new Option(`Node ${vertex.label} (${index})`, index);
                
                sourceSelect.add(option1);
                targetSelect.add(option2);
            });
            
            if (graph.vertices.length > 1) {
                targetSelect.selectedIndex = graph.vertices.length - 1;
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure algorithms has correct graph reference
            algorithms.graph = graph;
            
            updateSelectors();
            updateAlgorithmInfo();
            drawGraph();
            
            // Configure MathJax
            window.MathJax = {
                tex: {
                    inlineMath: [['\\(', '\\)']],
                    displayMath: [['\\[', '\\]']]
                }
            };
        });
        
        // Canvas click handling for interactive vertex selection
        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Find clicked vertex
            graph.vertices.forEach((vertex, index) => {
                const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                if (distance <= 20) {
                    // Toggle between source and target
                    if (event.shiftKey) {
                        document.getElementById('targetSelect').value = index;
                    } else {
                        document.getElementById('sourceSelect').value = index;
                    }
                }
            });
        });
    </script>
</body>
</html>
