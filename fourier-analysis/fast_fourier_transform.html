<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast Fourier Transform (FFT) - Theory & Interactive</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 50%, #2d2d60 100%);
            color: white;
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Navigation Styles */
        .nav-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .nav-tabs {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
        }

        .nav-tab {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-tab.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        /* Section Styles */
        .section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Theory Section Styles */
        .theory-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .theory-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
        }

        .theory-header h1 {
            font-size: 3em;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .theory-header p {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.8);
        }

        .theory-section {
            margin-bottom: 40px;
            background: rgba(0, 0, 0, 0.2);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .theory-section h2 {
            color: #00d4ff;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            padding-bottom: 10px;
        }

        .theory-section h3 {
            color: #66b3ff;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .definition, .theorem, .example {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid #00d4ff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .definition h4, .theorem h4, .example h4 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .algorithm-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .complexity-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .complexity-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            transition: transform 0.3s ease;
        }

        .complexity-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.2);
        }

        .complexity-card h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            margin: 15px 0;
            border-left: 3px solid #00d4ff;
            overflow-x: auto;
        }

        /* Interactive Section Styles */
        .interactive-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            min-height: calc(100vh - 60px);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .control-row label {
            min-width: 120px;
            margin-right: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            margin-right: 10px;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.95);
        }
        
        .performance-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .performance-panel h3 {
            margin-top: 0;
            color: #00d4ff;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00d4ff;
        }

        .signal-visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .chart-container {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .chart-title {
            color: #00d4ff;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <div class="nav-container">
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showSection('theory')">üìö Theory</button>
            <button class="nav-tab" onclick="showSection('interactive')">üéÆ Interactive</button>
        </div>
    </div>

    <!-- Theory Section -->
    <div id="theory" class="section active">
        <div class="theory-content">
            <div class="theory-header">
                <h1>Fast Fourier Transform (FFT)</h1>
                <p>The computational revolution that made modern digital signal processing possible</p>
            </div>

            <div class="theory-section">
                <h2>1. Mathematical Foundations</h2>
                
                <div class="definition">
                    <h4>üìê Discrete Fourier Transform (DFT) - Rigorous Definition</h4>
                    <p>Given a finite sequence $\{x[n]\}_{n=0}^{N-1}$ of complex numbers, the DFT is defined as:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k] = \sum_{n=0}^{N-1} x[n] \cdot W_N^{kn}, \quad k = 0, 1, \ldots, N-1$$
                        $$\text{where } W_N = e^{-j\frac{2\pi}{N}} \text{ is the primitive } N\text{-th root of unity}$$
                    </div>
                    
                    <h4>üîÑ Inverse DFT (IDFT)</h4>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] \cdot W_N^{-kn} = \frac{1}{N} \sum_{k=0}^{N-1} X[k] \cdot e^{j\frac{2\pi kn}{N}}$$
                    </div>
                    
                    <h4>üéØ Matrix Representation</h4>
                    <p>The DFT can be expressed as a matrix multiplication:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$\mathbf{X} = \mathbf{W}_N \mathbf{x}$$
                        $$\text{where } [\mathbf{W}_N]_{k,n} = W_N^{kn} = e^{-j\frac{2\pi kn}{N}}$$
                    </div>
                    <p>The DFT matrix $\mathbf{W}_N$ is a <strong>unitary matrix</strong> (up to scaling): $\mathbf{W}_N^H \mathbf{W}_N = N \mathbf{I}$</p>
                </div>

                <div class="theorem">
                    <h4>üßÆ Properties of the DFT Matrix</h4>
                    <div style="margin: 15px 0;">
                        <p><strong>1. Periodicity:</strong> $W_N^{k(n+N)} = W_N^{kn}$ and $W_N^{(k+N)n} = W_N^{kn}$</p>
                        <p><strong>2. Symmetry:</strong> $W_N^{kn} = W_N^{nk}$ (the DFT matrix is symmetric)</p>
                        <p><strong>3. Complex Conjugate:</strong> $W_N^{-kn} = (W_N^{kn})^* = W_N^{N-kn}$</p>
                        <p><strong>4. Orthogonality:</strong> $\sum_{n=0}^{N-1} W_N^{(k-l)n} = \begin{cases} N & \text{if } k-l \equiv 0 \pmod{N} \\ 0 & \text{otherwise} \end{cases}$</p>
                    </div>
                </div>

                <div class="example">
                    <h4>üìä Computational Complexity Analysis</h4>
                    <p><strong>Direct DFT Computation:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Each $X[k]$ requires $N$ complex multiplications and $N-1$ complex additions</li>
                        <li>Total for all $N$ outputs: $N^2$ complex multiplications, $N(N-1)$ complex additions</li>
                        <li><strong>Complexity:</strong> $\Theta(N^2)$ operations</li>
                        <li><strong>Memory:</strong> $O(N)$ for input/output, $O(1)$ auxiliary space</li>
                    </ul>
                    
                    <div style="text-align: center; margin: 15px 0; background: rgba(255,0,0,0.1); padding: 15px; border-radius: 8px;">
                        <strong>Problem:</strong> For $N = 2^{20} = 1,048,576$, direct DFT needs $\approx 10^{12}$ operations!
                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h2>2. The Fast Fourier Transform - Mathematical Derivation</h2>

                <div class="theorem">
                    <h4>üéØ Core Insight: Exploiting Symmetry</h4>
                    <p>The FFT exploits two fundamental properties of roots of unity:</p>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>1. Cancellation Property:</strong> $W_{2N}^{k+N} = -W_{2N}^k$</p>
                        <p><strong>2. Halving Property:</strong> $W_{2N}^{2k} = W_N^k$</p>
                        
                        <div style="text-align: center; margin: 10px 0;">
                            <strong>Proof:</strong>
                            $$W_{2N}^{k+N} = e^{-j\frac{2\pi(k+N)}{2N}} = e^{-j\frac{2\pi k}{2N}} \cdot e^{-j\pi} = -W_{2N}^k$$
                            $$W_{2N}^{2k} = e^{-j\frac{2\pi \cdot 2k}{2N}} = e^{-j\frac{2\pi k}{N}} = W_N^k$$
                        </div>
                    </div>
                </div>

                <div class="algorithm-box">
                    <h4>üîÑ Cooley-Tukey Decimation-in-Time Algorithm</h4>
                    
                    <p><strong>Step 1: Decomposition by Index Parity</strong></p>
                    <p>Split the DFT sum into even and odd indexed terms:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k] = \sum_{n=0}^{N-1} x[n] W_N^{kn} = \sum_{n=0}^{N/2-1} x[2n] W_N^{k(2n)} + \sum_{n=0}^{N/2-1} x[2n+1] W_N^{k(2n+1)}$$
                        
                        $$= \sum_{n=0}^{N/2-1} x[2n] W_{N/2}^{kn} + W_N^k \sum_{n=0}^{N/2-1} x[2n+1] W_{N/2}^{kn}$$
                        
                        $$= E[k] + W_N^k \cdot O[k]$$
                    </div>
                    
                    <p>Where:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>$E[k]$ = DFT of even-indexed samples $\{x[0], x[2], x[4], \ldots\}$</li>
                        <li>$O[k]$ = DFT of odd-indexed samples $\{x[1], x[3], x[5], \ldots\}$</li>
                        <li>Both $E[k]$ and $O[k]$ are periodic with period $N/2$</li>
                    </ul>

                    <p><strong>Step 2: Exploit Periodicity</strong></p>
                    <p>Since $E[k]$ and $O[k]$ have period $N/2$:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k] = E[k \bmod N/2] + W_N^k \cdot O[k \bmod N/2], \quad k = 0, 1, \ldots, N/2-1$$
                        $$X[k + N/2] = E[k] - W_N^k \cdot O[k], \quad k = 0, 1, \ldots, N/2-1$$
                    </div>
                    
                    <p><strong>Key insight:</strong> Using the cancellation property $W_N^{k+N/2} = -W_N^k$</p>
                </div>

                <div class="theorem">
                    <h4>ü¶ã The Butterfly Operation</h4>
                    <p>The core computational unit of FFT:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$\begin{align}
                        Y_0 &= X_0 + W \cdot X_1 \\
                        Y_1 &= X_0 - W \cdot X_1
                        \end{align}$$
                        
                        <p>In matrix form:</p>
                        $$\begin{bmatrix} Y_0 \\ Y_1 \end{bmatrix} = \begin{bmatrix} 1 & W \\ 1 & -W \end{bmatrix} \begin{bmatrix} X_0 \\ X_1 \end{bmatrix}$$
                    </div>
                    
                    <p><strong>Computational cost:</strong> 1 complex multiplication + 2 complex additions</p>
                    <p><strong>Compare with direct:</strong> 2 complex multiplications + 2 complex additions</p>
                </div>

                <div class="example">
                    <h4>üìà Complexity Recurrence Relation</h4>
                    <p>Let $T(N)$ be the number of operations for FFT of size $N$:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$T(N) = 2T(N/2) + O(N)$$
                        
                        <p><strong>Solving the recurrence:</strong></p>
                        $$T(N) = 2T(N/2) + cN$$
                        $$= 2[2T(N/4) + cN/2] + cN = 4T(N/4) + 2cN$$
                        $$= \ldots = NT(1) + cN \log_2 N$$
                        $$= O(N \log N)$$
                    </div>
                    
                    <p><strong>Exact operation count:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Complex multiplications: $\frac{N}{2} \log_2 N$</li>
                        <li>Complex additions: $N \log_2 N$</li>
                        <li>Total: $\frac{3N}{2} \log_2 N$ complex operations</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>3. Advanced FFT Algorithms</h2>

                <div class="algorithm-box">
                    <h4>üé™ Decimation-in-Frequency (DIF) Algorithm</h4>
                    <p>Alternative decomposition strategy:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k] = \sum_{n=0}^{N/2-1} x[n] W_N^{kn} + \sum_{n=N/2}^{N-1} x[n] W_N^{kn}$$
                        
                        $$= \sum_{n=0}^{N/2-1} x[n] W_N^{kn} + W_N^{kN/2} \sum_{n=0}^{N/2-1} x[n+N/2] W_N^{kn}$$
                        
                        $$= \sum_{n=0}^{N/2-1} [x[n] + (-1)^k x[n+N/2]] W_N^{kn}$$
                    </div>
                    
                    <p><strong>For even k:</strong> $X[2r] = \sum_{n=0}^{N/2-1} [x[n] + x[n+N/2]] W_{N/2}^{rn}$</p>
                    <p><strong>For odd k:</strong> $X[2r+1] = \sum_{n=0}^{N/2-1} [x[n] - x[n+N/2]] W_N^n W_{N/2}^{rn}$</p>
                </div>

                <div class="theorem">
                    <h4>üî¢ Mixed-Radix FFT</h4>
                    <p>For $N = p \cdot q$ where $p, q$ are coprime:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k_1 q + k_2 p] = \sum_{n_1=0}^{p-1} \sum_{n_2=0}^{q-1} x[n_1 q + n_2 p] W_N^{(k_1 q + k_2 p)(n_1 q + n_2 p)}$$
                        
                        <p>Using Chinese Remainder Theorem mapping:</p>
                        $$n = n_1 q + n_2 p \bmod N, \quad k = k_1 q + k_2 p \bmod N$$
                    </div>
                    
                    <p><strong>Complexity:</strong> $O(N(\log p + \log q)) = O(N \log N)$ when $p, q = O(\sqrt{N})$</p>
                </div>

                <div class="algorithm-box">
                    <h4>üåÄ Prime Factor Algorithm (PFA)</h4>
                    <p>For $N = \prod_{i=1}^r p_i$ with pairwise coprime $p_i$:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$\text{DFT}_N = \text{DFT}_{p_1} \otimes \text{DFT}_{p_2} \otimes \cdots \otimes \text{DFT}_{p_r}$$
                        
                        <p>Total multiplications: $\sum_{i=1}^r N p_i$ (no twiddle factors!)</p>
                    </div>
                    
                    <p><strong>Advantage:</strong> Minimal multiplication count</p>
                    <p><strong>Disadvantage:</strong> Complex indexing, limited to special lengths</p>
                </div>

                <div class="example">
                    <h4>üéµ Chirp Z-Transform (CZT)</h4>
                    <p>Generalization for arbitrary frequency grids:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$X[k] = \sum_{n=0}^{N-1} x[n] z_k^{-n}, \quad z_k = AW^{-k}$$
                        
                        <p>Where $A$ is starting point, $W$ is step size in z-plane</p>
                        <p>Rewrite as convolution:</p>
                        $$X[k] = W^{k^2/2} \sum_{n=0}^{N-1} [x[n] W^{n^2/2}] W^{-(k-n)^2/2}$$
                    </div>
                    
                    <p><strong>Applications:</strong> Zoom FFT, arbitrary frequency resolution, filter design</p>
                </div>
            </div>

            <div class="theory-section">
                <h2>4. Error Analysis and Numerical Considerations</h2>

                <div class="theorem">
                    <h4>üéØ Floating Point Error Analysis</h4>
                    <p>FFT error propagation in finite precision arithmetic:</p>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>Round-off error bound:</strong></p>
                        $$\|\hat{X} - X\|_2 \leq C \cdot \log_2 N \cdot \epsilon \cdot \|x\|_2$$
                        
                        <p>Where:</p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li>$\hat{X}$ = computed FFT</li>
                            <li>$X$ = exact FFT</li>
                            <li>$\epsilon$ = machine precision</li>
                            <li>$C$ = constant ‚âà 2</li>
                        </ul>
                    </div>
                    
                    <p><strong>Key insight:</strong> Error grows logarithmically with $N$, not linearly!</p>
                </div>

                <div class="algorithm-box">
                    <h4>üîß Implementation Optimizations</h4>
                    
                    <p><strong>1. Bit-Reversal Permutation</strong></p>
                    <div style="margin: 10px 0;">
                        <p>In-place FFT requires bit-reversed input ordering:</p>
                        <div style="font-family: monospace; background: rgba(0,0,0,0.2); padding: 10px; margin: 10px 0;">
                            Index: 0 1 2 3 4 5 6 7<br>
                            Binary: 000 001 010 011 100 101 110 111<br>
                            Reversed: 000 100 010 110 001 101 011 111<br>
                            New Index: 0 4 2 6 1 5 3 7
                        </div>
                    </div>
                    
                    <p><strong>2. Twiddle Factor Optimization</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Precomputation:</strong> Store $W_N^k$ values in lookup table</li>
                        <li><strong>Symmetry exploitation:</strong> $W_N^{k+N/2} = -W_N^k$</li>
                        <li><strong>Quarter-wave symmetry:</strong> $W_N^{k+N/4} = jW_N^k$</li>
                        <li><strong>Recursive generation:</strong> $W_N^{k+1} = W_N^k \cdot W_N$</li>
                    </ul>

                    <p><strong>3. Cache-Aware Algorithms</strong></p>
                    <div style="margin: 10px 0; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                        <p><strong>Cache blocking:</strong> Process data in cache-sized chunks</p>
                        <p><strong>Memory access pattern:</strong> Minimize stride and maximize locality</p>
                        <p><strong>SIMD vectorization:</strong> Process multiple butterflies in parallel</p>
                    </div>
                </div>

                <div class="example">
                    <h4>‚ö° Modern Hardware Acceleration</h4>
                    
                    <p><strong>SIMD Instructions (AVX-512):</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Process 8 complex numbers simultaneously</li>
                        <li>Specialized complex multiplication instructions</li>
                        <li>Fused multiply-add operations</li>
                        <li>Up to 8√ó speedup for butterfly operations</li>
                    </ul>
                    
                    <p><strong>GPU Acceleration:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Massive parallelism:</strong> Thousands of concurrent threads</li>
                        <li><strong>Shared memory:</strong> Fast on-chip memory for data sharing</li>
                        <li><strong>Coalesced access:</strong> Optimized memory bandwidth</li>
                        <li><strong>cuFFT library:</strong> Highly optimized implementations</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>5. The Computational Challenge</h2>
                
                <div class="definition">
                    <h4>The DFT Computational Problem</h4>
                    <p>The Discrete Fourier Transform (DFT) of a sequence $x[n]$ of length $N$ is:</p>
                    <div style="text-align: center; margin: 15px 0;">
                        $$X[k] = \sum_{n=0}^{N-1} x[n] e^{-j\frac{2\pi kn}{N}}, \quad k = 0, 1, \ldots, N-1$$
                    </div>
                    <p><strong>Computational Complexity:</strong> Direct computation requires $O(N^2)$ operations!</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>For each of $N$ frequency bins</li>
                        <li>Sum over all $N$ time samples</li>
                        <li>Each involves complex multiplication</li>
                        <li><strong>Total:</strong> $N^2$ complex multiplications</li>
                    </ul>
                </div>

                <div class="complexity-comparison">
                    <div class="complexity-card">
                        <h4>Before FFT (Direct DFT)</h4>
                        <p><strong>Complexity:</strong> $O(N^2)$</p>
                        <p><strong>Example:</strong> $N = 1024$</p>
                        <p>Operations: $1024^2 = 1,048,576$</p>
                        <p><strong>Status:</strong> Impractical for large signals</p>
                    </div>

                    <div class="complexity-card">
                        <h4>After FFT Revolution</h4>
                        <p><strong>Complexity:</strong> $O(N \log N)$</p>
                        <p><strong>Example:</strong> $N = 1024$</p>
                        <p>Operations: $1024 \times 10 = 10,240$</p>
                        <p><strong>Speedup:</strong> 100√ó faster!</p>
                    </div>
                </div>

                <div class="example">
                    <h4>Real-world Impact</h4>
                    <p>This computational breakthrough enabled:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Real-time audio processing:</strong> MP3, Spotify, voice recognition</li>
                        <li><strong>Digital communications:</strong> WiFi, 4G/5G, satellite communications</li>
                        <li><strong>Medical imaging:</strong> MRI, CT scans, ultrasound</li>
                        <li><strong>Scientific computing:</strong> Climate modeling, astronomy, physics simulations</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>6. Historical Context and Impact</h2>

                <div class="example">
                    <h4>üìö Historical Development</h4>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>1805:</strong> Gauss discovers FFT-like algorithm for trigonometric interpolation</p>
                        <p><strong>1965:</strong> Cooley & Tukey rediscover and popularize the FFT</p>
                        <p><strong>1968:</strong> Sande & Tukey develop decimation-in-frequency algorithm</p>
                        <p><strong>1976:</strong> Winograd introduces multiplicative complexity theory</p>
                        <p><strong>1997:</strong> FFTW library introduces adaptive algorithm selection</p>
                    </div>
                </div>

                <div class="theorem">
                    <h4>üéñÔ∏è The "Algorithm of the Century"</h4>
                    <p>IEEE Computing in Science & Engineering named FFT one of the top 10 algorithms of the 20th century</p>
                    
                    <p><strong>Transformative Impact:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Digital Revolution:</strong> Enabled real-time digital signal processing</li>
                        <li><strong>Communications:</strong> Modern telecommunications infrastructure</li>
                        <li><strong>Medical Imaging:</strong> MRI, CT scans, ultrasound processing</li>
                        <li><strong>Scientific Computing:</strong> Spectral methods for PDEs</li>
                        <li><strong>Entertainment:</strong> Digital audio, video compression, CGI</li>
                    </ul>
                </div>

                <div class="algorithm-box">
                    <h4>üî¨ Theoretical Foundations</h4>
                    
                    <p><strong>Connection to Number Theory:</strong></p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$\text{DFT matrix entries: } [\mathbf{W}_N]_{j,k} = \omega_N^{jk}$$
                        $$\text{where } \omega_N = e^{-2\pi i/N} \text{ is primitive } N\text{-th root of unity}$$
                        
                        <p><strong>Group Theory Connection:</strong></p>
                        $$\{\omega_N^k : k = 0, 1, \ldots, N-1\} \text{ forms cyclic group } \mathbb{Z}_N$$
                    </div>
                    
                    <p><strong>Connection to Polynomial Multiplication:</strong></p>
                    <div style="margin: 10px 0;">
                        <p>FFT enables fast polynomial multiplication via convolution theorem:</p>
                        <div style="text-align: center; margin: 10px 0;">
                            $$(f * g)[n] = \mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\}$$
                        </div>
                        <p>Applications: Large integer multiplication, symbolic computation</p>
                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h2>7. Advanced Applications and Modern Extensions</h2>

                <div class="algorithm-box">
                    <h4>üåä Multidimensional FFT</h4>
                    <p>Extension to 2D, 3D, and higher dimensions:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>2D FFT:</strong></p>
                        $$X[k_1, k_2] = \sum_{n_1=0}^{N_1-1} \sum_{n_2=0}^{N_2-1} x[n_1, n_2] e^{-j2\pi(k_1 n_1/N_1 + k_2 n_2/N_2)}$$
                        
                        <p><strong>Separable implementation:</strong></p>
                        $$X = \mathcal{F}_{N_2} (\mathcal{F}_{N_1} (x^T))^T$$
                    </div>
                    
                    <p><strong>Applications:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Image processing:</strong> 2D filtering, compression, enhancement</li>
                        <li><strong>Computer graphics:</strong> Texture synthesis, procedural generation</li>
                        <li><strong>Scientific simulation:</strong> 3D fluid dynamics, electromagnetics</li>
                        <li><strong>Medical imaging:</strong> 3D reconstruction, volumetric processing</li>
                    </ul>
                </div>

                <div class="theorem">
                    <h4>üé≠ Non-Uniform FFT (NUFFT)</h4>
                    <p>Extension to irregularly spaced samples:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$F_j = \sum_{k=0}^{N-1} f_k e^{-i k x_j}, \quad j = 1, \ldots, M$$
                        
                        <p>where $x_j$ are non-uniformly distributed points</p>
                        
                        <p><strong>Type 1 NUFFT:</strong> Non-uniform time, uniform frequency</p>
                        <p><strong>Type 2 NUFFT:</strong> Uniform time, non-uniform frequency</p>
                        <p><strong>Type 3 NUFFT:</strong> Non-uniform time and frequency</p>
                    </div>
                    
                    <p><strong>Key technique:</strong> Gridding with Kaiser-Bessel kernel + oversampled FFT</p>
                    <p><strong>Complexity:</strong> $O((N + M) \log N)$ with controllable accuracy</p>
                </div>

                <div class="example">
                    <h4>‚ö° Sparse FFT</h4>
                    <p>For signals with few significant frequencies:</p>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>Problem:</strong> Compute $s$-sparse DFT of length-$N$ signal</p>
                        <p><strong>Classical FFT:</strong> $O(N \log N)$ time</p>
                        <p><strong>Sparse FFT:</strong> $O(s \log N)$ time</p>
                        
                        <p><strong>Key insight:</strong> Random sampling + aliasing techniques</p>
                        <p><strong>Applications:</strong> Compressed sensing, radar, spectrum sensing</p>
                    </div>
                </div>

                <div class="algorithm-box">
                    <h4>üîÑ Sliding Window FFT</h4>
                    <p>Efficient computation for streaming data:</p>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>Problem:</strong> Compute overlapping FFTs efficiently</p>
                        <p><strong>Naive approach:</strong> $O(N \log N)$ per window</p>
                        <p><strong>Sliding FFT:</strong> $O(1)$ per sample update</p>
                        
                        <div style="text-align: center; margin: 10px 0;">
                            $$X_{new}[k] = e^{j2\pi k/N}(X_{old}[k] - x_{old} + x_{new})$$
                        </div>
                        
                        <p><strong>Applications:</strong> Real-time spectrum analysis, audio processing</p>
                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h2>8. Quantum FFT and Future Directions</h2>

                <div class="theorem">
                    <h4>üîÆ Quantum Fourier Transform</h4>
                    <p>Quantum analog with exponential speedup potential:</p>
                    <div style="text-align: center; margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        $$\text{QFT}|j\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i jk/N} |k\rangle$$
                        
                        <p><strong>Quantum circuit depth:</strong> $O((\log N)^2)$</p>
                        <p><strong>Classical simulation:</strong> $O(N \log N)$ (no advantage)</p>
                        <p><strong>Quantum advantage:</strong> In specific algorithmic contexts</p>
                    </div>
                    
                    <p><strong>Applications:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Shor's algorithm:</strong> Integer factorization</li>
                        <li><strong>Phase estimation:</strong> Quantum eigenvalue problems</li>
                        <li><strong>Quantum simulation:</strong> Many-body physics</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>üöÄ Emerging Trends and Future Research</h4>
                    
                    <p><strong>Machine Learning Integration:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Learned FFT:</strong> Neural networks learn optimal transforms</li>
                        <li><strong>Approximate FFT:</strong> Trade accuracy for speed using ML</li>
                        <li><strong>FFT in neural networks:</strong> Spectral convolutions, global receptive fields</li>
                    </ul>
                    
                    <p><strong>Hardware Acceleration:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Neuromorphic FFT:</strong> Spike-based signal processing</li>
                        <li><strong>Optical FFT:</strong> Photonic computing implementations</li>
                        <li><strong>DNA FFT:</strong> Biological computing approaches</li>
                    </ul>
                    
                    <p><strong>Theoretical Advances:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Butterfly networks:</strong> Communication-optimal algorithms</li>
                        <li><strong>Cache-oblivious FFT:</strong> Optimal for all memory hierarchies</li>
                        <li><strong>Distributed FFT:</strong> Exascale computing implementations</li>
                    </ul>
                </div>

                <div class="algorithm-box">
                    <h4>üìä Performance Comparison Summary</h4>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <table style="width: 100%; border-collapse: collapse; color: white;">
                            <tr>
                                <th style="border: 1px solid #444; padding: 8px;">Algorithm</th>
                                <th style="border: 1px solid #444; padding: 8px;">Complexity</th>
                                <th style="border: 1px solid #444; padding: 8px;">Multiplications</th>
                                <th style="border: 1px solid #444; padding: 8px;">Best Use Case</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px;">Direct DFT</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(N^2)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">$N^2$</td>
                                <td style="border: 1px solid #444; padding: 8px;">Very small $N$</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px;">Radix-2 FFT</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(N \log N)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">$\frac{N}{2} \log_2 N$</td>
                                <td style="border: 1px solid #444; padding: 8px;">$N = 2^k$</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px;">Mixed-Radix</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(N \log N)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">Varies</td>
                                <td style="border: 1px solid #444; padding: 8px;">Composite $N$</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px;">Prime Factor</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(N \log \log N)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">Minimal</td>
                                <td style="border: 1px solid #444; padding: 8px;">Coprime factors</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px;">Sparse FFT</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(s \log N)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">$O(s \log N)$</td>
                                <td style="border: 1px solid #444; padding: 8px;">$s$-sparse signals</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>

            <div class="theory-section">

                <div class="theorem">
                    <h4>Divide and Conquer Strategy</h4>
                    <p>The FFT exploits the <strong>symmetry and periodicity</strong> of complex exponentials.</p>
                    <p><strong>Key insight:</strong> Split the DFT computation into smaller sub-problems.</p>
                </div>

                <h3>Cooley-Tukey Algorithm (Radix-2)</h3>
                <div class="algorithm-box">
                    <h4>Step 1: Split into Even and Odd Indices</h4>
                    <p>For $N = 2^m$, split $x[n]$ into two sequences:</p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$x_{\text{even}}[n] = x[2n], \quad x_{\text{odd}}[n] = x[2n+1]$$
                    </div>
                    <p>Each of length $N/2$</p>
                </div>

                <div class="algorithm-box">
                    <h4>Step 2: Recursive DFT Computation</h4>
                    <div style="text-align: center; margin: 10px 0;">
                        $$X[k] = E[k] + W_N^k \cdot O[k]$$
                        $$X[k + N/2] = E[k] - W_N^k \cdot O[k]$$
                    </div>
                    <p>where:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>$E[k]$ = DFT of even-indexed samples</li>
                        <li>$O[k]$ = DFT of odd-indexed samples</li>
                        <li>$W_N^k = e^{-j\frac{2\pi k}{N}}$ = twiddle factor</li>
                    </ul>
                </div>

                <div class="algorithm-box">
                    <h4>Step 3: Butterfly Operations</h4>
                    <p>The core FFT computation is the <strong>"butterfly"</strong>:</p>
                    <div style="text-align: center; margin: 10px 0;">
                        $$\begin{bmatrix} Y_0 \\ Y_1 \end{bmatrix} = \begin{bmatrix} 1 & W \\ 1 & -W \end{bmatrix} \begin{bmatrix} X_0 \\ X_1 \end{bmatrix}$$
                    </div>
                    <p>Two complex additions and one complex multiplication!</p>
                </div>

                <div class="example">
                    <h4>Complexity Analysis</h4>
                    <p><strong>Recursive structure:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Problem size reduces by factor of 2 each level</li>
                        <li>Number of levels: $\log_2 N$</li>
                        <li>Work per level: $O(N)$ butterfly operations</li>
                        <li><strong>Total complexity:</strong> $O(N \log N)$</li>
                    </ul>
                </div>

                <h3>Pseudocode</h3>
                <div class="code-block">
function FFT(x):
    N = length(x)
    if N == 1:
        return x
    
    // Divide
    even = FFT([x[0], x[2], x[4], ...])
    odd = FFT([x[1], x[3], x[5], ...])
    
    // Conquer
    X = zeros(N)
    for k = 0 to N/2-1:
        twiddle = exp(-2œÄjk/N)
        X[k] = even[k] + twiddle * odd[k]
        X[k + N/2] = even[k] - twiddle * odd[k]
    
    return X
                </div>
            </div>

            <div class="theory-section">
                <h2>3. FFT Variants and Optimizations</h2>

                <div class="complexity-comparison">
                    <div class="complexity-card">
                        <h4>Radix-2 FFT</h4>
                        <p><strong>Requirement:</strong> $N = 2^m$</p>
                        <p><strong>Most common</strong> implementation</p>
                        <p><strong>Memory:</strong> In-place possible</p>
                        <p><strong>Use:</strong> Power-of-2 signal lengths</p>
                    </div>

                    <div class="complexity-card">
                        <h4>Mixed-Radix FFT</h4>
                        <p><strong>Requirement:</strong> $N = r_1^{a_1} \times r_2^{a_2} \times \ldots$</p>
                        <p><strong>Flexibility:</strong> Any composite length</p>
                        <p><strong>Memory:</strong> More complex indexing</p>
                        <p><strong>Use:</strong> Non-power-of-2 lengths</p>
                    </div>

                    <div class="complexity-card">
                        <h4>Prime Factor FFT</h4>
                        <p><strong>Requirement:</strong> $N$ with coprime factors</p>
                        <p><strong>Method:</strong> Chinese Remainder Theorem</p>
                        <p><strong>Advantage:</strong> No multiplications by roots of unity</p>
                        <p><strong>Use:</strong> Specific composite lengths</p>
                    </div>

                    <div class="complexity-card">
                        <h4>Chirp Z-Transform</h4>
                        <p><strong>Requirement:</strong> Any $N$</p>
                        <p><strong>Method:</strong> Convolution-based</p>
                        <p><strong>Flexibility:</strong> Non-uniform frequency grids</p>
                        <p><strong>Use:</strong> Arbitrary signal lengths</p>
                    </div>
                </div>

                <h3>Modern Optimizations</h3>
                <div class="example">
                    <h4>FFTW (Fastest Fourier Transform in the West)</h4>
                    <p>Advanced optimization techniques:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Plan optimization:</strong> Benchmark different algorithms for specific sizes</li>
                        <li><strong>SIMD instructions:</strong> Vectorized operations on modern CPUs</li>
                        <li><strong>Cache-aware algorithms:</strong> Optimize memory access patterns</li>
                        <li><strong>Multithreading:</strong> Parallel computation for large transforms</li>
                        <li><strong>Prime factorization:</strong> Optimal algorithm selection</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>9. Classic Applications and Real-World Impact</h2>

                <h3>Digital Signal Processing</h3>
                <div class="example">
                    <h4>Audio Processing</h4>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>MP3 Compression:</strong> Frequency domain analysis for perceptual coding</li>
                        <li><strong>Equalizers:</strong> Real-time frequency response modification</li>
                        <li><strong>Noise Reduction:</strong> Spectral subtraction and Wiener filtering</li>
                        <li><strong>Pitch Detection:</strong> Autocorrelation via FFT convolution</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Image Processing</h4>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>JPEG Compression:</strong> 2D DCT (related to FFT)</li>
                        <li><strong>Image Filtering:</strong> Convolution via frequency domain multiplication</li>
                        <li><strong>Feature Detection:</strong> Template matching in frequency domain</li>
                        <li><strong>Denoising:</strong> Frequency domain filtering</li>
                    </ul>
                </div>

                <h3>Communications Systems</h3>
                <div class="example">
                    <h4>Modern Digital Communications</h4>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>OFDM:</strong> WiFi, 4G/5G use FFT for orthogonal subcarriers</li>
                        <li><strong>Channel Estimation:</strong> Frequency response characterization</li>
                        <li><strong>Spectrum Analysis:</strong> Real-time frequency monitoring</li>
                        <li><strong>Radar Processing:</strong> Range and Doppler estimation</li>
                    </ul>
                </div>

                <h3>Scientific Computing</h3>
                <div class="example">
                    <h4>Solving Differential Equations</h4>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Spectral Methods:</strong> FFT for spatial derivatives</li>
                        <li><strong>Heat Equation:</strong> Efficient solution in frequency domain</li>
                        <li><strong>Wave Equations:</strong> Dispersion relation analysis</li>
                        <li><strong>Fluid Dynamics:</strong> Turbulence simulation</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>10. Implementation Considerations</h2>

                <h3>Numerical Precision</h3>
                <div class="theorem">
                    <h4>Floating Point Considerations</h4>
                    <p>FFT computation involves:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Complex arithmetic:</strong> Error accumulation in recursive computation</li>
                        <li><strong>Twiddle factors:</strong> Precomputed vs. on-the-fly calculation</li>
                        <li><strong>Bit-reversal:</strong> Index permutation for in-place algorithms</li>
                        <li><strong>Scaling:</strong> Preventing overflow in fixed-point implementations</li>
                    </ul>
                </div>

                <h3>Memory Access Patterns</h3>
                <div class="algorithm-box">
                    <h4>Cache Optimization</h4>
                    <p><strong>Decimation-in-time vs. Decimation-in-frequency:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>DIT:</strong> Input bit-reversed, output in order</li>
                        <li><strong>DIF:</strong> Input in order, output bit-reversed</li>
                        <li><strong>Cache blocking:</strong> Minimize memory bandwidth requirements</li>
                        <li><strong>SIMD-friendly:</strong> Vectorizable butterfly operations</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Modern Hardware Acceleration</h4>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>GPU FFT:</strong> Massive parallelization for large transforms</li>
                        <li><strong>DSP processors:</strong> Specialized hardware for signal processing</li>
                        <li><strong>FPGA implementations:</strong> Custom pipelined architectures</li>
                        <li><strong>AI accelerators:</strong> FFT support in neural network chips</li>
                    </ul>
                </div>
            </div>

            <div class="theory-section">
                <h2>11. Mathematical Summary and Key Insights</h2>

                <div class="theorem">
                    <h4>üéì The FFT Revolution: A Mathematical Perspective</h4>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 25px; border-radius: 10px;">
                        <h4 style="color: #00d4ff; margin-top: 0;">Core Mathematical Breakthrough:</h4>
                        <div style="text-align: center; margin: 15px 0;">
                            $$\boxed{\text{DFT complexity: } O(N^2) \rightarrow O(N \log N)}$$
                        </div>
                        
                        <h4 style="color: #00d4ff;">Fundamental Insights:</h4>
                        <ol style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>Symmetry Exploitation:</strong> $W_N^{k+N/2} = -W_N^k$ (cancellation property)</li>
                            <li><strong>Periodicity:</strong> $W_N^{k+N} = W_N^k$ (reduces computation)</li>
                            <li><strong>Recursion:</strong> Divide-and-conquer on problem structure</li>
                            <li><strong>Matrix Factorization:</strong> $\mathbf{W}_N = \prod_{i=0}^{\log_2 N - 1} \mathbf{B}_i$ (sparse factors)</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <h4>üìä Mathematical Complexity Comparison</h4>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <table style="width: 100%; border-collapse: collapse; color: white; font-size: 14px;">
                            <tr>
                                <th style="border: 1px solid #444; padding: 10px; background: rgba(0,212,255,0.2);">Signal Length $N$</th>
                                <th style="border: 1px solid #444; padding: 10px; background: rgba(0,212,255,0.2);">Direct DFT $O(N^2)$</th>
                                <th style="border: 1px solid #444; padding: 10px; background: rgba(0,212,255,0.2);">FFT $O(N \log N)$</th>
                                <th style="border: 1px solid #444; padding: 10px; background: rgba(0,212,255,0.2);">Speedup Factor</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$2^{10} = 1,024$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 10^6$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 10^4$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center; color: #4CAF50;">$100√ó$</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$2^{16} = 65,536$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 4 √ó 10^9$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 10^6$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center; color: #4CAF50;">$4,000√ó$</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$2^{20} = 1,048,576$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 10^{12}$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center;">$‚âà 2 √ó 10^7$</td>
                                <td style="border: 1px solid #444; padding: 8px; text-align: center; color: #4CAF50;">$50,000√ó$</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="example">
                    <h4>üèÜ Theoretical Contributions</h4>
                    <div style="margin: 15px 0; padding: 20px; background: linear-gradient(45deg, rgba(0,212,255,0.1), rgba(255,107,107,0.1)); border-radius: 10px;">
                        <h4 style="color: #FFD700; margin-top: 0;">Algorithm Design Principles:</h4>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>Divide and Conquer:</strong> Break $O(N^2)$ problem into $O(\log N)$ levels of $O(N)$ work</li>
                            <li><strong>Symmetry Exploitation:</strong> Use mathematical structure to eliminate redundant computation</li>
                            <li><strong>Cache Optimization:</strong> Memory-aware algorithms for modern architectures</li>
                            <li><strong>Parallel Decomposition:</strong> Natural parallelization across frequency bins</li>
                        </ul>
                        
                        <h4 style="color: #FFD700;">Mathematical Foundations:</h4>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>Group Theory:</strong> Cyclic group structure of roots of unity</li>
                            <li><strong>Linear Algebra:</strong> Unitary matrix decomposition and factorization</li>
                            <li><strong>Number Theory:</strong> Prime factorization and Chinese Remainder Theorem</li>
                            <li><strong>Complex Analysis:</strong> Properties of complex exponentials</li>
                        </ul>
                    </div>
                </div>

                <div class="definition">
                    <h4>üéØ The FFT Legacy: Computational Mathematics</h4>
                    <div style="margin: 15px 0; background: rgba(255,215,0,0.1); padding: 20px; border-radius: 10px; border: 2px solid #FFD700;">
                        <p style="font-size: 18px; text-align: center; margin-bottom: 20px; color: #FFD700;">
                            <strong>"The FFT is not just an algorithm; it's a computational paradigm that transformed how we think about mathematical computation."</strong>
                        </p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                            <div>
                                <h4 style="color: #00d4ff; margin-bottom: 10px;">Before FFT (1960s):</h4>
                                <ul style="margin: 0 0 0 20px;">
                                    <li>Real-time DSP impossible</li>
                                    <li>Large transforms impractical</li>
                                    <li>Limited scientific computing</li>
                                    <li>Analog signal processing dominant</li>
                                </ul>
                            </div>
                            <div>
                                <h4 style="color: #4CAF50; margin-bottom: 10px;">After FFT Revolution:</h4>
                                <ul style="margin: 0 0 0 20px;">
                                    <li>Digital audio/video processing</li>
                                    <li>Modern telecommunications</li>
                                    <li>Scientific simulation enabled</li>
                                    <li>Digital signal processing born</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="theorem">
                    <h4>üîÆ Future Mathematical Challenges</h4>
                    <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                        <p><strong>Open Problems and Active Research:</strong></p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li><strong>Lower Bounds:</strong> Is $O(N \log N)$ optimal for general FFT?</li>
                            <li><strong>Quantum Advantage:</strong> When does Quantum FFT provide real speedup?</li>
                            <li><strong>Communication Complexity:</strong> Minimize data movement in distributed FFT</li>
                            <li><strong>Approximate FFT:</strong> Trade-offs between accuracy and speed</li>
                            <li><strong>Non-uniform Sampling:</strong> Optimal algorithms for irregular grids</li>
                            <li><strong>High-dimensional FFT:</strong> Curse of dimensionality mitigation</li>
                        </ul>
                        
                        <div style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,212,255,0.1); border-radius: 8px;">
                            <strong>The mathematical journey continues...</strong><br>
                            <em>From Gauss (1805) ‚Üí Cooley-Tukey (1965) ‚Üí Quantum FFT (1990s) ‚Üí ? (2020s+)</em>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Interactive Section -->
    <div id="interactive" class="section">
        <div class="interactive-container">
            <h1>Interactive FFT Visualization & Performance Analysis</h1>
            
            <div class="controls">
                <div class="control-group">
                    <h3>üéµ Signal Generation</h3>
                    <div class="control-row">
                        <label>Signal Type:</label>
                        <select id="signalType" onchange="generateSignal()">
                            <option value="sine">Pure Sine Wave</option>
                            <option value="multisine">Multi-Sine</option>
                            <option value="chirp">Chirp Signal</option>
                            <option value="noise">White Noise</option>
                            <option value="pulse">Pulse Train</option>
                            <option value="sawtooth">Sawtooth</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Signal Length:</label>
                        <select id="signalLength" onchange="updateSignalLength()">
                            <option value="64">64 samples</option>
                            <option value="128">128 samples</option>
                            <option value="256">256 samples</option>
                            <option value="512" selected>512 samples</option>
                            <option value="1024">1024 samples</option>
                            <option value="2048">2048 samples</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Frequency:</label>
                        <input type="range" id="frequency" min="1" max="50" value="5" oninput="updateFrequency()">
                        <input type="number" id="frequencyValue" value="5" min="1" max="50" onchange="updateFrequency()">
                    </div>
                    <div class="control-row">
                        <label>Amplitude:</label>
                        <input type="range" id="amplitude" min="0.1" max="2" step="0.1" value="1" oninput="updateAmplitude()">
                        <input type="number" id="amplitudeValue" value="1" min="0.1" max="2" step="0.1" onchange="updateAmplitude()">
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚ö° FFT Algorithm</h3>
                    <div class="control-row">
                        <label>Algorithm:</label>
                        <select id="algorithm" onchange="updateAlgorithm()">
                            <option value="radix2">Radix-2 FFT</option>
                            <option value="dft">Direct DFT</option>
                            <option value="mixed">Mixed-Radix</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <button onclick="computeFFT()">üöÄ Compute FFT</button>
                        <button onclick="compareAlgorithms()">üìä Compare Performance</button>
                        <button onclick="animateFFT()">üé¨ Animate Process</button>
                    </div>
                    <div class="control-row">
                        <label>Window Function:</label>
                        <select id="window" onchange="updateWindow()">
                            <option value="rectangular">Rectangular</option>
                            <option value="hanning">Hanning</option>
                            <option value="hamming">Hamming</option>
                            <option value="blackman">Blackman</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üìà Visualization</h3>
                    <div class="control-row">
                        <label>Show Phase:</label>
                        <input type="checkbox" id="showPhase" onchange="updateVisualization()">
                    </div>
                    <div class="control-row">
                        <label>Log Scale:</label>
                        <input type="checkbox" id="logScale" checked onchange="updateVisualization()">
                    </div>
                    <div class="control-row">
                        <label>Zoom Frequency:</label>
                        <input type="range" id="freqZoom" min="0.1" max="1" step="0.1" value="1" oninput="updateVisualization()">
                    </div>
                    <div class="control-row">
                        <button onclick="exportData()">üíæ Export Data</button>
                        <button onclick="resetView()">üîÑ Reset View</button>
                    </div>
                </div>
            </div>

            <div class="signal-visualization">
                <div class="chart-container">
                    <div class="chart-title">Time Domain Signal</div>
                    <canvas id="timeCanvas" width="400" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Frequency Domain (FFT)</div>
                    <canvas id="freqCanvas" width="400" height="300"></canvas>
                </div>
            </div>

            <div class="performance-metrics">
                <div class="metric-card">
                    <div class="metric-value" id="computationTime">0.00</div>
                    <div>Computation Time (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="operationCount">0</div>
                    <div>Complex Operations</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="speedupFactor">1.0√ó</div>
                    <div>Speedup vs DFT</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="memoryUsage">0</div>
                    <div>Memory Usage (KB)</div>
                </div>
            </div>

            <div class="performance-panel">
                <h3>üèÜ Performance Analysis</h3>
                <div id="performanceAnalysis">
                    Select a signal and compute the FFT to see detailed performance analysis including complexity comparison, algorithm efficiency, and computational insights.
                </div>
                
                <h4>üìä Complexity Comparison Chart</h4>
                <div style="text-align: center;">
                    <canvas id="complexityChart" width="600" height="300"></canvas>
                </div>
                
                <h4>üî¨ Algorithm Breakdown</h4>
                <div id="algorithmBreakdown">
                    <p>The FFT algorithm breakdown will appear here after computation, showing:</p>
                    <ul>
                        <li>Number of butterfly operations</li>
                        <li>Recursion depth and stages</li>
                        <li>Memory access patterns</li>
                        <li>Computational complexity analysis</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation functionality
        function showSection(sectionName) {
            // Hide all sections
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Initialize MathJax rendering for theory section
            if (sectionName === 'theory' && window.MathJax) {
                MathJax.typesetPromise();
            }
        }

        // FFT Implementation and Visualization
        let currentSignal = [];
        let currentFFT = [];
        let signalLength = 512;
        let sampleRate = 1000;

        // Complex number operations
        class Complex {
            constructor(real, imag = 0) {
                this.real = real;
                this.imag = imag;
            }
            
            add(other) {
                return new Complex(this.real + other.real, this.imag + other.imag);
            }
            
            subtract(other) {
                return new Complex(this.real - other.real, this.imag - other.imag);
            }
            
            multiply(other) {
                return new Complex(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
            
            phase() {
                return Math.atan2(this.imag, this.real);
            }
        }

        // FFT Implementation (Radix-2)
        function fft(x) {
            const N = x.length;
            if (N <= 1) return x;
            
            // Ensure power of 2
            if (N & (N - 1)) {
                throw new Error('FFT input length must be a power of 2');
            }
            
            // Divide
            const even = [];
            const odd = [];
            for (let i = 0; i < N; i++) {
                if (i % 2 === 0) {
                    even.push(x[i]);
                } else {
                    odd.push(x[i]);
                }
            }
            
            // Conquer
            const evenFFT = fft(even);
            const oddFFT = fft(odd);
            
            // Combine
            const result = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const twiddle = new Complex(
                    Math.cos(-2 * Math.PI * k / N),
                    Math.sin(-2 * Math.PI * k / N)
                );
                const twiddledOdd = twiddle.multiply(oddFFT[k]);
                
                result[k] = evenFFT[k].add(twiddledOdd);
                result[k + N / 2] = evenFFT[k].subtract(twiddledOdd);
            }
            
            return result;
        }

        // Direct DFT implementation for comparison
        function dft(x) {
            const N = x.length;
            const result = new Array(N);
            
            for (let k = 0; k < N; k++) {
                result[k] = new Complex(0, 0);
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const twiddle = new Complex(Math.cos(angle), Math.sin(angle));
                    result[k] = result[k].add(x[n].multiply(twiddle));
                }
            }
            
            return result;
        }

        // Signal generation functions
        function generateSignal() {
            const type = document.getElementById('signalType').value;
            const freq = parseFloat(document.getElementById('frequencyValue').value);
            const amp = parseFloat(document.getElementById('amplitudeValue').value);
            
            currentSignal = [];
            
            for (let n = 0; n < signalLength; n++) {
                const t = n / sampleRate;
                let value = 0;
                
                switch (type) {
                    case 'sine':
                        value = amp * Math.sin(2 * Math.PI * freq * t);
                        break;
                    case 'multisine':
                        value = amp * (Math.sin(2 * Math.PI * freq * t) + 
                                     0.5 * Math.sin(2 * Math.PI * freq * 3 * t) +
                                     0.25 * Math.sin(2 * Math.PI * freq * 5 * t));
                        break;
                    case 'chirp':
                        const chirpRate = freq / signalLength;
                        value = amp * Math.sin(2 * Math.PI * (freq + chirpRate * n) * t);
                        break;
                    case 'noise':
                        value = amp * (Math.random() - 0.5) * 2;
                        break;
                    case 'pulse':
                        value = amp * (n % Math.floor(sampleRate / freq) < 5 ? 1 : 0);
                        break;
                    case 'sawtooth':
                        value = amp * (2 * (t * freq - Math.floor(t * freq + 0.5)));
                        break;
                }
                
                currentSignal.push(new Complex(value, 0));
            }
            
            updateVisualization();
        }

        // Control functions
        function updateSignalLength() {
            signalLength = parseInt(document.getElementById('signalLength').value);
            generateSignal();
        }

        function updateFrequency() {
            const freq = parseFloat(document.getElementById('frequency').value);
            document.getElementById('frequencyValue').value = freq;
            document.getElementById('frequency').value = freq;
            generateSignal();
        }

        function updateAmplitude() {
            const amp = parseFloat(document.getElementById('amplitude').value);
            document.getElementById('amplitudeValue').value = amp;
            document.getElementById('amplitude').value = amp;
            generateSignal();
        }

        function updateAlgorithm() {
            // Algorithm selection logic
            computeFFT();
        }

        function updateWindow() {
            // Apply windowing function
            generateSignal();
        }

        // FFT computation with performance measurement
        function computeFFT() {
            if (currentSignal.length === 0) {
                generateSignal();
            }
            
            const algorithm = document.getElementById('algorithm').value;
            const startTime = performance.now();
            let operationCount = 0;
            
            try {
                switch (algorithm) {
                    case 'radix2':
                        currentFFT = fft([...currentSignal]);
                        operationCount = signalLength * Math.log2(signalLength);
                        break;
                    case 'dft':
                        currentFFT = dft([...currentSignal]);
                        operationCount = signalLength * signalLength;
                        break;
                    case 'mixed':
                        // Simplified mixed-radix (fallback to radix-2)
                        currentFFT = fft([...currentSignal]);
                        operationCount = signalLength * Math.log2(signalLength) * 1.2;
                        break;
                }
                
                const endTime = performance.now();
                const computationTime = endTime - startTime;
                
                // Update performance metrics
                document.getElementById('computationTime').textContent = computationTime.toFixed(2);
                document.getElementById('operationCount').textContent = Math.round(operationCount);
                
                const dftTime = Math.pow(signalLength / 64, 2) * 0.1; // Estimated DFT time
                const speedup = dftTime / computationTime;
                document.getElementById('speedupFactor').textContent = speedup.toFixed(1) + '√ó';
                
                const memoryUsage = (signalLength * 16) / 1024; // Complex numbers, bytes to KB
                document.getElementById('memoryUsage').textContent = memoryUsage.toFixed(1);
                
                updateVisualization();
                updatePerformanceAnalysis(algorithm, computationTime, operationCount);
                
            } catch (error) {
                alert('Error computing FFT: ' + error.message);
            }
        }

        function compareAlgorithms() {
            const algorithms = ['radix2', 'dft'];
            const results = {};
            
            algorithms.forEach(alg => {
                document.getElementById('algorithm').value = alg;
                const startTime = performance.now();
                
                switch (alg) {
                    case 'radix2':
                        fft([...currentSignal]);
                        break;
                    case 'dft':
                        if (signalLength <= 256) { // Limit DFT for performance
                            dft([...currentSignal]);
                        }
                        break;
                }
                
                const endTime = performance.now();
                results[alg] = endTime - startTime;
            });
            
            updateComplexityChart(results);
        }

        function animateFFT() {
            // Simple animation placeholder
            alert('FFT Animation: This would show the divide-and-conquer process step by step, including butterfly operations and bit-reversal indexing.');
        }

        // Visualization functions
        function updateVisualization() {
            drawTimeDomain();
            drawFrequencyDomain();
        }

        function drawTimeDomain() {
            const canvas = document.getElementById('timeCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentSignal.length === 0) return;
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (canvas.width / 10) * i;
                const y = (canvas.height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw signal
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxAmp = Math.max(...currentSignal.map(c => Math.abs(c.real)));
            
            for (let i = 0; i < currentSignal.length; i++) {
                const x = (i / currentSignal.length) * canvas.width;
                const y = canvas.height / 2 - (currentSignal[i].real / maxAmp) * (canvas.height / 2 - 20);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Time ‚Üí', canvas.width - 50, canvas.height - 10);
            ctx.save();
            ctx.translate(15, 50);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Amplitude', 0, 0);
            ctx.restore();
        }

        function drawFrequencyDomain() {
            const canvas = document.getElementById('freqCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentFFT.length === 0) return;
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (canvas.width / 10) * i;
                const y = (canvas.height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Calculate magnitudes
            const magnitudes = currentFFT.slice(0, currentFFT.length / 2).map(c => c.magnitude());
            const logScale = document.getElementById('logScale').checked;
            const showPhase = document.getElementById('showPhase').checked;
            
            let maxMag = Math.max(...magnitudes);
            if (maxMag === 0) maxMag = 1;
            
            // Draw magnitude spectrum
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < magnitudes.length; i++) {
                const x = (i / magnitudes.length) * canvas.width;
                let mag = magnitudes[i];
                
                if (logScale && mag > 0) {
                    mag = Math.log10(mag + 1) / Math.log10(maxMag + 1);
                } else {
                    mag = mag / maxMag;
                }
                
                const y = canvas.height - mag * (canvas.height - 20) - 10;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw phase if enabled
            if (showPhase) {
                const phases = currentFFT.slice(0, currentFFT.length / 2).map(c => c.phase());
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = 0; i < phases.length; i++) {
                    const x = (i / phases.length) * canvas.width;
                    const y = canvas.height / 2 + (phases[i] / Math.PI) * (canvas.height / 4);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Frequency ‚Üí', canvas.width - 70, canvas.height - 10);
            ctx.save();
            ctx.translate(15, 50);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Magnitude', 0, 0);
            ctx.restore();
        }

        function updateComplexityChart(results) {
            const canvas = document.getElementById('complexityChart');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw complexity comparison
            const sizes = [64, 128, 256, 512, 1024];
            const colors = ['#00d4ff', '#ff6b6b', '#66b3ff'];
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (canvas.width / 10) * i;
                const y = (canvas.height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw theoretical complexity curves
            ctx.lineWidth = 2;
            
            // O(N log N) for FFT
            ctx.strokeStyle = colors[0];
            ctx.beginPath();
            sizes.forEach((n, i) => {
                const x = (i / (sizes.length - 1)) * (canvas.width - 60) + 30;
                const complexity = n * Math.log2(n);
                const y = canvas.height - 30 - (complexity / (1024 * Math.log2(1024))) * (canvas.height - 60);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // O(N^2) for DFT
            ctx.strokeStyle = colors[1];
            ctx.beginPath();
            sizes.forEach((n, i) => {
                const x = (i / (sizes.length - 1)) * (canvas.width - 60) + 30;
                const complexity = n * n;
                const y = canvas.height - 30 - (complexity / (1024 * 1024)) * (canvas.height - 60);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Labels and legend
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Signal Length ‚Üí', canvas.width - 100, canvas.height - 10);
            
            // Legend
            ctx.fillStyle = colors[0];
            ctx.fillRect(20, 20, 15, 15);
            ctx.fillStyle = '#333';
            ctx.fillText('FFT O(N log N)', 45, 32);
            
            ctx.fillStyle = colors[1];
            ctx.fillRect(20, 40, 15, 15);
            ctx.fillStyle = '#333';
            ctx.fillText('DFT O(N¬≤)', 45, 52);
        }

        function updatePerformanceAnalysis(algorithm, time, operations) {
            const analysis = document.getElementById('performanceAnalysis');
            const breakdown = document.getElementById('algorithmBreakdown');
            
            let analysisText = `<strong>Algorithm:</strong> ${algorithm.toUpperCase()}<br>`;
            analysisText += `<strong>Computation Time:</strong> ${time.toFixed(2)} ms<br>`;
            analysisText += `<strong>Operations:</strong> ${operations.toLocaleString()}<br>`;
            
            if (algorithm === 'radix2') {
                const stages = Math.log2(signalLength);
                const butterflies = signalLength / 2 * stages;
                analysisText += `<strong>FFT Stages:</strong> ${stages}<br>`;
                analysisText += `<strong>Butterfly Operations:</strong> ${butterflies}<br>`;
                analysisText += `<strong>Theoretical Complexity:</strong> O(N log N)<br>`;
                analysisText += `<strong>Memory Access:</strong> In-place computation possible<br>`;
                
                breakdown.innerHTML = `
                    <p><strong>Radix-2 FFT Analysis:</strong></p>
                    <ul>
                        <li>Recursion depth: ${stages} levels</li>
                        <li>Butterfly operations per stage: ${signalLength / 2}</li>
                        <li>Total multiplications: ${butterflies}</li>
                        <li>Bit-reversal required: ${algorithm === 'radix2' ? 'Yes' : 'No'}</li>
                        <li>Cache efficiency: Good (divide-and-conquer)</li>
                        <li>Parallelization potential: High</li>
                    </ul>
                `;
            } else if (algorithm === 'dft') {
                analysisText += `<strong>Theoretical Complexity:</strong> O(N¬≤)<br>`;
                analysisText += `<strong>Memory Access:</strong> Sequential<br>`;
                analysisText += `<strong>Practical Limit:</strong> ~1000 samples<br>`;
                
                breakdown.innerHTML = `
                    <p><strong>Direct DFT Analysis:</strong></p>
                    <ul>
                        <li>Nested loops: N √ó N operations</li>
                        <li>Complex multiplications: ${signalLength * signalLength}</li>
                        <li>Memory efficiency: Poor for large N</li>
                        <li>Parallelization: Limited to outer loop</li>
                        <li>Numerical precision: Better than FFT</li>
                        <li>Implementation: Straightforward</li>
                    </ul>
                `;
            }
            
            analysis.innerHTML = analysisText;
        }

        function exportData() {
            if (currentFFT.length === 0) {
                alert('Please compute FFT first!');
                return;
            }
            
            const data = {
                timeData: currentSignal.map(c => c.real),
                fftMagnitude: currentFFT.map(c => c.magnitude()),
                fftPhase: currentFFT.map(c => c.phase()),
                sampleRate: sampleRate,
                signalLength: signalLength
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fft_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetView() {
            // Reset all controls to defaults
            document.getElementById('signalType').value = 'sine';
            document.getElementById('signalLength').value = '512';
            document.getElementById('frequency').value = '5';
            document.getElementById('frequencyValue').value = '5';
            document.getElementById('amplitude').value = '1';
            document.getElementById('amplitudeValue').value = '1';
            document.getElementById('algorithm').value = 'radix2';
            document.getElementById('showPhase').checked = false;
            document.getElementById('logScale').checked = true;
            
            // Regenerate signal
            signalLength = 512;
            generateSignal();
            computeFFT();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            generateSignal();
            updateComplexityChart({});
        });

        // Initialize MathJax
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
</body>
</html>
