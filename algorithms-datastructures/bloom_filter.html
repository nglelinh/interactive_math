<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloom Filter - Probabilistic Data Structure</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            min-height: 100vh;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .bloom-filter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        .bit-array {
            display: flex;
            gap: 2px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .bit {
            width: 30px;
            height: 30px;
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .bit.zero {
            background-color: #333;
            color: #fff;
        }
        .bit.one {
            background-color: #4CAF50;
            color: #fff;
        }
        .bit.highlight {
            border-color: #FFD700;
            box-shadow: 0 0 10px #FFD700;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        input[type="text"] {
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            width: 150px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        button:hover {
            background: #45a049;
        }
        button.clear {
            background: #f44336;
        }
        button.clear:hover {
            background: #da190b;
        }
        button.test {
            background: #2196F3;
        }
        button.test:hover {
            background: #1976D2;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .hash-functions {
            margin: 20px 0;
        }
        .hash-function {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        .result {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        .result.positive {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
        }
        .result.negative {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid #f44336;
        }
        .result.maybe {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #FFC107;
            color: #333;
        }
        .theory-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        .formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        .applications {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .application-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        .slider-container {
            margin: 15px 0;
            text-align: center;
        }
        .slider {
            width: 300px;
            margin: 10px;
        }
        .optimization-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üå∏ Bloom Filter - B·ªô L·ªçc X√°c Su·∫•t</h1>
        
        <div class="section">
            <h2>üìñ Bloom Filter l√† g√¨?</h2>
            <p><strong>Bloom Filter</strong> l√† m·ªôt probabilistic data structure ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ki·ªÉm tra xem m·ªôt ph·∫ßn t·ª≠ c√≥ thu·ªôc v·ªÅ m·ªôt t·∫≠p h·ª£p hay kh√¥ng. ƒê√¢y l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu space-efficient nh∆∞ng c√≥ th·ªÉ cho false positives (nh∆∞ng kh√¥ng bao gi·ªù false negatives).</p>
            
            <div class="theory-section">
                <h3>üîç ƒê·∫∑c ƒëi·ªÉm ch√≠nh:</h3>
                <ul>
                    <li><strong>Space efficient:</strong> S·ª≠ d·ª•ng √≠t b·ªô nh·ªõ h∆°n set th√¥ng th∆∞·ªùng</li>
                    <li><strong>Fast operations:</strong> Insert v√† lookup ƒë·ªÅu O(k) v·ªõi k l√† s·ªë hash functions</li>
                    <li><strong>False positives possible:</strong> C√≥ th·ªÉ n√≥i "c√≥ th·ªÉ c√≥" khi th·ª±c t·∫ø kh√¥ng c√≥</li>
                    <li><strong>No false negatives:</strong> N·∫øu n√≥i "kh√¥ng c√≥" th√¨ ch·∫Øc ch·∫Øn kh√¥ng c√≥</li>
                    <li><strong>Cannot delete:</strong> Kh√¥ng th·ªÉ x√≥a ph·∫ßn t·ª≠ ƒë√£ th√™m</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>üéÆ Interactive Bloom Filter Demo</h2>
            
            <div class="optimization-panel">
                <h3>‚öôÔ∏è T·ªëi ∆∞u h√≥a tham s·ªë</h3>
                <div class="slider-container">
                    <label>K√≠ch th∆∞·ªõc bit array (m): <span id="sizeValue">100</span></label><br>
                    <input type="range" id="sizeSlider" class="slider" min="50" max="200" value="100">
                </div>
                <div class="slider-container">
                    <label>S·ªë hash functions (k): <span id="hashValue">3</span></label><br>
                    <input type="range" id="hashSlider" class="slider" min="1" max="7" value="3">
                </div>
                <div class="slider-container">
                    <label>S·ªë ph·∫ßn t·ª≠ d·ª± ki·∫øn (n): <span id="elementsValue">20</span></label><br>
                    <input type="range" id="elementsSlider" class="slider" min="5" max="50" value="20">
                </div>
                <div id="falsePositiveRate" class="formula"></div>
            </div>

            <div class="bloom-filter-container">
                <div class="controls">
                    <input type="text" id="inputElement" placeholder="Nh·∫≠p ph·∫ßn t·ª≠...">
                    <button onclick="addElement()">Th√™m v√†o Filter</button>
                    <button onclick="testElement()" class="test">Ki·ªÉm tra c√≥ t·ªìn t·∫°i?</button>
                    <button onclick="clearFilter()" class="clear">X√≥a Filter</button>
                </div>
                
                <div id="bitArray" class="bit-array"></div>
                
                <div id="hashFunctions" class="hash-functions">
                    <h4>üî® Hash Functions ƒë∆∞·ª£c s·ª≠ d·ª•ng:</h4>
                </div>
                
                <div id="result"></div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <h4>üìä S·ªë ph·∫ßn t·ª≠ ƒë√£ th√™m</h4>
                    <div id="elementsAdded">0</div>
                </div>
                <div class="stat-card">
                    <h4>üéØ Bits ƒë∆∞·ª£c set</h4>
                    <div id="bitsSet">0</div>
                </div>
                <div class="stat-card">
                    <h4>üìà Load factor</h4>
                    <div id="loadFactor">0%</div>
                </div>
                <div class="stat-card">
                    <h4>‚ö†Ô∏è False positive rate</h4>
                    <div id="currentFPR">0%</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üìê To√°n h·ªçc ƒë·∫±ng sau Bloom Filter</h2>
            <div class="theory-section">
                <h3>üßÆ C√¥ng th·ª©c t√≠nh to√°n:</h3>
                
                <div class="formula">
                    <strong>False Positive Rate:</strong><br>
                    \( P_{fp} = \left(1 - e^{-kn/m}\right)^k \)
                </div>
                
                <div class="formula">
                    <strong>Optimal number of hash functions:</strong><br>
                    \( k_{opt} = \frac{m}{n} \ln(2) \)
                </div>
                
                <div class="formula">
                    <strong>Optimal bit array size:</strong><br>
                    \( m_{opt} = -\frac{n \ln(P_{fp})}{\ln^2(2)} \)
                </div>
                
                <p><strong>Gi·∫£i th√≠ch:</strong></p>
                <ul>
                    <li><strong>m:</strong> K√≠ch th∆∞·ªõc bit array</li>
                    <li><strong>n:</strong> S·ªë ph·∫ßn t·ª≠ ƒë∆∞·ª£c th√™m</li>
                    <li><strong>k:</strong> S·ªë hash functions</li>
                    <li><strong>P<sub>fp</sub>:</strong> False positive rate</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>üöÄ ·ª®ng d·ª•ng th·ª±c t·∫ø</h2>
            <div class="applications">
                <div class="application-card">
                    <h4>üåê Web Browsers</h4>
                    <p>Chrome s·ª≠ d·ª•ng Bloom Filter ƒë·ªÉ ki·ªÉm tra URLs c√≥ ph·∫£i l√† malicious kh√¥ng tr∆∞·ªõc khi g·ª≠i request ƒë·∫ßy ƒë·ªß ƒë·∫øn Google Safe Browsing.</p>
                </div>
                <div class="application-card">
                    <h4>üíæ Database Systems</h4>
                    <p>Cassandra, BigTable s·ª≠ d·ª•ng ƒë·ªÉ tr√°nh disk lookups kh√¥ng c·∫ßn thi·∫øt - n·∫øu Bloom Filter n√≥i "kh√¥ng c√≥" th√¨ ch·∫Øc ch·∫Øn kh√¥ng c·∫ßn ƒë·ªçc disk.</p>
                </div>
                <div class="application-card">
                    <h4>üìä Big Data</h4>
                    <p>Apache Spark, Hadoop s·ª≠ d·ª•ng ƒë·ªÉ optimize joins - lo·∫°i b·ªè partitions kh√¥ng c√≥ d·ªØ li·ªáu matching.</p>
                </div>
                <div class="application-card">
                    <h4>üîç Search Engines</h4>
                    <p>Elasticsearch s·ª≠ d·ª•ng ƒë·ªÉ quickly eliminate documents kh√¥ng ch·ª©a search terms.</p>
                </div>
                <div class="application-card">
                    <h4>üí∞ Cryptocurrency</h4>
                    <p>Bitcoin s·ª≠ d·ª•ng trong SPV (Simplified Payment Verification) ƒë·ªÉ clients c√≥ th·ªÉ verify transactions m√† kh√¥ng c·∫ßn download to√†n b·ªô blockchain.</p>
                </div>
                <div class="application-card">
                    <h4>üì± Mobile Apps</h4>
                    <p>WhatsApp s·ª≠ d·ª•ng ƒë·ªÉ ki·ªÉm tra contact c√≥ s·ª≠ d·ª•ng app kh√¥ng m√† kh√¥ng c·∫ßn upload to√†n b·ªô phone book.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üí° Design Trade-offs</h2>
            <div class="theory-section">
                <h3>‚úÖ ∆Øu ƒëi·ªÉm:</h3>
                <ul>
                    <li><strong>Memory efficient:</strong> Ch·ªâ c·∫ßn m bits cho n ph·∫ßn t·ª≠</li>
                    <li><strong>Fast operations:</strong> O(k) insert v√† lookup</li>
                    <li><strong>Privacy preserving:</strong> Kh√¥ng th·ªÉ reconstruct original data</li>
                    <li><strong>Scalable:</strong> Performance kh√¥ng ph·ª• thu·ªôc v√†o s·ªë ph·∫ßn t·ª≠ ƒë√£ th√™m</li>
                </ul>
                
                <h3>‚ùå Nh∆∞·ª£c ƒëi·ªÉm:</h3>
                <ul>
                    <li><strong>False positives:</strong> C√≥ th·ªÉ b√°o sai "c√≥" khi th·ª±c t·∫ø "kh√¥ng c√≥"</li>
                    <li><strong>Cannot delete:</strong> Kh√¥ng th·ªÉ x√≥a ph·∫ßn t·ª≠ (tr·ª´ khi d√πng Counting Bloom Filter)</li>
                    <li><strong>No enumeration:</strong> Kh√¥ng th·ªÉ list t·∫•t c·∫£ ph·∫ßn t·ª≠ trong filter</li>
                    <li><strong>Parameter sensitivity:</strong> C·∫ßn tune m, k, n c·∫©n th·∫≠n</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>üîß Implementation Tips</h2>
            <div class="theory-section">
                <h3>üéØ Best Practices:</h3>
                <ul>
                    <li><strong>Choose k carefully:</strong> S·ª≠ d·ª•ng k = (m/n) * ln(2) ƒë·ªÉ minimize false positive rate</li>
                    <li><strong>Good hash functions:</strong> S·ª≠ d·ª•ng independent, uniform hash functions (MurmurHash, SHA-1)</li>
                    <li><strong>Monitor load factor:</strong> Khi qu√° nhi·ªÅu bits ƒë∆∞·ª£c set, false positive rate tƒÉng exponentially</li>
                    <li><strong>Consider variants:</strong> Counting Bloom Filter cho deletion, Cuckoo Filter cho better performance</li>
                </ul>
                
                <h3>‚ö° Performance Optimization:</h3>
                <ul>
                    <li><strong>Bit-level operations:</strong> S·ª≠ d·ª•ng bitwise operations thay v√¨ arrays</li>
                    <li><strong>Cache-friendly:</strong> Arrange hash functions ƒë·ªÉ minimize cache misses</li>
                    <li><strong>Parallel hashing:</strong> Compute multiple hashes simultaneously</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        class BloomFilter {
            constructor(size, numHashFunctions) {
                this.size = size;
                this.numHashFunctions = numHashFunctions;
                this.bitArray = new Array(size).fill(0);
                this.elementsAdded = 0;
                this.addedElements = new Set(); // For tracking what we actually added
            }

            // Simple hash functions based on string hashing
            hash(item, seed) {
                let hash = seed;
                for (let i = 0; i < item.length; i++) {
                    hash = ((hash << 5) + hash + item.charCodeAt(i)) & 0x7fffffff;
                }
                return hash % this.size;
            }

            add(item) {
                const positions = [];
                for (let i = 0; i < this.numHashFunctions; i++) {
                    const position = this.hash(item, i + 1);
                    positions.push(position);
                    this.bitArray[position] = 1;
                }
                this.elementsAdded++;
                this.addedElements.add(item);
                return positions;
            }

            test(item) {
                const positions = [];
                for (let i = 0; i < this.numHashFunctions; i++) {
                    const position = this.hash(item, i + 1);
                    positions.push(position);
                    if (this.bitArray[position] === 0) {
                        return { result: false, positions, type: 'definite' };
                    }
                }
                // All positions are 1, so it might be in the set
                const actuallyAdded = this.addedElements.has(item);
                return { 
                    result: true, 
                    positions, 
                    type: actuallyAdded ? 'true_positive' : 'false_positive' 
                };
            }

            getBitsSet() {
                return this.bitArray.reduce((sum, bit) => sum + bit, 0);
            }

            getLoadFactor() {
                return (this.getBitsSet() / this.size * 100).toFixed(1);
            }

            clear() {
                this.bitArray.fill(0);
                this.elementsAdded = 0;
                this.addedElements.clear();
            }

            // Calculate theoretical false positive rate
            getFalsePositiveRate() {
                const k = this.numHashFunctions;
                const m = this.size;
                const n = this.elementsAdded;
                if (n === 0) return 0;
                const rate = Math.pow(1 - Math.exp(-k * n / m), k);
                return (rate * 100).toFixed(3);
            }
        }

        let bloomFilter = new BloomFilter(100, 3);

        function initializeBloomFilter() {
            const size = parseInt(document.getElementById('sizeSlider').value);
            const numHash = parseInt(document.getElementById('hashSlider').value);
            bloomFilter = new BloomFilter(size, numHash);
            updateDisplay();
            updateHashFunctions();
            updateOptimalParameters();
        }

        function updateDisplay() {
            const bitArrayDiv = document.getElementById('bitArray');
            bitArrayDiv.innerHTML = '';
            
            for (let i = 0; i < bloomFilter.size; i++) {
                const bit = document.createElement('div');
                bit.className = `bit ${bloomFilter.bitArray[i] ? 'one' : 'zero'}`;
                bit.textContent = bloomFilter.bitArray[i];
                bit.title = `Position ${i}`;
                bitArrayDiv.appendChild(bit);
            }

            // Update stats
            document.getElementById('elementsAdded').textContent = bloomFilter.elementsAdded;
            document.getElementById('bitsSet').textContent = bloomFilter.getBitsSet();
            document.getElementById('loadFactor').textContent = bloomFilter.getLoadFactor() + '%';
            document.getElementById('currentFPR').textContent = bloomFilter.getFalsePositiveRate() + '%';
        }

        function updateHashFunctions() {
            const hashDiv = document.getElementById('hashFunctions');
            let html = '<h4>üî® Hash Functions ƒë∆∞·ª£c s·ª≠ d·ª•ng:</h4>';
            for (let i = 1; i <= bloomFilter.numHashFunctions; i++) {
                html += `<div class="hash-function">hash${i}(x) = ((x << 5) + x + charCodes) % ${bloomFilter.size} v·ªõi seed=${i}</div>`;
            }
            hashDiv.innerHTML = html;
        }

        function highlightPositions(positions) {
            // Remove previous highlights
            document.querySelectorAll('.bit').forEach(bit => bit.classList.remove('highlight'));
            
            // Add highlights to new positions
            positions.forEach(pos => {
                const bitElements = document.querySelectorAll('.bit');
                if (bitElements[pos]) {
                    bitElements[pos].classList.add('highlight');
                }
            });

            // Remove highlights after 2 seconds
            setTimeout(() => {
                document.querySelectorAll('.bit').forEach(bit => bit.classList.remove('highlight'));
            }, 2000);
        }

        function addElement() {
            const input = document.getElementById('inputElement');
            const element = input.value.trim();
            
            if (!element) {
                alert('Vui l√≤ng nh·∫≠p m·ªôt ph·∫ßn t·ª≠!');
                return;
            }

            const positions = bloomFilter.add(element);
            updateDisplay();
            highlightPositions(positions);

            document.getElementById('result').innerHTML = `
                <div class="result positive">
                    ‚úÖ ƒê√£ th√™m "${element}" v√†o Bloom Filter<br>
                    Positions set: ${positions.join(', ')}
                </div>
            `;

            input.value = '';
        }

        function testElement() {
            const input = document.getElementById('inputElement');
            const element = input.value.trim();
            
            if (!element) {
                alert('Vui l√≤ng nh·∫≠p m·ªôt ph·∫ßn t·ª≠ ƒë·ªÉ ki·ªÉm tra!');
                return;
            }

            const testResult = bloomFilter.test(element);
            highlightPositions(testResult.positions);

            let resultHtml = '';
            if (!testResult.result) {
                resultHtml = `
                    <div class="result negative">
                        ‚ùå "${element}" CH·∫ÆC CH·∫ÆN KH√îNG c√≥ trong filter<br>
                        (T√¨m th·∫•y bit 0 t·∫°i position ${testResult.positions.find(pos => bloomFilter.bitArray[pos] === 0)})
                    </div>
                `;
            } else {
                if (testResult.type === 'true_positive') {
                    resultHtml = `
                        <div class="result positive">
                            ‚úÖ "${element}" C√ì TRONG filter (True Positive)<br>
                            T·∫•t c·∫£ positions ${testResult.positions.join(', ')} ƒë·ªÅu l√† 1
                        </div>
                    `;
                } else {
                    resultHtml = `
                        <div class="result maybe">
                            ‚ö†Ô∏è "${element}" C√ì TH·ªÇ c√≥ trong filter (False Positive!)<br>
                            T·∫•t c·∫£ positions ${testResult.positions.join(', ')} ƒë·ªÅu l√† 1 nh∆∞ng ph·∫ßn t·ª≠ n√†y ch∆∞a ƒë∆∞·ª£c th√™m
                        </div>
                    `;
                }
            }

            document.getElementById('result').innerHTML = resultHtml;
        }

        function clearFilter() {
            bloomFilter.clear();
            updateDisplay();
            document.getElementById('result').innerHTML = '';
        }

        function updateOptimalParameters() {
            const m = parseInt(document.getElementById('sizeSlider').value);
            const n = parseInt(document.getElementById('elementsSlider').value);
            const k = parseInt(document.getElementById('hashSlider').value);
            
            // Calculate theoretical false positive rate
            const fpr = Math.pow(1 - Math.exp(-k * n / m), k);
            const optimalK = (m / n) * Math.log(2);
            
            document.getElementById('falsePositiveRate').innerHTML = `
                <strong>Theoretical False Positive Rate:</strong> ${(fpr * 100).toFixed(3)}%<br>
                <strong>Optimal k for current m,n:</strong> ${optimalK.toFixed(2)}
            `;
        }

        // Event listeners for sliders
        document.getElementById('sizeSlider').addEventListener('input', function() {
            document.getElementById('sizeValue').textContent = this.value;
            initializeBloomFilter();
        });

        document.getElementById('hashSlider').addEventListener('input', function() {
            document.getElementById('hashValue').textContent = this.value;
            initializeBloomFilter();
        });

        document.getElementById('elementsSlider').addEventListener('input', function() {
            document.getElementById('elementsValue').textContent = this.value;
            updateOptimalParameters();
        });

        // Allow Enter key to add/test elements
        document.getElementById('inputElement').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addElement();
            }
        });

        // Initialize
        initializeBloomFilter();

        // Add some sample data for demonstration
        setTimeout(() => {
            const samples = ['apple', 'banana', 'cherry', 'date'];
            samples.forEach(item => {
                document.getElementById('inputElement').value = item;
                addElement();
            });
            document.getElementById('inputElement').value = '';
        }, 1000);
    </script>
</body>
</html>
